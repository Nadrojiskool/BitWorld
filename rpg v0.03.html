<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Indie RPG Project</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
    <script type="text/javascript" src="https://unpkg.com/bsv@0.27.2/bsv.min.js"></script>
</head>
<body>

<canvas id="myCanvas" width="1920" height="1080"></canvas>

<script src="https://www.moneybutton.com/moneybutton.js"></script>
<script src='https://unpkg.com/datapay'></script>
<script src='https://unpkg.com/databutton'></script>
<div id='my-money-button'></div>

<script>
// BSV Library //

  let bnMax = 99999999999999999999999999999999999999999999999999999999999999999999999999999n;
  let GX;
  let GY;
  let GI = 1;
  let priv = bsv.PrivateKey.fromRandom();
  let pub = bsv.PublicKey.fromPrivateKey(priv);
  let priv2 = bsv.PrivateKey.fromRandom();
  let pub2 = bsv.PublicKey.fromPrivateKey(priv2);
  let bn = priv.toBigNumber();
  let bn2 = priv2.toBigNumber();
  let bigNum = BigInt(bn) * BigInt(bn2);
  let bnPub = pub.point.getX();
  let bnPub2 = pub2.point.getX();
  let bigNumPub = BigInt(bnPub) * BigInt(bnPub2);

  function gOf(val) {
    GX = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getX().toString();
    GY = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getY().toString();
  }

</script>

<script>

  class GPS {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z; }}
  GPS.prototype.toString = function () {
    return (padXYZ(this.x, this.y, this.z)); };

  class Coord {
    constructor(x, y, xx = 0, yy = 0) {
      this.x = x;
      this.y = y;
      this.xx = xx;
      this.yy = yy; }}
  Coord.prototype.toString = function () {
    return (getCoord(this.x, this.y, this.xx, this.yy)); }

  class Land {
	  constructor(name, color) {
      this.name = name;
      this.color = color; }
  }

  // Property is an advanced and detailed piece of land (32x32 square)
  // Will replace BUILDING (or build on top)
  class Property {
	  constructor(type, terrain = [[]], objects = new Map(), capitol = null, production = 0) {
      this.type = type; // Draw/Structure ID
      this.terrain = terrain; // X&Y array of 32x32
      this.objects = objects; // Populated tiles
      this.capitol = capitol; // Logical parent tile
      this.production = production; // multiplier?
      this.units = new Map(); }
    calcProduction(skill) {
      let list = [ ...this.units.values() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
  }

  // Contracts alpha
  // Default no expiration and always active (24/7)
  class Contract {
	  constructor(period, exp = 0, active = 0) {
      this.period = period;
      this.expiration = exp;
      this.active = active; }
  }

  class Building {
    constructor(id) {
      this.id = id;
      this.units = new Map(); // contracts mapped to ssn
		  this.production = 0; }
    calcProduction(skill) {
      let list = [ ...this.units.keys() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
  }

  class Unit {
	  constructor(ssn, home, stats = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], name = "Shadders") {
      this.ssn = ssn; // unit list number
      this.home = home;
      this.name = name;
      this.stats = stats;
      this.work = null;
      this.skills = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.equipment = [];
      this.events = []; }} // currently list of events, eventually event tree

  /// Class to convert Stats array into object
  /// 0: Level (LVL) = 1 + Stats 10-30
  /// 1: Health (HP) = 10 * (2 + Tenacity(1) + Physique(2))
  /// 2: Attack (ATK) = 1 + Valor(5) * (Agility(3) + Physique(2))
  /// 3: Defense (DEF) = 1 + Valor(5) * (Agility(3) + Physique(2) + Tenacity(1))
  /// 4: Speed (SPD) = 1 / (101 - (Agility(3) * Tenacity(1)))
  class Stats { // must have array of length 10
    constructor(stats) {
      this.xp = stats[0];
      this.tenacity = stats[1];
      this.physique = stats[2];
      this.agility = stats[3];
      this.precision = stats[4];
      this.valor = stats[5];
      this.charisma = stats[6];
      this.intellect = stats[7];
      this.wisdom = stats[8];
      this.expertise = stats[9]; }}

  /// Class to convert skill xp pools into object
  class Skills {
    constructor(skills) {
      this.xp = skills[0]; }}

	class Army {
    units = [];
	  constructor(tileX, tileY, color, level = 0) {
      this.tileX = tileX;
      this.tileY = tileY;
      this.color = color;
      this.units = new Map();
      this.level = level;
      this.production = 0;
      this.health = 0;
      this.attack = 0;
      this.defense = 0;
      this.speed = 0;
      this.action = 0;
      this.timeCompleted = 0;
      this.direction = 0;
      this.moveX = 0;
      this.moveY = 0; }
      
      setStats() {

      }
      calcProduction(skill) {
        let list = [ ...this.units.keys() ];
        this.production = list.reduce((prod, ssn) =>
          prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
    }

  class Region { // resources = [0, food, currency, culture, lumber, stone, 0, 0, 0, 0]
    constructor(domain = [], resources = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.domain = domain;
      this.resources = resources; }
  }

  class Tech {
	  constructor(name, id, requiredTechs, researched = false) {
      this.name = name;
      this.id = id;
      this.requiredTechs = requiredTechs;
      this.researched = researched; }}

  /*let { MoneyButtonClient } = require('@moneybutton/api-client');
  let moneyButtonClient = new MoneyButtonClient(b3536e2a2b10f7fbf0177c9660aa5d35);
  moneyButtonClient.requestAuthorization('auth.user_identity:read', OAUTH_REDIRECT_URI);
  await moneyButtonClient.handleAuthorizationResponse();
  const { id: moneyButtonId } = await moneyButtonClient.getIdentity();*/

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let fieldX = 1920;
	let fieldY = 1080;
	let biomeDraws = ['#055000', 'white', "goldenrod"];
  let biomeNames = ["Grassland", "Snowy Region", "Desert"];
  let tileDraws = ['black', 'black', 'darkblue', '#808000', "rgba(150,150,150,1)", "rgba(69,69,69,1)", "rgba(69,69,69,1)"];
  let tileNames = ["Zero", "Fill", "Water", "Forest", "Mountain", "House", "Building", "Mine", "Lumber Mill"];
  let eventIndex = ["It's been a long day.",
    "Today was a good day.",
    "I met someone nice today.",
    "I'm late for work!",
    "I'm bored.",
    "I need a vacation.",
    "I'm in love.",
    "I love my job.",
    "I need a new job.",
    "I'm exhausted."
  ] // eventually replace with event generator and event trees

  let tileIndex = false; // render tile layer index for testing
  let infoMenu = false;
  let buyLand = false;
  let paintLand = false;

	let mapWidth = 999;
	let mapHeight = 999;
  let cameraX = 50 - 30;
  let cameraY = 50 - 17;
  let cursorX = 0;
  let cursorY = 0;
  let cursorMapX = 0;
  let cursorMapY = 0;
  let playerX = 50;
  let playerY = 50;
  let playerIncome = 0;
  let playerIncomeS = 0;
 // let GDP = 100000; // denominated in copper pieces, G:Cx10000
  let playerBank = [1000,0,0,0,0]; // $C, Wood, Stone,
  let selectedTileX = 0;
  let selectedTileY = 0;
  let selectedUnit = null;
  let selectedArmy = null;
  let selectedBuilding = null;
  let keyMap = {};
  let clickStart = 0;
  let clickEnd = 0;
  let clickLock = false;
  let tileAdded = false;
  let buildLand = 0;
  let uploading = false;
  let showUI = true;
  let showTech = false;

	let map = [];
	let tiles = [];
  let tileOwned = [];
  let tileLevel = [];
  let activeMenu = 0;
  let activeSubMenu = 0;
  let menuPage = 0;
  let nextPage = false;
  let planInfo = 0;

  let tileLogic = [];
  
  let techs = [
    [new Tech("Agriculture", [0, 0], [], true)],
    [new Tech("Pottery", [1, 0], []), new Tech("Animal Husbandry", [1, 1], []), 
      new Tech("Archery", [1, 2], []), new Tech("Mining", [1, 3], [])], 
    [new Tech("Sailing", [2, 0], [[1, 0]]), new Tech("Calendar", [2, 1], [[1, 0]]), new Tech("Writing", [2, 2], [[1, 0]]), 
      new Tech("Trapping", [2, 3], [[1, 1]]), new Tech("The Wheel", [2, 4], [[1, 1], [1, 2]]), 
      new Tech("Masonry", [2, 5], [[1, 3]]), new Tech("Bronze Working", [2, 6], [[1, 3]])],
    [new Tech("Optics", [3, 0], [[2, 0]]), new Tech("Horseback Riding", [3, 1], [[2, 3], [2, 4]]), 
      new Tech("Mathematics", [3, 2], [[2, 4]]), new Tech("Construction", [3, 3], [[2, 4], [2, 5]])],
    [new Tech("Philosophy", [4, 0], [[2, 1], [2, 2]]), new Tech("Drama", [4, 1], [[2, 2]]), new Tech("Currency", [4, 2], [[3, 2]]),
      new Tech("Engineering", [4, 3], [[3, 2], [3, 3]]), new Tech("Iron Working", [4, 4], [[2, 6]])]
  ]; // [tier][id]

  let menuText = [
    [],
    ["Btn", "Draw Tile Index", "Schematics", "Blueprints", "Technology"],
    ["Btn", "Build", "Buy Land", "Level Up (10X:1)", "", ""],
    ["Btn", "Citizens", "Spawn Unit"],
    ["Btn"],
    ["Btn", "Wood Pick", "Wood Axe", "Wood Sword", "Wood Spear", "Wood Shield", 
      "Stone Pick", "Stone Axe", "Stone Sword", "Stone Spear", "Stone Shield"],
    ["Btn", "House", "Lumbermill", "Mine", "Castle"],
    ["Btn"],
    ["Btn", "Zero", "Water", "Forest", "Mountain", "House", "Building", "Mine", "Lumber Mill"],
    ["Btn", "Deploy"]];

  let menuLogic = [[],[],[],[],[],[],[],[],[],[]];
  menuLogic[0][0] = () => {};

  menuLogic[1][0] = () => {}; // info menu main button function
  menuLogic[1][1] = () => {
    tileIndex = !tileIndex; };
  menuLogic[1][2] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 5 : 0; };
  menuLogic[1][3] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 6 : 0; };
  menuLogic[1][4] = () => {
    showUI = false;
    showTech = true; };

  menuLogic[2][0] = () => {}; // home menu main button function
  menuLogic[2][1] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 8 : 0; };
  menuLogic[2][2] = () => {
    buyLand = !buyLand; };
  menuLogic[2][3] = () => {
    if (playerBank[0] >= 100 * tileLevel[selectedTileX][selectedTileY]) {
      playerBank[0] -= 100 * tileLevel[selectedTileX][selectedTileY];
      tileLevel[selectedTileX][selectedTileY]++; }};
  menuLogic[2].push(() => {});
  menuLogic[2].push(() => {});

  menuLogic[3][0] = () => {}; // army menu main button function
  menuLogic[3][1] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 7 : 0; };
  menuLogic[3][2] = () => {
    let x = rnd(fieldX) + cameraX;
    let y = rnd(fieldY) + cameraY;
    createArmy(x, y, [createUnit(new GPS(0, 0, 0), true)]); };
    
  menuLogic[4][0] = () => {
    playerBank[0] += 100; }; // lovely button function

  menuLogic[5][0] = () => { menuPage++; }; // schematics menu
  menuLogic[5][1] = () => {};
  menuLogic[5][2] = () => {};
  menuLogic[5][3] = () => {};
  menuLogic[5][4] = () => {};
  menuLogic[5][5] = () => {};
  menuLogic[5][6] = () => {};
  menuLogic[5][7] = () => {};
  menuLogic[5][8] = () => {};
  menuLogic[5][9] = () => {};
  menuLogic[5][10] = () => {};

  menuLogic[6][0] = () => {}; // blueprints menu
  menuLogic[6][1] = () => {};
  menuLogic[6][2] = () => {};
  menuLogic[6][3] = () => {};
  menuLogic[6][4] = () => {};

  menuLogic[7][0] = () => { nextPage = true; }; // citizen list

  menuLogic[8][0] = () => {}; // build list
  menuLogic[8][1] = () => { buildLand = 1; };
  menuLogic[8][2] = () => { buildLand = 2; };
  menuLogic[8][3] = () => { buildLand = 3; };
  menuLogic[8][4] = () => { buildLand = 4; };
  menuLogic[8][5] = () => { buildLand = 5; };
  menuLogic[8][6] = () => { buildLand = 6; };
  menuLogic[8][7] = () => { buildLand = 7; };
  menuLogic[8][8] = () => { buildLand = 8; };

  menuLogic[9][0] = () => {}; // unit screen
  menuLogic[9][1] = () => {
    assignUnit();
  };

  let units = [];
  // !!! // IMPORTANT NOTE // TEMPORARY FIX // !!! //
  // army keys are handled by converting to and from STRING manually //
  // this was implemented to solve anonymous map access issues //
  // ideal solution is to be able to access map values with anonymous keys //
  // I.E. comparing objects by likeness, instead of memory value (cached) //
  // NOT IDEAL, IMO //
  let armies = new Map();

  {
    //createArmy(51, 49, [createUnit(new Coord(51, 49), true)]);
    //createArmy(51, 50, [createUnit(new Coord(51, 50), true)]);
    //createArmy(51, 51, [createUnit(new Coord(51, 51), true)]);
  }

  let regions = new Map();
  {
    let newRegion = new Region();
    let key = padXYZ(playerX, playerY, 0);
    regions.set(key, newRegion);
  }
  let buildings = new Map();
  let properties = new Map();
	let ID = [];
  let movement = [[0, 1, 0, -1, 0], [0, 0, 1, 0, -1]];
  let movementFull = [[0, 1, 1, 0, -1, -1, -1, 0, 1], [0, 0, 1, 1, 1, 0, -1, -1, -1]];

  const div = document.getElementById('my-money-button');

  /*
  var query = {
    v: 3,
    q: { find: {}, limit: 5 }
  };
  var b64 = btoa(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;

  var header = {
    headers: { key: "1CRKrBCUJDFyU3LsBAQRzwBkBPrjmDQasV" }
  };

  fetch(url, header).then(function(r) {
    return r.json()
  }).then(function(r) {
    var result = JSON.stringify(r, null, 2);
    document.querySelector("pre").innerHTML = result;
  })

  /*moneyButton.render(div, { // 
    to: "12cRRk9wn2LofWKE2wwxb7mw5qNeMaW7zH",
    amount: ".1",
    currency: "USD",
    label: "Hi",
    clientIdentifier: "RPG",
    buttonId: "IndieRPGProject",
    buttonData: "{}",
    type: "tip",
    onPayment: function (arg) { console.log('onPayment', arg) },
    onError: function (arg) { console.log('onError', arg) }
  })

  function upload(data)
  {
    /*moneyButton.render(div, {
      outputs: [{
        type: 'SCRIPT',
        script: data,
        amount: '.002',
        currency: 'USD'
      }]
    })
  }

  function uploadData(data)
  {
    //upload(bsv.Script.buildDataOut(arrMny).toASM());
  }*/

  // UNTESTED // Padding functions may malfunction if NUM has >1 significant digits
  // ALSO // Current default length of 3 relies on a map with max size of 999
  function padVal(val, length = 3, num = 0) {
    return val.toString().padStart(length, num) }

  function valPad(val, length = 3, num = 0) {
    return val.toString().padEnd(length, num) }

  // padXYZ() converts x, y, z into a single string for standardized use as an index //
  function padXYZ(x, y, z, length = 3, num = 0) {
    return (padVal(x, length, num) + padVal(y, length, num) + padVal(z, length, num)); }

  // sliceXYZ() reverts standardized index strings into a new GPS(x, y, z)
  function sliceXYZ(str) {
    return (new GPS(Number(str.slice(0, 3)), Number(str.slice(3, 6)), Number(str.slice(6, 9)))); }

  function getCoord(x, y, xx, yy) { // 000-00-000-00 // xx-x-yy-y
    return ((padVal(x) + padVal(xx, 2)) + (padVal(y) + padVal(yy, 2))); }

  function sliceCoord(str) { // x, y, xx, yy
    return ([Number(str.slice(0,3)), Number(str.slice(5,8)), Number(str.slice(3,5)), Number(str.slice(8,10))]) }

  function set(val, x, y, array) {
    array[x][y] = val; }

  function getSign(num) {
    return ((num == 0) ? 0 : (Math.abs(num) / num)); }
    
  function modulo(num, max) {
    return (num % max) }

	function rnd(max, min = 0) {
		return min + Math.floor(Math.random() * max); }

	function rndCeil(max, min = 0) {
		return min + Math.ceil(Math.random() * max); }

  function rndArray(length = 10, max = 4, min = 0, arr = []) {
    for (i = 0; i < length; i++) { 
      arr[i] = rnd(max, min); }
    return (arr); }

  // loop() returns num after looping it until within range //
  function loop(num, min, max) {
    range = max - min;
    if (num > max) {
      num -= range + 1; }
    else if (num < min) {
      num += range + 1; }
    if (num > max || num < min) {
      loop(num, min, max); }
    return num; }

  // JAVASCRIPT STRUGGLE-BUS //
  // I've tried and tried and tried, but can't figure out how this breaks //
  // When running the function traceProperty for BuyLand movement breaks //
  // I've currently removed range checking from movement pending tests //
  // This may require reverting this function to a true/false //
  // I liked adjusting value to edges of boundaries, but I give up on this //
  // This is one more beyond baffling and frustrating struggle with JavaScript //
  function range(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  function range2(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  // inRange() returns true if num is within min && max //
  // Solves issues of range() failing to return/set the correct value //
  function inRange(num, min = 0, max = 999) {
    return ((num <= max && num >= min) ? true : false ) }

  // contains() returns true if within rectangle bounds (x, y, width, height) //
  function contains(x, y, width, height, checkX, checkY) {
      return ((x <= checkX && checkX <= x + width && y <= checkY && checkY <= y + height) ? true : false); }

  function checkAdjacent(val, x, y, array = map) { // returns seed percentage
    let seed = 0;
    for (let i = 1; i <= 4; i++) {
      if (array[range(x + movement[0][i], 0, 999)][range(y + movement[1][i], 0, 999)] == val) {
        seed += .25; }}
    return seed; }

  function techAvailable(tech) {
    for (let i = 0; i < tech.requiredTechs.length; i++) {
      if (!techs[tech.requiredTechs[i][0]][tech.requiredTechs[i][1]].researched) {
        return false; }}
    return true; }

  function createUnit(home, r = false) {
    let unit = new Unit(units.length, home, rndArray(), "Shadders " + units.length);
    units.push(unit);
    menuText[7].push("Unit " + (units.length - 1));
    menuLogic[7].push(() => { clearUI(); selectTile(unit.home.x, unit.home.y); });
    if (r) return unit; }

  function assignUnit(tile = new GPS(selectedTileX, selectedTileY, 0),
      unit = units[selectedUnit]) {
    let key = padXYZ(tile.x, tile.y, 0);
    let building = buildings.get(key);
    if (building && building.units.size < 4 && !unit.work) {
      unit.work = gps;
      unit.events.push("I'm employed at the " + tileNames[tiles[tile.x][tile.y]] + "!")
      building.units.set(selectedUnit, new Contract(Date.now() + 30000));
      building.calcProduction(0); }
    else if (!building && !unit.work) {
      (armies.get(key)) ? armies.get(key).units.set(unit.ssn, unit)
        : createArmy(tile.x, tile.y, [unit], true);
      armies.get(key).calcProduction(0);
      unit.work = true; }
  }

  function createArmy(x, y, units = 0, r = false) {
    let army = new Army(0, 0, "blue", 10);
    let key = padXYZ(x, y, 0);
    if (units != 0) {
      for (let i = 0; i < units.length; i++) {
        army.units.set(units[i].ssn, units[i]); }
    armies.set(key, army); }
    if (r) { return army; }}

/*
  function setResources(region) {
    let res = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let workBonus;
    for (let i = 0; i < region.domain.length; i++) {
      gps = region.domain[i];
      key = padXYZ(gps.x, gps.y, gps.z);
      workBonus = (armies.has(key)) ? armies.get(key).level : 1;
      if (tiles[gps.x][gps.y] > 4) {
        res[3] += workBonus;
        res[2] += workBonus;
      }
      else {
        res[1] += workBonus;
      }
    }
    region.resources = res;
  } */

  function traceProperty(x, y) {
    do {
      y = y + movement[1][4];
    } while (tileOwned[x][y]);

    let xi = x;
    let yi = y;
    let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
    drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");
    xi = xi + movement[0][direction];
    yi = yi + movement[1][direction];

    do {
      drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

      direction = loop(direction + 1, 1, 4);
      if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
        do {
          direction = loop(direction - 1, 1, 4);
        } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }
      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];
      
      if (xi == x && yi == y) { return; }
    } while (buyLand);
  }

	async function generateMap() {
		for (let y = 0; y <= mapHeight; y++) {
			for (let x = 0; x <= mapWidth; x++) {
        if (y == 0) {
          map[x] = [];
          tiles[x] = [];
          tileOwned[x] = [];
          tileLevel[x] = []; }
				map[x][y] = 0;
				tiles[x][y] = 0; }}

    generateSnow();
    expandSnow();
    generateDesert();
    expandDesert();
    generateWater();
    expandWater();
    generateForests();
    expandForests();
    generateMountains();
    expandMountains(); }

  function layer(val, x, y, min, max, array = map) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 8; ii++) {
        for (let iii = 0; iii < i; iii++) {
          x += movementFull[0][ii];
          y += movementFull[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; }}}}

  function layerSq(val, x, y, min, max, array = map, addDomain = false) {
    for (let i = min; i <= max; i++) {
      let gps;
      let domainKey = padXYZ(playerX, playerY, 0);
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 4; ii++) {
        for (let iii = 0; iii < i * 2; iii++) {
          x += movement[0][ii];
          y += movement[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; 
          if (addDomain) {
            gps = new GPS(x, y, 0);
            regions.get(domainKey).domain.push(gps);
          }}}}}

  function pool(val, x, y, array) {
    let i = 0;
    let slope = 0;
    do {
      layer(val, x, y, i, i + 1, array);
      slope = rnd(9);
      i++; } while (slope == 0);
    return (slope); }

	function generateSnow() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 100; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 1;
      layer(1, x, y, 1, size, map); }}

	function generateDesert() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 150; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 2;
      layer(2, x, y, 1, size, map); }}

	function generateWater() {
    let slope;
    let current;
    let flow;
    let x;
    let y;
    for (let i = 0; i < 800; i++) {
      slope = rnd(9); // 0 causes a pool, forces new flow, !chance of new river
      flow = 3 * (rndCeil(30));
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      tiles[x][y] = 2;
      
      if (slope == 0) {
        slope = pool(2, x, y, tiles); }

      do {
        x = range((x + movementFull[0][slope]), 0, 999);
        y = range((y + movementFull[1][slope]), 0, 999);
        tiles[x][y] = 2;
        if (rnd(5) < 1) {
          slope = rnd(9);
          if (slope == 0) {
            slope = pool(2, x, y, tiles); }}

        flow--; } while (flow > 0); }}

	function generateForests() {
     let x;
     let y;
     for (let i = 0; i < 200000; i++) {
       x = rnd(999);
       y = rnd(999)
       if (tiles[x][y] == 0 && map[x][y] != 2) {
         tiles[x][y] = 3; }}}

	function generateMountains() {
    let x;
    let y;
    for (let i = 0; i < 100000; i++) {
      x = rnd(999);
      y = rnd(999)
      if (tiles[x][y] == 0) {
        tiles[x][y] = 4; }
      if (map[x][y] == 1 && rnd(7) >= 5) {
        layer(4, x, y, 1, 1, tiles); }}}

  function generateLand() {
    let gps = new GPS(playerX, playerY, 0);
    let key = padXYZ(playerX, playerY, 0);
    tileOwned[playerX][playerY] = true;
    regions.get(key).domain.push(gps);
    layerSq(true, playerX, playerY, 1, 3, tileOwned, true); }

  function expansion(val, def, gen, array = map) {
    for (let i = 0; i < def; i++) {
      for (let y = 0; y <= mapHeight; y++) {
        for (let x = 0; x <= mapWidth; x++) {
          if (array[x][y] != val) {
            let seed = checkAdjacent(val, x, y, array);
            if (rnd(100 * seed) > gen) {
              array[x][y] = val; }}}}}}

  function expandSnow() {
    expansion(1, 5, 15);
    expansion(1, 5, 30);
    expansion(1, 1, 75); }

  function expandDesert() {
    expansion(2, 5, 15);
    expansion(2, 5, 30);
    expansion(2, 2, 75); }

  function expandWater() {
    expansion(2, 2, 20, tiles);
    expansion(2, 2, 40, tiles);
    expansion(2, 2, 80, tiles); }

  function expandForests() {
    expansion(3, 1, 35, tiles);
    expansion(3, 1, 60, tiles);
    expansion(3, 1, 85, tiles); }

  function expandMountains() {
    expansion(4, 1, 25, tiles);
    expansion(4, 1, 50, tiles);
    expansion(4, 1, 80, tiles); }

  onkeydown = onkeyup = function(e) {
    e = e || event; // IE Compatibility
    keyMap[e.keyCode] = e.type == 'keydown'; }

  function moveTo(army, location) {
    let moveX = (army.moveX != 0) ? (army.moveX / (Math.abs(army.moveX))) : -(army.tileX / (Math.abs(army.tileX)));
    let moveY = (army.moveY != 0) ? (army.moveY / (Math.abs(army.moveY))) : -(army.tileY / (Math.abs(army.tileY)));
    if ((army.moveX != 0 || army.tileX != 0)
      && !armies.has(padXYZ(location.x + moveX, location.y, location.z))) {
      army.tileX += moveX;
      if (!inRange(army.tileX, -15, 16)) {
        army.tileX = loop(army.tileX, -15, 16);
        army.moveX -= moveX;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.x += moveX;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
    if ((army.moveY != 0 || army.tileY != 0) 
      && !armies.has(padXYZ(location.x, location.y + moveY, location.z))) {
      army.tileY += moveY;
      if (!inRange(army.tileY, -15, 16)) {
        army.tileY = loop(army.tileY, -15, 16);
        army.moveY -= moveY;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.y += moveY;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
  }
  
  function patrol(key, x = 50, y = 50, range = 25) {
    let army = armies.get(key);
    let location = sliceXYZ(key);
    let rndX = rnd(range * 2) - range;
    let rndY = rnd(range * 2) - range;
    army.moveX = x - location.x + rndX;
    army.moveY = y - location.y + rndY;
  }

  function logic() {
    if (nextPage) { menuPage++; nextPage = false; }
    if (keyMap[68] && inRange(cameraX + 1, 0, mapWidth - fieldX - 1)) { // d
      cameraX++; }
    if (keyMap[83] && inRange(cameraY + 1, 0, mapHeight - fieldY - 1)) { // s
      cameraY++; }
    if (keyMap[65] && inRange(cameraX - 1)) { // a
      cameraX--; }
    if (keyMap[87] && inRange(cameraY - 1)) { // w
      cameraY--; }
      
    if (keyMap[27]) { clearUI(); }


    selectedArmy = null;
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++){
      let location = sliceXYZ(key[i]);
      if (selectedTileX == location.x && selectedTileY == location.y) {
        selectedArmy = key[i]; }
      if (army[i].moveX != 0 || army[i].moveY != 0
          || army[i].tileX != 0 || army[i].tileY != 0) {
        moveTo(army[i], location); }
      else if (army[i].action == 1) {
        patrol(key[i]); }
    }

    if (buildLand != 0)
    {
      let x = cameraX + cursorMapX;
      let y = cameraY + cursorMapY;
      if (buildLand == 1 && clickEnd != 0) {
        tiles[x][y] = 0; }
      else {
        if (clickEnd != 0 && playerBank[0] >= 250 && tileOwned[x][y]
          && tiles[x][y] == 0) {
          tiles[x][y] = buildLand;
          if (buildLand >= 5) {
            tileLevel[x][y] = 1;
            buildings.set(new GPS(x, y, 0).toString(), new Building(buildings.length));
            playerBank[0] -= 250;
    }}}}
  }

  function logic1000() {
    //let key = padXYZ(playerX, playerY, 0);
    //let region = regions.get(key);

    let key = [ ...buildings.keys() ];
    let building = [ ...buildings.values() ];
    for (let i = 0; i < building.length; i++) {
      let location = sliceXYZ(key[i]);
      let gps = new GPS(location.x, location.y, 0);
      let contract = [ ...building[i].units.values() ];
      if (contract.length > 0) { settleContracts(gps, building[i], contract); }

      if (tiles[gps.x][gps.y] == 5 && rnd(50) >= 5 && building[i].units.size < 4) {
        let unit = createUnit(gps, true);
        unit.events.push("I now live at " + location + "!")
        building[i].units.set(unit.ssn, new Contract(Date.now() + 30000));
        building[i].calcProduction(0); }}

    /*for (y = 0; y <= mapHeight; y++) {
      for (x = 0; x <= mapWidth; x++) {
        if (tileOwned[x][y]) {
              let tile = tiles[x][y];
              if (Number.isInteger(tile) && tile == 5) {
                playerGold += tileLevel[x][y] * 10; }}
      }
    }*/
  }

  function logic5000() {
    let list = units;
    for (const unit of list) {
      if (rnd(100) == 50) {
        unit.events.push(eventIndex[rnd(10)]);
      }
    }
  }

  function settleContracts(gps, property, contracts) {
    for(const contract of contracts) {
      if (contract.period < Date.now()) {
        payContract(gps, property);
        contract.period = Date.now() + 30000; }
    }
  }

  function payContract(gps, property) {
    let index = tiles[gps.x][gps.y];
    if (index == 5) {
      playerBank[0] += 10 * property.production; }
    else if (index == 7) {
      playerBank[2] += 1 * property.production; }
    else if (index == 8) {
      playerBank[1] += 1 * property.production; }
  }

	function drawMap() {
		let size = 32;
    let land;
    let tile;
    let outlineColor;

    // draw first layer (land/biome) //
	for (let y = 0; y < fieldY; y++) {
		for (let x = 0; x < fieldX; x++) {
			land = map[x + cameraX][y + cameraY];
			outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
			  "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
			drawRectangle(x * 32, y * 32, size, size, true, true,
			  biomeDraws[land], outlineColor, "1"); }}

    // draw selected tile || tile @ cursor position //
    let rect = (selectedTileX != 0 && selectedTileY != 0) 
      ? [(selectedTileX - cameraX) * 32, (selectedTileY - cameraY) * 32, 32, 32] 
      : [cursorMapX * 32, cursorMapY * 32, 32, 32];
    drawRectangle(rect[0], rect[1], rect[2], rect[3], false, true, "black", "darkgray");

    // draw second layer (tiles)
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        tile = tiles[x + cameraX][y + cameraY];
        if (Number.isInteger(tile) && tile != 0) {
          if (tile >= 2 && tile <= 8) {
            tileDrawFuncs[tile](x * 32, y * 32); }
          else {
            drawRectangle(x * 32, y * 32, size, size, true, false, "black"); }
        }
      }
    }

    // trace the domain to show available lands for purchase //
    if (buyLand) {
      traceProperty(playerX, playerY); }

    // draw second layer index value on top of each tile //
    if (tileIndex) {
    	for (let y = 0; y < fieldY; y++) {
    		for (let x = 0; x < fieldX; x++) {
          drawText(tiles[x + cameraX][y + cameraY], 8 + x * 32, 28 + y * 32, "30px Arial"); }}}
  }

  function drawMod() {

  }

  function drawText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4) {
    ctx.font = font;
    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.strokeText(text, x, y); }
    ctx.fillStyle = color;
    ctx.fillText(text, x, y); }

  function drawRectangle(x, y, width, height, fill = true, stroke = true,
      fillColor = "black", strokeColor = "black", strokeWidth = "3") {
    ctx.beginPath();
    ctx.rect(x, y, width, height);
    if (stroke) { 
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    if (fill) { 
      ctx.fillStyle = fillColor; 
      ctx.fill(); }}

  function drawTriangle(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 2) {
    size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 28 * scale, y + 28 * scale - size);
    ctx.lineTo(x + 4 * scale, y + 28 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    ctx.fillStyle = color;
    ctx.fill();
  }
  
  function drawTree(x, y) {
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 4);
    ctx.lineTo(x + 28, y + 10);
    ctx.lineTo(x + 20, y + 10);
    ctx.lineTo(x + 28, y + 14);
    ctx.lineTo(x + 20, y + 14);
    ctx.lineTo(x + 28, y + 18);
    ctx.lineTo(x + 4, y + 18);
    ctx.lineTo(x + 12, y + 14);
    ctx.lineTo(x + 4, y + 14);
    ctx.lineTo(x + 12, y + 10);
    ctx.lineTo(x + 4, y + 10);
    ctx.lineTo(x + 16, y + 4);
    ctx.lineTo(x + 4, y + 28);
    ctx.fillStyle = "green";
    ctx.fill();
    ctx.beginPath();
    ctx.rect(x + 14, y + 18, 4, 10);
    ctx.fillStyle = "saddlebrown";
    ctx.fill();
  }

  function drawHouse(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 3) {
    let size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 28 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 4 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    ctx.fillStyle = color;
    ctx.fill(); }

  function drawBuilding(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 3) {
    let size = 0;
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 27 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 27 * scale, y + 28 * scale);
    ctx.lineTo(x + 5 * scale, y + 28 * scale);
    ctx.lineTo(x + 5 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    ctx.fillStyle = color;
    ctx.fill(); }

  function drawArmy(x, y, scale, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x + (16 * scale), y + (10 * scale), 6 * scale, 0, Math.PI * 2, true);
    ctx.moveTo(x + 16 * scale, y + 16 * scale);
    ctx.lineTo(x + 24 * scale, y + 28 * scale);
    ctx.lineTo(x + 8 * scale, y + 28 * scale);
    ctx.fill(); }

  function drawCapitol() {
    drawRectangle((playerX - cameraX) * 32 + 4, (playerY - cameraY) * 32 + 4, 24, 24,
      true, true, "rgba(169,169,169,0.35)", "rgba(0,0,0,0.5)");
    drawRectangle((playerX - cameraX) * 32 + 10, (playerY - cameraY) * 32 + 10, 12, 12,
      true, false, "rgba(0,0,0,0.8)");
  }

  function drawMenu(x, y, width, height, func = (() => {}), menuID = 0, 
      strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3", hoverFunc = (() => {})) {
    let overflow = (menuLogic[menuID].length <= 8) ? 0 : (8 * menuPage);
    let length = menuLogic[menuID].length - overflow;
    let menuLength = (length <= 8) ? length : 9;
    height += 64 * (menuLength - 1);
    if (contains(x, y, width, height, cursorX, cursorY)) {
      clickLock = true;
      strokeColor = "rgba(255,255,255,1)";
      strokeWidth = "5";
      { (clickEnd != 0) ? func() : hoverFunc(); }
    }
    drawRectangle(x, y, width, height, true, true, "rgba(0,0,0,0.05)", strokeColor);

    if (menuID != 0) {
      for (let i = 1 + overflow; i < menuLength + overflow; i++) {
        if (menuID == 7) { hoverFunc = (() => { 
          drawMenu(cursorX + 25, cursorY + 25, 320, 96);
          drawText(units[i - 1].name, cursorX + 25 + 32, cursorY + 32 + 32, "24px Arial", "lightgray", true);
          drawText(units[i - 1].stats, cursorX + 25 + 32, cursorY + 32 + 64, "24px Arial", "lightgray", true);
        }); }
        drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288, 32, menuLogic[menuID][i], 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
        drawText(menuText[menuID][i], x + 32, y - 8 + (64 * (i - overflow)), "24px Arial", "lightgray", true); }}}
        // CURRENTLY CLICK TO CHANGE PAGE, NEED BUTTON FOR OVERFLOW MENUS

  function drawTileUnits(tile, height, width) {
    drawMenu((fieldX - 11) * 32, 32 + height + 32, width, 192);
    drawText("Production: " + (tile.action), (fieldX - 10) * 32, height + 96, "30px Arial", "White");
    let func = (tile instanceof Army) ? () => { armies.get(selectedArmy).action = 1; } : () => {};
    drawMenu((fieldX - 3) * 32, 32 + height + 32, 64, 64, func);
    drawArmy((fieldX - 3) * 32, 32 + height + 32, 2, "rgba(0,0,200,.5)");
	  let ssns = [ ...tile.units.keys() ];
      for (i = 0; i < ssns.length; i++) {
        drawMenu((fieldX - 11) * 32, 128 + height + (32 * (i)), width, 32,
          () => { selectedUnit = ssns[i]; });
        drawText(units[ssns[i]].name + ": " + units[ssns[i]].stats, 
          (fieldX - 11) * 32 + 24, 160 + height - 8 + (32 * (i)), "24px Arial", "lightgray", true); }}

  function drawObj() {
    drawCapitol();

    // draw all standing armies //
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++) {
      let location = sliceXYZ(key[i]);
      drawArmy((location.x - cameraX) * 32 + army[i].tileX, (location.y - cameraY) * 32
        + army[i].tileY, 1, army[i].color); }}

  function drawUI() {
    let rect;
    let font;
    let color;
    let x;
    let y;
    let key = padXYZ(playerX, playerY, 0);
    let region = regions.get(key);

    if (buildLand != 0) {
      tileDrawFuncs[buildLand](cursorMapX * 32, cursorMapY * 32); }

    //let buf = bsv.crypto.Random.getRandomBuffer(32);
    //let bn3 = modulo(bigNum, bnMax);
    //let bnPub3 = modulo(bigNumPub, bnMax);
    //let buf2 = bsv.crypto.BN.fromString(bn3.toString()).toBuffer();
    //let bufPub = bsv.crypto.BN.fromString(bnPub3.toString()).toBuffer();
    //let priv3 = bsv.PrivateKey.fromBuffer(buf2);
    //let pub3 = bsv.PublicKey.fromX(true, bnPub3);
    //let pub3Priv = bsv.PublicKey.fromPrivateKey(priv3).point.getX();
    //let priv3 = bsv.
    // draw toolbar at top of screen //
    font = "30px Arial";
    drawText(cameraX, 8, 28, font);
    drawText(cameraY, 8 + 54, 28, font);
    drawText(playerBank[0] / 100, 8 + 112, 28, font, "silver");
    drawText("Lumber: " + playerBank[1], 8 + 112, 28 + 32, font, "brown");
    drawText("Stone: " + playerBank[2], 8 + 112, 28 + 64, font, "gray");
    drawText(fieldX, 8 + 176, 28, font);
    drawText(fieldY, 8 + 230, 28, font);
    /*drawText(priv, 8 + 192, 28, font, "silver");
    drawText(pub, 8 + 192, 28+32, font, "silver");
    drawText(priv2, 8 + 192,28+32+32, font, "silver");
    drawText(pub2, 8 + 192, 28+32+32+32, font, "silver");
    drawText(bn, 8 + 192,   28+32+32+32+32, font, "silver");
    drawText(bn2, 8 + 192,  28+32+32+32+32+32, font, "silver");
    drawText(bn3, 8 + 192,  28+32+32+32+32+32+32, font, "silver");
    drawText(bnPub, 8 + 192, 28+32+32+32+32+32+32+32, font, "silver");
    drawText(bnPub2, 8 + 192, 28+32+32+32+32+32+32+32+32, font, "silver");
    drawText(bnPub3, 8 + 192, 28+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(priv3, 8 + 192, 28+32+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(pub3.point.getX(), 8 + 192, 28+32+32+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(pub3Priv, 8 + 192, 28+32+32+32+32+32+32+32+32+32+32+32+32, font, "silver");*/
    drawText(fps, 8, 28 + 32, font);

    // info menu button
    rect = [32, 64, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[1][0]);
    ctx.font = "60px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("i", 57, 118);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 1 : 0; }

    // home menu button
    rect = [32, 160, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[2][0]);
    drawHouse(rect[0], rect[1], 2, "rgba(69,69,69,0.7)", true);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 2 : 0; }

    // army menu button
    rect = [32, 256, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[3][0]);
    drawArmy(rect[0], rect[1], 2, "rgba(0,0,200,.5)")
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 3 : 0; }

    // lovely button
    rect = [32, 352, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[4][0]);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 4 : 0; }

    // set menu size for tooltip menu //
    let width = 320;
    let height = 224;
    if (selectedTileX != 0 && selectedTileY != 0) {
      x = selectedTileX;
      y = selectedTileY;
      if (![0,1,2,3].includes(tiles[x][y])) {
        height = 448; } }
    else {
      x = cameraX + cursorMapX;
      y = cameraY + cursorMapY; }

    // draw tooltip menu //
    drawRectangle((fieldX - 11) * 32, 32, width, height, true, true, "rgba(0,0,0,0.05)", "rgba(0,0,0,0.25)");
    font = "40px Arial";
    color = "rgba(0,0,0,0.7)";
    drawText(biomeNames[map[x][y]], (fieldX - 10) * 32, 100, font, color);
    drawText(tileNames[tiles[x][y]], (fieldX - 10) * 32, 150, font, color);
    drawText("Owned: " + ((!tileOwned[x][y]) ? false : true), (fieldX - 10) * 32, 200, font, color);
    // if tile has logic, draw expanded tooltip menu elements //
    if (![0,1,2,3,4].includes(tiles[x][y])) {
      drawText("Level: " + tileLevel[x][y], (fieldX - 10) * 32, 250, font, color);
      drawText("Action: ", (fieldX - 10) * 32, 300, font, color);
      drawText("Pay In: ", (fieldX - 10) * 32, 350, font, color);
      drawMenu((fieldX - 10) * 32, 416, 112, 32);
      drawMenu((fieldX - 5.5) * 32, 416, 112, 32); }

    // if army is selected, draw underlying units info below tooltip menu //
    if (selectedArmy) {
      army = armies.get(selectedArmy);
      drawTileUnits(army, height, width); }
    if (selectedBuilding) {
      building = buildings.get(selectedBuilding);
      drawTileUnits(building, height, width); }
    if (selectedUnit && activeMenu == 0) {
      let unit = units[selectedUnit];
      let length = 32 * unit.events.length;
      drawMenu(128, 64, 320, 96 + length, menuLogic[9][0], 9);
      drawText("Stats: " + unit.stats, 128 + 16, 160);
      drawText("Skills: " + unit.skills, 128 + 16, 192)
      for (let i = 0; i < unit.events.length; i++) {
        drawText(unit.events[i], 128+16, 224 + (32 * i));
      }
    }

    // if main menu is active, draw from index with embedded menuLogic[] //
    if (activeMenu != 0) {
      drawMenu(128, 64, 320, 32, menuLogic[activeMenu][0], activeMenu); }

    // if main menu child is active, draw with indexed logic //
    if (activeSubMenu != 0) {
      drawMenu(480, 64, 320, 32, menuLogic[activeSubMenu][0], activeSubMenu); }

    // !!! INACTIVE !!! divert to new hoverFunc in drawMenu() //
    if (planInfo != 0) {
      drawMenu(832, 64, 128, 64); }
  }

  function clearUI() {
    activeMenu = 0;
    activeSubMenu = 0;
    menuPage = 0;
    buildLand = 0;
    buyLand = false;
    tileIndex = false;
    selectedTileX = 0;
    selectedTileY = 0;
    selectedUnit = null;
    selectedArmy = null;
    selectedBuilding = null;
    showUI = true;
    showTech = false; }

  // draw technology tree //
  function drawTech() {
    if (clickLock) { clickEnd = 0; } // spend click on first pass //
    let x;
    let y;
    for (i = 0; i < 5; i++) {
      for (ii = 0; ii < techs[i].length; ii++) {
        x = 64 + (i * 192);
        y = 64 + (ii * 96);

        if (techs[i][ii].researched) {
          drawMenu(x, y, 160, 64, () => {}, 0, "rgba(255,255,255,1)"); }
        else if (techAvailable(techs[i][ii])) {
          drawMenu(x, y, 160, 64, () => { techs[i][ii].researched = true; }, 0, "rgba(0,255,0,1)"); }
        else {
          drawMenu(x, y, 160, 64); }

        drawText(techs[i][ii].name, x + 32, y - 8, "24px Arial", "lightgray", true); }}
  }

  // draw canvas elements //
	async function draw() {
    clickLock = false;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.canvas.width  = window.innerWidth;
		ctx.canvas.height = window.innerHeight;
		fieldX = Math.ceil(ctx.canvas.width / 32);
		fieldY = Math.ceil(ctx.canvas.height / 32);
		drawMap();
    drawMod();
    drawObj();
    if (showUI) { drawUI(); }
    if (showTech) { drawTech(); }
    
    clickEnd = 0;
  }

	generateMap();
  generateLand();

  document.addEventListener("mousedown", mouseDownHandler, false);
  document.addEventListener("mouseup", mouseUpHandler, false);
  

  window.onload = init;
  function init() {
    if (window.Event) {
    document.captureEvents(Event.MOUSEMOVE); }
    document.onmousemove = getCursorXY; }

  function mouseDownHandler(e) {
    clickStart = Date.now();

    if (selectedArmy && !clickLock) {
      let army = armies.get(selectedArmy);
      let location = sliceXYZ(selectedArmy);
      army.moveX = (cameraX + cursorMapX) - location.x;
      army.moveY = (cameraY + cursorMapY) - location.y; }

    if (buyLand) {
      let x = playerX;
      let y = playerY;
      do {
        y = y + movement[1][4];
      } while (tileOwned[x][y]);

      let xi = x;
      let yi = y;
      let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
      if (playerBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
        tileOwned[xi][yi] = true;
        playerBank[0] -= 10;
        return; }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      do {
        if (playerBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
          tileOwned[xi][yi] = true;
          playerBank[0] -= 10;
          return; }

        direction = loop(direction + 1, 1, 4);
        if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
          do {
            direction = loop(direction - 1, 1, 4);
          } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }

        xi = xi + movement[0][direction];
        yi = yi + movement[1][direction];

        if (xi == x && yi == y) { return; }
      } while (true); }}

  function mouseUpHandler(e) {
    if (clickStart != 0) {
      clickEnd = Date.now() - clickStart;
      clickStart = 0; }

    if (cameraX + cursorMapX == selectedTileX && cameraY + cursorMapY == selectedTileY) {
      selectedTileX = 0;
      selectedTileY = 0;
      selectedBuilding = null; }
    else if (!clickLock) {
      selectTile(cameraX + cursorMapX, cameraY + cursorMapY); }}

  function selectTile(x, y) {
    selectedTileX = x;
    selectedTileY = y;
    let gps = new GPS(x, y, 0).toString();
    if (buildings.has(gps)) { selectedBuilding = gps; }}

  function getCursorXY(e) {
    let rect = canvas.getBoundingClientRect();
    cursorX = (event.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
    cursorY = (event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
    cursorMapX = Math.floor(cursorX / 32);
    cursorMapY = Math.floor(cursorY / 32); }

  const times = [];
  let fps;

  function refreshLoop() {
    window.requestAnimationFrame(() => {
      const now = performance.now();
      while (times.length > 0 && times[0] <= now - 1000) {
        times.shift(); }
      times.push(now);
      fps = times.length;
      refreshLoop(); }); }

  // uploadData();


  let tileDrawFuncs = [
    (x, y, color = "black", toStroke = false) => { 
		drawRectangle(x, y, 32, 32, true, toStroke,
		  color, "rgba(0,0,0,0.05)", "1"); }, 
    (x, y) => {}, 
    (x, y) => {
		drawRectangle(x, y, 32, 32, true, false, "darkblue"); },
    (x, y) => { 
      ctx.beginPath();
      ctx.moveTo(x + 16, y + 8);
      ctx.lineTo(x + 24, y + 24);
      ctx.lineTo(x + 8, y + 24);
      ctx.lineTo(x + 16, y + 8);
      ctx.fillStyle = "#6E2C00";
      ctx.strokeStyle = "black";
      ctx.lineWidth = "2";
      ctx.stroke();
      ctx.fill(); },
    (x, y) => { drawTriangle(x, y, 1, "rgba(150,150,150,0.7)", true); },
    (x, y) => { drawHouse(x, y, 1, "rgba(69,69,69,0.7)", true); },
    (x, y) => { drawBuilding(x, y, 1, "rgba(69,69,69,0.7)", true); },
    (x, y) => { drawRectangle(x, y, 32, 32); drawText("M", x + 6, y + 26, "24px Arial", "White", true); }, 
    (x, y) => { drawRectangle(x, y, 32, 32); drawText("L", x + 6, y + 26, "24px Arial", "White", true); }]

  refreshLoop();
	setInterval(logic, 20);
	setInterval(logic1000, 1000);
	setInterval(logic5000, 1000);
	setInterval(draw, 20);
</script>

</body>
</html>
