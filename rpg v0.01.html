<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <script type="text/javascript" src="https://unpkg.com/bsv@0.27.1/bsv.min.js"></script>
    <title>Indie RPG Project</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="1920" height="1080"></canvas>

<script src="https://www.moneybutton.com/moneybutton.js"></script>
<script src='https://unpkg.com/datapay'></script>
<script src='https://unpkg.com/databutton'></script>
<div id='my-money-button'></div>
<script>
</script>

<script>

  class GPS {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z; }}
  GPS.prototype.toString = function () {
    return (padXYZ(this.x, this.y, this.z)); };

  class Land {
	  constructor(name, color) {
      this.name = name;
      this.color = color; }
  }

  class Tile {
	  constructor(biome, capitol = null) {
      this.biome = biome;
      this.capitol = capitol; }
  }

  class Building {
    constructor(id) {
      this.id = id; }}

  class Unit { // stats [level, ]
	  constructor(name = "Shadders", stats = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.name = name;
      this.stats = stats;
      this.equipment = []; }}

	class Army {
    units = [];
	  constructor(tileX, tileY, color, level = 0) {
      this.tileX = tileX;
      this.tileY = tileY;
      this.color = color;
      this.level = level;
      this.health = 0;
      this.attack = 0;
      this.defense = 0;
      this.speed = 0;
      this.action = 0;
      this.timeCompleted = 0;
      this.direction = 0;
      this.moveX = 0;
      this.moveY = 0; }
      
      setStats() {

      }}

  class Region { // resources = [0, food, currency, culture, lumber, stone, 0, 0, 0, 0]
    constructor(domain = [], resources = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.domain = domain;
      this.resources = resources; }
  }

  class Tech {
	  constructor(name, id, requiredTechs, researched = false) {
      this.name = name;
      this.id = id;
      this.requiredTechs = requiredTechs;
      this.researched = researched; }}

  /*let { MoneyButtonClient } = require('@moneybutton/api-client');
  let moneyButtonClient = new MoneyButtonClient(b3536e2a2b10f7fbf0177c9660aa5d35);
  moneyButtonClient.requestAuthorization('auth.user_identity:read', OAUTH_REDIRECT_URI);
  await moneyButtonClient.handleAuthorizationResponse();
  const { id: moneyButtonId } = await moneyButtonClient.getIdentity();*/

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let biomeDraws = ['#055000', 'white', "goldenrod"];
  let biomeNames = ["Grassland", "Snowy Region", "Desert"];
  let tileDraws = ['black', 'black', 'darkblue', '#808000', "rgba(150,150,150,1)", "rgba(69,69,69,1)"];
  let tileNames = ["Zero", "Fill", "Water", "Forest", "Mountain", "House"];


  let tileIndex = false; // render tile layer index for testing
  let infoMenu = false;
  let buyLand = false;
  let paintLand = false;

	let mapWidth = 999;
	let mapHeight = 999;
  let cameraX = 50 - 30;
  let cameraY = 50 - 17;
  let cursorX = 0;
  let cursorY = 0;
  let cursorMapX = 0;
  let cursorMapY = 0;
  let playerX = 50;
  let playerY = 50;
  let playerIncome = 0;
  let playerIncomeS = 0;
  let playerGold = 100;
  let playerSilver = 20;
  let tileSelectX = 0;
  let tileSelectY = 0;
  let selectedArmy = null;
  let keyMap = {};
  let clickStart = 0;
  let clickEnd = 0;
  let clickLock = false;
  let tileAdded = false;
  let buildHouse = false;
  let uploading = false;
  let showUI = true;
  let showTech = false;

	let map = [];
	let tiles = [];
  let tileOwned = [];
  let tileAction = [];
  let tileCompleted = [];
  let tileLevel = [];
  let activeMenu = 0;
  let activeSubMenu = 0;
  let planInfo = 0;
  let units = [];
  units.push(new Unit(rndArray()));
  units.push(new Unit(rndArray()));
  units.push(new Unit(rndArray()));
  units.push(new Unit(rndArray()));
  units.push(new Unit(rndArray()));

  let tileLogic = [];
  
  let techs = [
    [new Tech("Agriculture", [0, 0], [], true)],
    [new Tech("Pottery", [1, 0], []), new Tech("Animal Husbandry", [1, 1], []), 
      new Tech("Archery", [1, 2], []), new Tech("Mining", [1, 3], [])], 
    [new Tech("Sailing", [2, 0], [[1, 0]]), new Tech("Calendar", [2, 1], [[1, 0]]), new Tech("Writing", [2, 2], [[1, 0]]), 
      new Tech("Trapping", [2, 3], [[1, 1]]), new Tech("The Wheel", [2, 4], [[1, 1], [1, 2]]), 
      new Tech("Masonry", [2, 5], [[1, 3]]), new Tech("Bronze Working", [2, 6], [[1, 3]])],
    [new Tech("Optics", [3, 0], [[2, 0]]), new Tech("Horseback Riding", [3, 1], [[2, 3], [2, 4]]), 
      new Tech("Mathematics", [3, 2], [[2, 4]]), new Tech("Construction", [3, 3], [[2, 4], [2, 5]])],
    [new Tech("Philosophy", [4, 0], [[2, 1], [2, 2]]), new Tech("Drama", [4, 1], [[2, 2]]), new Tech("Currency", [4, 2], [[3, 2]]),
      new Tech("Engineering", [4, 3], [[3, 2], [3, 3]]), new Tech("Iron Working", [4, 4], [[2, 6]])]
  ]; // [tier][id]

  let menuText = [
    [],
    ["Btn", "Draw Tile Index", "Schematics", "Blueprints", "Technology"],
    ["Btn", "Build House (25:1)", "Buy Land", "Level Up (10X:1)", "", ""],
    ["Btn", "Unit List", "Spawn Unit"],
    ["Btn"],
    ["Btn", "Wood Pick", "Wood Axe", "Wood Sword", "Wood Spear", "Wood Shield", 
      "Stone Pick", "Stone Axe", "Stone Sword", "Stone Spear", "Stone Shield"],
    ["Btn", "House", "Lumbermill", "Mine", "Castle"],
    ["Btn", "Unit 1", "Unit 2", "Unit 3", "Unit 4", "Unit 5"]];

  let menuLogic = [[],[],[],[],[],[],[],[]];
  menuLogic[0][0] = () => {};

  menuLogic[1][0] = () => {}; // info menu main button function
  menuLogic[1][1] = () => {
    tileIndex = !tileIndex; };
  menuLogic[1][2] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 5 : 0; };
  menuLogic[1][3] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 6 : 0; };
  menuLogic[1][4] = () => {
    showUI = false;
    showTech = true; };

  menuLogic[2][0] = () => {}; // home menu main button function
  menuLogic[2][1] = () => {
    buildHouse = !buildHouse; };
  menuLogic[2][2] = () => {
    buyLand = !buyLand; };
  menuLogic[2][3] = () => {
    if (playerGold >= 10 * tileLevel[tileSelectX][tileSelectY]) {
      playerGold -= 10 * tileLevel[tileSelectX][tileSelectY];
      tileLevel[tileSelectX][tileSelectY]++; }};
  menuLogic[2].push(() => {});
  menuLogic[2].push(() => {});

  menuLogic[3][0] = () => {}; // army menu main button function
  menuLogic[3][1] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 7 : 0; };
  menuLogic[3][2] = () => {
    armies.set(padXYZ(rnd(60) + cameraX, rnd(34) + cameraY, 0), new Army(0, 0, "blue")); };
    
  menuLogic[4][0] = () => {
    playerGold += 100; }; // lovely button function

  menuLogic[5][0] = () => {}; // schematics menu
  menuLogic[5][1] = () => {};
  menuLogic[5][2] = () => {};
  menuLogic[5][3] = () => {};
  menuLogic[5][4] = () => {};
  menuLogic[5][5] = () => {};
  menuLogic[5][6] = () => {};
  menuLogic[5][7] = () => {};
  menuLogic[5][8] = () => {};
  menuLogic[5][9] = () => {};
  menuLogic[5][10] = () => {};

  menuLogic[6][0] = () => {}; // blueprints menu
  menuLogic[6][1] = () => {};
  menuLogic[6][2] = () => {};
  menuLogic[6][3] = () => {};
  menuLogic[6][4] = () => {};

  menuLogic[7][0] = () => {}; // unit list
  menuLogic[7][1] = () => {};
  menuLogic[7][2] = menuLogic[7][1];
  menuLogic[7][3] = menuLogic[7][1];
  menuLogic[7][4] = menuLogic[7][1];
  menuLogic[7][5] = menuLogic[7][1];

  // !!! // IMPORTANT NOTE // TEMPORARY FIX // !!! //
  // army keys are handled by converting to and from STRING manually //
  // this was implemented to solve anonymous map access issues //
  // ideal solution is to be able to access map values with anonymous keys //
  // I.E. comparing objects by likeness, instead of memory value (cached) //
  // NOT IDEAL, IMO //
  let armies = new Map();
  {
    let newArmy = new Army(0, 0, "blue", 10);
    let key = padXYZ(playerX, playerY + 1, 0);
    newArmy.units.push(units[0]);
    newArmy.units.push(units[1]);
    newArmy.units.push(units[2]);
    armies.set(key, newArmy);
  }
  let regions = new Map();
  {
    let newRegion = new Region();
    let key = padXYZ(playerX, playerY, 0);
    regions.set(key, newRegion);
  }
  let buildings = new Map();
	let ID = [];
  let movement = [[0, 1, 0, -1, 0], [0, 0, 1, 0, -1]];
  let movementFull = [[0, 1, 1, 0, -1, -1, -1, 0, 1], [0, 0, 1, 1, 1, 0, -1, -1, -1]];

  const div = document.getElementById('my-money-button');
  //let bsv = require('bsv')

  /*
  var query = {
    v: 3,
    q: { find: {}, limit: 5 }
  };
  var b64 = btoa(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;

  var header = {
    headers: { key: "1CRKrBCUJDFyU3LsBAQRzwBkBPrjmDQasV" }
  };

  fetch(url, header).then(function(r) {
    return r.json()
  }).then(function(r) {
    var result = JSON.stringify(r, null, 2);
    document.querySelector("pre").innerHTML = result;
  })

  /*moneyButton.render(div, { // 
    to: "12cRRk9wn2LofWKE2wwxb7mw5qNeMaW7zH",
    amount: ".1",
    currency: "USD",
    label: "Hi",
    clientIdentifier: "RPG",
    buttonId: "IndieRPGProject",
    buttonData: "{}",
    type: "tip",
    onPayment: function (arg) { console.log('onPayment', arg) },
    onError: function (arg) { console.log('onError', arg) }
  })

  function upload(data)
  {
    /*moneyButton.render(div, {
      outputs: [{
        type: 'SCRIPT',
        script: data,
        amount: '.002',
        currency: 'USD'
      }]
    })
  }

  function uploadData(data)
  {
    //upload(bsv.Script.buildDataOut(arrMny).toASM());
  }*/

  // UNTESTED // Padding functions may malfunction if NUM has >1 significant digits
  // ALSO // Current default length of 3 relies on a map with max size of 999
  function padVal(val, length = 3, num = 0) {
    return val.toString().padStart(length, num) }

  function valPad(val, length = 3, num = 0) {
    return val.toString().padEnd(length, num) }

  // padXYZ() converts x, y, z into a single string for standardized use as an index //
  function padXYZ(x, y, z, length = 3, num = 0) {
    return (padVal(x, length, num) + padVal(y, length, num) + padVal(z, length, num)); }

  // sliceXYZ() reverts standardized index strings into a new GPS(x, y, z)
  function sliceXYZ(str) {
    return (new GPS(Number(str.slice(0, 3)), Number(str.slice(3, 6)), Number(str.slice(6, 9)))); }

  function set(val, x, y, array) {
    array[x][y] = val; }

  function getSign(num) {
    return ((num == 0) ? 0 : (Math.abs(num) / num)); }

	function rnd(max, min = 0) {
		return min + Math.floor(Math.random() * max); }

	function rndCeil(max, min = 0) {
		return min + Math.ceil(Math.random() * max); }

  function rndArray(length = 10, max = 4, min = 0, arr = []) {
    for (i = 0; i < length; i++) { 
      arr[i] = rnd(max, min); }
    return (arr); }

  // loop() returns num after looping it until within range //
  function loop(num, min, max) {
    range = max - min;
    if (num > max) {
      num -= range + 1; }
    else if (num < min) {
      num += range + 1; }
    if (num > max || num < min) {
      loop(num, min, max); }
    return num; }

  // JAVASCRIPT STRUGGLE-BUS //
  // I've tried and tried and tried, but can't figure out how this breaks //
  // When running the function traceProperty for BuyLand movement breaks //
  // I've currently removed range checking from movement pending tests //
  // This may require reverting this function to a true/false //
  // I liked adjusting value to edges of boundaries, but I give up on this //
  // This is one more beyond baffling and frustrating struggle with JavaScript //
  function range(num, min, max) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  // inRange() returns true if num is within min && max //
  // Solves issues of range() failing to return/set the correct value //
  function inRange(num, min = 0, max = 999) {
    return ((num <= max && num >= min) ? true : false ) }

  // contains() returns true if within rectangle bounds (x, y, width, height) //
  function contains(x, y, width, height, checkX, checkY) {
      return ((x <= checkX && checkX <= x + width && y <= checkY && checkY <= y + height) ? true : false); }

  function checkAdj(val, x, y, array = map) // returns seed percentage
  {
    let seed = 0;
    for (let i = 1; i <= 4; i++) {
      if (array[range(x + movement[0][i], 0, 999)][range(y + movement[1][i], 0, 999)] == val) {
        seed += .25; }}
    return seed; }

  function techAvailable(tech) {
    for (let i = 0; i < tech.requiredTechs.length; i++) {
      if (!techs[tech.requiredTechs[i][0]][tech.requiredTechs[i][1]].researched) {
        return false; }}
    return true; }

/*
  function setResources(region) {
    let res = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let workBonus;
    for (let i = 0; i < region.domain.length; i++) {
      gps = region.domain[i];
      key = padXYZ(gps.x, gps.y, gps.z);
      workBonus = (armies.has(key)) ? armies.get(key).level : 1;
      if (tiles[gps.x][gps.y] > 4) {
        res[3] += workBonus;
        res[2] += workBonus;
      }
      else {
        res[1] += workBonus;
      }
    }
    region.resources = res;
  } */

  function traceProperty(x, y) {
    do {
      y = y + movement[1][4];
    } while (tileOwned[x][y]);

    let xi = x;
    let yi = y;
    let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
    drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");
    xi = xi + movement[0][direction];
    yi = yi + movement[1][direction];

    do {
      drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

      direction = loop(direction + 1, 1, 4);
      if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
        do {
          direction = loop(direction - 1, 1, 4);
        } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }
      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];
      
      if (xi == x && yi == y) { return; }
    } while (buyLand);
  }

	async function generateMap() {
		for (let y = 0; y <= mapHeight; y++) {
			for (let x = 0; x <= mapWidth; x++) {
        if (y == 0) {
          map[x] = [];
          tiles[x] = [];
          tileOwned[x] = [];
          tileAction[x] = [];
          tileCompleted[x] = [];
          tileLevel[x] = []; }
				map[x][y] = 0;
				tiles[x][y] = 0; }}

    generateSnow();
    expandSnow();
    generateDesert();
    expandDesert();
    generateWater();
    expandWater();
    generateForests();
    expandForests();
    generateMountains();
    expandMountains(); }

  function layer(val, x, y, min, max, array = map) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 8; ii++) {
        for (let iii = 0; iii < i; iii++) {
          x += movementFull[0][ii];
          y += movementFull[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; }}}}

  function layerSq(val, x, y, min, max, array = map, addDomain = false) {
    for (let i = min; i <= max; i++) {
      let gps;
      let domainKey = padXYZ(playerX, playerY, 0);
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 4; ii++) {
        for (let iii = 0; iii < i * 2; iii++) {
          x += movement[0][ii];
          y += movement[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; 
          if (addDomain) {
            gps = new GPS(x, y, 0);
            regions.get(domainKey).domain.push(gps);
          }}}}}

  function pool(val, x, y, array) {
    let i = 0;
    let slope = 0;
    do {
      layer(val, x, y, i, i + 1, array);
      slope = rnd(9);
      i++; } while (slope == 0);
    return (slope); }

	function generateSnow() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 100; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 1;
      layer(1, x, y, 1, size, map); }}

	function generateDesert() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 150; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 2;
      layer(2, x, y, 1, size, map); }}

	function generateWater() {
    let slope;
    let current;
    let flow;
    let x;
    let y;
    for (let i = 0; i < 800; i++) {
      slope = rnd(9); // 0 causes a pool, forces new flow, !chance of new river
      flow = 3 * (rndCeil(30));
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      tiles[x][y] = 2;
      
      if (slope == 0) {
        slope = pool(2, x, y, tiles); }

      do {
        x = range((x + movementFull[0][slope]), 0, 999);
        y = range((y + movementFull[1][slope]), 0, 999);
        tiles[x][y] = 2;
        if (rnd(5) < 1) {
          slope = rnd(9);
          if (slope == 0) {
            slope = pool(2, x, y, tiles); }}

        flow--; } while (flow > 0); }}

	function generateForests() {
     let x;
     let y;
     for (let i = 0; i < 200000; i++) {
       x = rnd(999);
       y = rnd(999)
       if (tiles[x][y] == 0 && map[x][y] != 2) {
         tiles[x][y] = 3; }}}

	function generateMountains() {
    let x;
    let y;
    for (let i = 0; i < 100000; i++) {
      x = rnd(999);
      y = rnd(999)
      if (tiles[x][y] == 0) {
        tiles[x][y] = 4; }
      if (map[x][y] == 1 && rnd(7) >= 5) {
        layer(4, x, y, 1, 1, tiles); }}}

  function generateLand() {
    let gps = new GPS(playerX, playerY, 0);
    let key = padXYZ(playerX, playerY, 0);
    tileOwned[playerX][playerY] = true;
    regions.get(key).domain.push(gps);
    layerSq(true, playerX, playerY, 1, 3, tileOwned, true); }

  function expansion(val, def, gen, array = map) {
    for (let i = 0; i < def; i++) {
      for (let y = 0; y <= mapHeight; y++) {
        for (let x = 0; x <= mapWidth; x++) {
          if (array[x][y] != val) {
            let seed = checkAdj(val, x, y, array);
            if (rnd(100 * seed) > gen) {
              array[x][y] = val; }}}}}}

  function expandSnow() {
    expansion(1, 5, 15);
    expansion(1, 5, 30);
    expansion(1, 1, 75); }

  function expandDesert() {
    expansion(2, 5, 15);
    expansion(2, 5, 30);
    expansion(2, 2, 75); }

  function expandWater() {
    expansion(2, 2, 20, tiles);
    expansion(2, 2, 40, tiles);
    expansion(2, 2, 80, tiles); }

  function expandForests() {
    expansion(3, 1, 35, tiles);
    expansion(3, 1, 60, tiles);
    expansion(3, 1, 85, tiles); }

  function expandMountains() {
    expansion(4, 1, 25, tiles);
    expansion(4, 1, 50, tiles);
    expansion(4, 1, 80, tiles); }

  onkeydown = onkeyup = function(e) {
    e = e || event; // IE Compatibility
    keyMap[e.keyCode] = e.type == 'keydown'; }

  function ai(army, location) {
    let moveX = (army.moveX != 0) ? (army.moveX / (Math.abs(army.moveX))) : -(army.tileX / (Math.abs(army.tileX)));
    let moveY = (army.moveY != 0) ? (army.moveY / (Math.abs(army.moveY))) : -(army.tileY / (Math.abs(army.tileY)));
    if ((army.moveX != 0 || army.tileX != 0)
      && !armies.has(padXYZ(location.x + moveX, location.y, location.z))) {
      army.tileX += moveX;
      if (!inRange(army.tileX, -15, 16)) {
        army.tileX = loop(army.tileX, -15, 16);
        army.moveX -= moveX;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.x += moveX;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
    if ((army.moveY != 0 || army.tileY != 0) 
      && !armies.has(padXYZ(location.x, location.y + moveY, location.z))) {
      army.tileY += moveY;
      if (!inRange(army.tileY, -15, 16)) {
        army.tileY = loop(army.tileY, -15, 16);
        army.moveY -= moveY;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.y += moveY;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
  }

  function logic() {
    if (keyMap[68] && inRange(cameraX + 1, 0, mapWidth - 59)) { // d
      cameraX++; }
    if (keyMap[83] && inRange(cameraY + 1, 0, mapHeight - 33)) { // s
      cameraY++; }
    if (keyMap[65] && inRange(cameraX - 1)) { // a
      cameraX--; }
    if (keyMap[87] && inRange(cameraY - 1)) { // w
      cameraY--; }
      
    if (keyMap[27]) {
      activeMenu = 0;
      activeSubMenu = 0;
      buildHouse = false;
      buyLand = false;
      tileIndex = false;
      tileSelectX = 0;
      tileSelectY = 0;
      selectedArmy = null;
      showUI = true;
      showTech = false; }


    selectedArmy = null;
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++){
      let location = sliceXYZ(key[i]);
      if (tileSelectX == location.x && tileSelectY == location.y) {
        selectedArmy = key[i];
      }
      ai(army[i], location);
    }

    if (buildHouse)
    {
      let x = cameraX + cursorMapX;
      let y = cameraY + cursorMapY;
      if (clickEnd != 0 && playerGold >= 25 && tileOwned[x][y]
        && tiles[x][y] == 0) {
        tiles[x][y] = 5;
        tileAction[x][y] = 1;
        tileCompleted[x][y] = Date.now() + 10000;
        tileLevel[x][y] = 1;
        playerGold -= 25; }}
  }

  function logic1000() {
    //let key = padXYZ(playerX, playerY, 0);
    //let region = regions.get(key);

    for (y = 0; y <= mapHeight; y++) {
      for (x = 0; x <= mapWidth; x++) {
        if (tileOwned[x][y]) {
          if (tileAction[x][y] != 0) {
            if (tileCompleted[x][y] <= Date.now()) {
              let tile = tiles[x][y];
              if (Number.isInteger(tile) && tile == 5) {
                tileCompleted[x][y] = Date.now() + 10000;
                playerGold += tileLevel[x][y]; }}}}
      }
    }
  }

	function drawMap() {
		let size = 32;
    let land;
    let tile;
    let outlineColor;

    // draw first layer (land/biome) //
		for (let y = 0; y < 34; y++) {
			for (let x = 0; x < 60; x++) {
        land = map[x + cameraX][y + cameraY];
        outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
          "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
        drawRectangle(x * 32, y * 32, size, size, true, true,
          biomeDraws[land], outlineColor, "1"); }}

    // draw selected tile || tile @ cursor position //
    let rect = (tileSelectX != 0 && tileSelectY != 0) 
      ? [(tileSelectX - cameraX) * 32, (tileSelectY - cameraY) * 32, 32, 32] 
      : [cursorMapX * 32, cursorMapY * 32, 32, 32];
    drawRectangle(rect[0], rect[1], rect[2], rect[3], false, true, "black", "darkgray");

    // draw second layer (tiles)
    for (let y = 0; y < 34; y++) {
      for (let x = 0; x < 60; x++) {
        tile = tiles[x + cameraX][y + cameraY];
        if (Number.isInteger(tile) && tile != 0) {
          if (tile == 3) {
            ctx.beginPath();
            ctx.moveTo(x * 32 + 16, y * 32 + 8);
            ctx.lineTo(x * 32 + 24, y * 32 + 24);
            ctx.lineTo(x * 32 + 8, y * 32 + 24);
            ctx.lineTo(x * 32 + 16, y * 32 + 8);
    				ctx.fillStyle = "#6E2C00";
            ctx.strokeStyle = "black";
            ctx.lineWidth = "2";
            ctx.stroke();
            ctx.fill(); }
          else if (tile == 4) {
            drawTriangle(x * 32, y * 32, 1, "rgba(150,150,150,0.7)", true); }
          else if (tile == 5) {
            drawHouse(x * 32, y * 32, 1, "rgba(69,69,69,0.7)", true); }
          else {
            drawRectangle(x * 32, y * 32, size, size, true, false, tileDraws[tile]); }
        }
      }
    }

    // trace the domain to show available lands for purchase //
    if (buyLand) {
      traceProperty(playerX, playerY); }

    // draw second layer index value on top of each tile //
    if (tileIndex) {
    	for (let y = 0; y < 34; y++) {
    		for (let x = 0; x < 60; x++) {
          drawText(tiles[x + cameraX][y + cameraY], 8 + x * 32, 28 + y * 32, "30px Arial"); }}}
  }

  function drawMod() {

  }

  function drawText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4) {
    ctx.font = font;
    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.strokeText(text, x, y); }
    ctx.fillStyle = color;
    ctx.fillText(text, x, y); }

  function drawRectangle(x, y, width, height, fill = true, stroke = true,
      fillColor = "black", strokeColor = "black", strokeWidth = "3") {
    ctx.beginPath();
    ctx.rect(x, y, width, height);
    if (stroke) { 
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    if (fill) { 
      ctx.fillStyle = fillColor; 
      ctx.fill(); }}

  function drawTriangle(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 2) {
    size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 28 * scale, y + 28 * scale - size);
    ctx.lineTo(x + 4 * scale, y + 28 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    ctx.fillStyle = color;
    ctx.fill();
  }
  
  function drawTree(x, y) {
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 4);
    ctx.lineTo(x + 28, y + 10);
    ctx.lineTo(x + 20, y + 10);
    ctx.lineTo(x + 28, y + 14);
    ctx.lineTo(x + 20, y + 14);
    ctx.lineTo(x + 28, y + 18);
    ctx.lineTo(x + 4, y + 18);
    ctx.lineTo(x + 12, y + 14);
    ctx.lineTo(x + 4, y + 14);
    ctx.lineTo(x + 12, y + 10);
    ctx.lineTo(x + 4, y + 10);
    ctx.lineTo(x + 16, y + 4);
    ctx.lineTo(x + 4, y + 28);
    ctx.fillStyle = "green";
    ctx.fill();
    ctx.beginPath();
    ctx.rect(x + 14, y + 18, 4, 10);
    ctx.fillStyle = "saddlebrown";
    ctx.fill();
  }

  function drawHouse(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 3) {
    size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 28 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 4 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke(); }
    ctx.fillStyle = color;
    ctx.fill(); }

  function drawArmy(x, y, scale, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x + (16 * scale), y + (10 * scale), 6 * scale, 0, Math.PI * 2, true);
    ctx.moveTo(x + 16 * scale, y + 16 * scale);
    ctx.lineTo(x + 24 * scale, y + 28 * scale);
    ctx.lineTo(x + 8 * scale, y + 28 * scale);
    ctx.fill(); }

  function drawCapitol() {
    drawRectangle((playerX - cameraX) * 32 + 4, (playerY - cameraY) * 32 + 4, 24, 24,
      true, true, "rgba(169,169,169,0.35)", "rgba(0,0,0,0.5)");
    drawRectangle((playerX - cameraX) * 32 + 10, (playerY - cameraY) * 32 + 10, 12, 12,
      true, false, "rgba(0,0,0,0.8)");
  }

  function drawMenu(x, y, width, height, func = (() => {}), menuID = 0, 
      strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3", hoverFunc = (() => {})) {
    height += 64 * (menuLogic[menuID].length - 1);
    if (contains(x, y, width, height, cursorX, cursorY)) {
      if (menuID == 0) { clickLock = true; }
      strokeColor = "rgba(255,255,255,1)";
      strokeWidth = "5";
      { (clickEnd != 0) ? func() : hoverFunc(); }
    }
    drawRectangle(x, y, width, height, true, true, "rgba(0,0,0,0.05)", strokeColor);

    if (menuID != 0) {
      if (menuID == 7) { hoverFunc = (() => { drawMenu(cursorX + 25, cursorY + 25, 300, 100); }); }
      for (let i = 1; i < menuLogic[menuID].length; i++) {
        drawMenu(x + 16, y - 32 + (64 * (i)), 288, 32, menuLogic[menuID][i], 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
        drawText(menuText[menuID][i], x + 32, y - 8 + (64 * (i)), "24px Arial", "lightgray", true); }}}

  function drawObj() {
    drawCapitol();

    // draw all standing armies //
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++) {
      let location = sliceXYZ(key[i]);
      drawArmy((location.x - cameraX) * 32 + army[i].tileX, (location.y - cameraY) * 32
        + army[i].tileY, 1, army[i].color); }}

  function drawUI() {
    let rect;
    let font;
    let color;
    let x;
    let y;
    let key = padXYZ(playerX, playerY, 0);
    let region = regions.get(key);

    if (buildHouse) {
      drawHouse(cursorMapX * 32, cursorMapY * 32, 1, "rgba(69,69,69,0.7)", true); }

    // draw toolbar at top of screen //
    font = "30px Arial";
    drawText(cameraX, 8, 28, font);
    drawText(cameraY, 8 + 32, 28, font);
    drawText(playerGold, 8 + 128, 28, font, "gold");
    drawText(playerSilver, 8 + 192, 28, font, "silver");
    drawText(fps, 8, 28 + 32, font);

    // info menu button
    rect = [32, 64, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[1][0]);
    ctx.font = "60px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("i", 57, 118);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 1 : 0; }

    // home menu button
    rect = [32, 160, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[2][0]);
    drawHouse(rect[0], rect[1], 2, "rgba(69,69,69,0.7)", true);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 2 : 0; }

    // army menu button
    rect = [32, 256, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[3][0]);
    drawArmy(rect[0], rect[1], 2, "rgba(0,0,200,.5)")
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 3 : 0; }

    // lovely button
    rect = [32, 352, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[4][0]);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 4 : 0; }

    // set menu size for tooltip menu //
    let width = 320;
    let height = 224;
    if (tileSelectX != 0 && tileSelectY != 0) {
      x = tileSelectX;
      y = tileSelectY;
      if (![0,1,2,3].includes(tiles[x][y])) {
        height = 448; } }
    else {
      x = cameraX + cursorMapX;
      y = cameraY + cursorMapY; }

    // draw tooltip menu //
    drawRectangle(1568, 32, width, height, true, true, "rgba(0,0,0,0.05)", "rgba(0,0,0,0.25)");
    font = "40px Arial";
    color = "rgba(0,0,0,0.7)";
    drawText(biomeNames[map[x][y]], 1600, 100, font, color);
    drawText(tileNames[tiles[x][y]], 1600, 150, font, color);
    drawText("Owned: " + ((!tileOwned[x][y]) ? false : true), 1600, 200, font, color);
    // if tile has logic, draw expanded tooltip menu elements //
    if (![0,1,2,3,4].includes(tiles[x][y])) {
      drawText("Level: " + tileLevel[x][y], 1600, 250, font, color);
      drawText("Action: " + tileAction[x][y], 1600, 300, font, color);
      drawText("Pay In: " + Math.ceil((tileCompleted[x][y] - Date.now()) / 1000), 1600, 350, font, color);
      drawMenu(1600, 416, 112, 32);
      drawMenu(1744, 416, 112, 32); }

    // if army is selected, draw underlying units info below tooltip menu //
    if (selectedArmy) {
      army = armies.get(selectedArmy);
      drawMenu(1568, 32 + height + 32, width, 192);
      drawArmy(1824, 32 + height + 32, 2, "rgba(0,0,200,.5)");
      for (i = 0; i < army.units.length; i++) {
        drawText("Unit " + i + ": " + army.units[i].stats, 
          1568 + 24, 160 + height - 8 + (32 * (i)), "24px Arial", "lightgray", true); }}

    // if main menu is active, draw from index with embedded menuLogic[] //
    if (activeMenu != 0) {
      drawMenu(128, 64, 320, 32, menuLogic[0][0], activeMenu); }

    // if main menu child is active, draw with indexed logic //
    if (activeSubMenu != 0) {
      drawMenu(480, 64, 320, 32, menuLogic[0][0], activeSubMenu); }

    // !!! INACTIVE !!! divert to new hoverFunc in drawMenu() //
    if (planInfo != 0) {
      drawMenu(832, 64, 128, 64); }
  }

  // draw technology tree //
  function drawTech() {
    if (clickLock) { clickEnd = 0; } // spend click on first pass //
    let x;
    let y;
    for (i = 0; i < 5; i++) {
      for (ii = 0; ii < techs[i].length; ii++) {
        x = 64 + (i * 192);
        y = 64 + (ii * 96);

        if (techs[i][ii].researched) {
          drawMenu(x, y, 160, 64, () => {}, 0, "rgba(255,255,255,1)"); }
        else if (techAvailable(techs[i][ii])) {
          drawMenu(x, y, 160, 64, () => { techs[i][ii].researched = true; }, 0, "rgba(0,255,0,1)"); }
        else {
          drawMenu(x, y, 160, 64); }

        drawText(techs[i][ii].name, x + 32, y - 8, "24px Arial", "lightgray", true); }}
  }

  // draw canvas elements //
	async function draw() {
    clickLock = false;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawMap();
    drawMod();
    drawObj();
    if (showUI) { drawUI(); }
    if (showTech) { drawTech(); }
    
    clickEnd = 0;
  }

	generateMap();
  generateLand();

  document.addEventListener("mousedown", mouseDownHandler, false);
  document.addEventListener("mouseup", mouseUpHandler, false);
  

  window.onload = init;
  function init() {
    if (window.Event) {
    document.captureEvents(Event.MOUSEMOVE); }
    document.onmousemove = getCursorXY; }

  function mouseDownHandler(e) {
    clickStart = Date.now();

    if (selectedArmy) {
      let army = armies.get(selectedArmy);
      let location = sliceXYZ(selectedArmy);
      army.moveX = (cameraX + cursorMapX) - location.x;
      army.moveY = (cameraY + cursorMapY) - location.y; }

    if (buyLand) {
      let x = playerX;
      let y = playerY;
      do {
        y = y + movement[1][4];
      } while (tileOwned[x][y]);

      let xi = x;
      let yi = y;
      let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
      if (playerGold >= 1 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
        tileOwned[xi][yi] = true;
        playerGold--;
        return; }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      do {
        if (playerGold >= 1 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
          tileOwned[xi][yi] = true;
          playerGold--;
          return; }

        direction = loop(direction + 1, 1, 4);
        if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
          do {
            direction = loop(direction - 1, 1, 4);
          } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }

        xi = xi + movement[0][direction];
        yi = yi + movement[1][direction];

        if (xi == x && yi == y) { return; }
      } while (true); }}

  function mouseUpHandler(e) {
    if (clickStart != 0) {
      clickEnd = Date.now() - clickStart;
      clickStart = 0; }

    if (cameraX + cursorMapX == tileSelectX && cameraY + cursorMapY == tileSelectY) {
      tileSelectX = 0;
      tileSelectY = 0; }
    else if (!clickLock) {
      tileSelectX = cameraX + cursorMapX;
      tileSelectY = cameraY + cursorMapY; }}

  function getCursorXY(e) {
    let rect = canvas.getBoundingClientRect();
    cursorX = (event.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
    cursorY = (event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
    cursorMapX = Math.floor(cursorX / 32);
    cursorMapY = Math.floor(cursorY / 32); }

  const times = [];
  let fps;

  function refreshLoop() {
    window.requestAnimationFrame(() => {
      const now = performance.now();
      while (times.length > 0 && times[0] <= now - 1000) {
        times.shift(); }
      times.push(now);
      fps = times.length;
      refreshLoop(); }); }

  // uploadData();

  refreshLoop();
	setInterval(logic, 20);
	setInterval(logic1000, 1000);
	setInterval(draw, 20);
</script>

</body>
</html>
