<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <script type="text/javascript" src="https://unpkg.com/bsv@0.27.1/bsv.min.js"></script>
    <title>Indie RPG Project</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="1920" height="1080"></canvas>

<script src="https://www.moneybutton.com/moneybutton.js"></script>
<script src='https://unpkg.com/datapay'></script>
<script src='https://unpkg.com/databutton'></script>
<div id='my-money-button'></div>
<script>
</script>

<script>
	/*class Tile {
	  constructor(id, level) {
	    this.x = x;
      this.y = y;
      this.owned = false;
	  }
	}*/

  class Tuple {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
  }

  class Tile {

  }

  class Building {

  }

	class Unit {
	  constructor(x, y, color) {
	    //this.x = x;
      //this.y = y;
      this.color = color;
	  }
	}

  /*let { MoneyButtonClient } = require('@moneybutton/api-client');
  let moneyButtonClient = new MoneyButtonClient(b3536e2a2b10f7fbf0177c9660aa5d35);
  moneyButtonClient.requestAuthorization('auth.user_identity:read', OAUTH_REDIRECT_URI);
  await moneyButtonClient.handleAuthorizationResponse();
  const { id: moneyButtonId } = await moneyButtonClient.getIdentity();*/

	let canvas = document.getElementById("myCanvas");
	let ctx = canvas.getContext("2d");
	let biomeDraws = ['#055000', 'white'];
  let biomeNames = ["Grassland", "Snowy Region"];
  let tileDraws = ['black', 'black', 'blue', '#808000', "rgba(69,69,69,1)"];
  let tileNames = ["Zero", "Fill", "Water", "Forest", "House"];


  let tileIndex = false; // render tile layer index for testing
  let infoMenu = false;
  let buyLand = false;
  let paintLand = false;

	let mapWidth = 999;
	let mapHeight = 999;
  let cameraX = 50 - 30;
  let cameraY = 50 - 17;
  let cursorX = 0;
  let cursorY = 0;
  let cursorMapX = 0;
  let cursorMapY = 0;
  let playerX = 50;
  let playerY = 50;
  let playerIncome = 0;
  let playerIncomeS = 0;
  let playerGold = 100;
  let playerSilver = 20;
  let tileSelectX = 0;
  let tileSelectY = 0;
  let rightPressed = false;
  let leftPressed = false;
  let upPressed = false;
  let downPressed = false;
  let clickStart = 0;
  let clickEnd = 0;
  let clickLock = false;
  let tileAdded = false;
  let buildHouse = false;
  let uploading = false;

	let map = [];
	let tiles = [];
  let tileOwned = [];
  let tileAction = [];
  let tileCompleted = [];
  let tileLevel = [];
  let activeMenu = 0;
  let menuText = [
    [],
    ["Btn", "Draw Tile Index"],
    ["Btn", "Build House (25:1)", "Buy Land", "Level Up (10X:1)", ""],
    ["Btn", "Spawn Unit"],
    ["Btn"]];
  let menuLogic = [[],[],[],[],[]];
  menuLogic[0][0] = () => {};

  menuLogic[1][0] = () => {}; // info menu main button function
  menuLogic[1][1] = () => {
    tileIndex = !tileIndex; };

  menuLogic[2][0] = () => {}; // home menu main button function
  menuLogic[2][1] = () => {
    buildHouse = !buildHouse; };
  menuLogic[2][2] = () => {
    buyLand = !buyLand; };
  menuLogic[2][3] = () => {
    if (playerGold >= 10 * tileLevel[tileSelectX][tileSelectY]) {
      playerGold -= 10 * tileLevel[tileSelectX][tileSelectY];
      tileLevel[tileSelectX][tileSelectY]++; }};
  menuLogic[2].push(menuLogic[0][0]);
  menuLogic[2].push(menuLogic[0][0]);

  menuLogic[3][0] = () => {}; // unit menu main button function
  menuLogic[3][1] = () => {
    units.set(new Tuple(rnd(60) + cameraX, rnd(34) + cameraY, 0), "blue"); };
    
  menuLogic[4][0] = () => {
    playerGold += 100;
  }; // lovely button function

  //let objects = [];
  let units = new Map();
  units.set(new Tuple(40, 40, 0), "blue");
  let buildings = new Map();
  units.set(new Tuple(playerX, playerY, 0), "blue");
	let ID = [];
  let movement = [[0, 1, 0, -1, 0], [0, 0, 1, 0, -1]];
  let movementFull = [[0, 1, 1, 0, -1, -1, -1, 0, 1], [0, 0, 1, 1, 1, 0, -1, -1, -1]];

  const div = document.getElementById('my-money-button');
  //let bsv = require('bsv')

  /*
  var query = {
    v: 3,
    q: { find: {}, limit: 5 }
  };
  var b64 = btoa(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;

  var header = {
    headers: { key: "1CRKrBCUJDFyU3LsBAQRzwBkBPrjmDQasV" }
  };

  fetch(url, header).then(function(r) {
    return r.json()
  }).then(function(r) {
    var result = JSON.stringify(r, null, 2);
    document.querySelector("pre").innerHTML = result;
  })

  /*moneyButton.render(div, { // 
    to: "12cRRk9wn2LofWKE2wwxb7mw5qNeMaW7zH",
    amount: ".1",
    currency: "USD",
    label: "Hi",
    clientIdentifier: "RPG",
    buttonId: "IndieRPGProject",
    buttonData: "{}",
    type: "tip",
    onPayment: function (arg) { console.log('onPayment', arg) },
    onError: function (arg) { console.log('onError', arg) }
  })

  function upload(data)
  {
    /*moneyButton.render(div, {
      outputs: [{
        type: 'SCRIPT',
        script: data,
        amount: '.002',
        currency: 'USD'
      }]
    })
  }

  function uploadData(data)
  {
    //upload(bsv.Script.buildDataOut(arrMny).toASM());
  }*/

	function rnd(max, min = 0) {
		return min + Math.floor(Math.random() * max); }

	function rndCeil(max, min = 0) {
		return min + Math.ceil(Math.random() * max); }

  function loop(num, min, max) {
    range = max - min;
    if (num > max) {
      num -= range + 1; }
    else if (num < min) {
      num += range + 1; }
    if (num > max || num < min) {
      loop(num, min, max); }
    return num; }

  function range(num, min, max) {
    if (num > max) {
      num = max; }
    if (num < min) {
      num = min; }
    return num; }

  function contains(x, y, width, height, checkX, checkY) {
      if (x <= checkX && checkX <= x + width && y <= checkY && checkY <= y + height)
      {
        return true;
      }
      return false;
  }

  function checkAdj(val, x, y, array = map) // returns seed percentage
  {
    let seed = 0;
    for (let i = 1; i <= 4; i++)
    {
      if (array[range(x + movement[0][i], 0, 999)][range(y + movement[1][i], 0, 999)] == val)
      {
        seed += .25;
      }
    }
    return seed;
  }

  function traceProperty(x, y)
  {
    do {
      y = y + movement[1][4];
    } while (tileOwned[x][y]);

    let xi = x;
    let yi = y;
    let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
    drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

    xi = xi + movement[0][direction];
    yi = yi + movement[1][direction];

    do {
      drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

      direction = loop(direction + 1, 1, 4);

      if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
        do {
          direction = loop(direction - 1, 1, 4);
        } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]);
      }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      if (xi == x && yi == y) { return; }
    } while (true);
  }

	async function generateMap() {
		for (let y = 0; y <= mapHeight; y++)
		{
			for (let x = 0; x <= mapWidth; x++)
			{
        if (y == 0)
        {
          map[x] = [];
          tiles[x] = [];
          tileOwned[x] = [];
          tileAction[x] = [];
          tileCompleted[x] = [];
          tileLevel[x] = [];
          //objects[x] = [];
        }
				map[x][y] = 0;
				tiles[x][y] = 0;
				//tileOwned[x][y] = false;
			}
		}
    generateSnow();
    expandSnow();
    generateWater();
    expandWater();
    generateTrees();
    expandTrees();
	}

  function layer(val, x, y, min, max, array = map) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 8; ii++) {
        for (let iii = 0; iii < i; iii++) {
          x += movementFull[0][ii];
          y += movementFull[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; }}}}

  function layerSq(val, x, y, min, max, array = map) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 4; ii++) {
        for (let iii = 0; iii < i * 2; iii++) {
          x += movement[0][ii];
          y += movement[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; }}}}

  function pool(val, x, y, array) {
    let i = 0;
    let slope = 0;
    do {
      layer(val, x, y, i, i + 1, array);
      slope = rnd(9);
      i++; }
    while (slope == 0);
    return (slope); }

	function generateSnow() {
    let size;
    let move = 1;
    let x;
    let y;
    for (let i = 0; i < 50; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 1;
      layer(1, x, y, 1, size, map); }}

	function generateWater() {
    let slope;
    let current;
    let flow;
    let x;
    let y;
    for (let i = 0; i < 800; i++) {
      slope = rnd(9); // 0 causes a pool, forces new flow, !chance new river
      flow = 3 * (rndCeil(30));
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      tiles[x][y] = 2;
      if (slope == 0) {
        slope = pool(2, x, y, tiles);
      }
      do {
        x = range((x + movementFull[0][slope]), 0, 999);
        y = range((y + movementFull[1][slope]), 0, 999);
        tiles[x][y] = 2;
        if (rnd(5) < 1)
        {
          slope = rnd(9);
          if (slope == 0)
          {
            slope = pool(2, x, y, tiles);
          }
        }
        flow--;
      }
      while (flow > 0);
     }}

	function generateTrees() {
     let x;
     let y;
     for (let i = 0; i < 200000; i++) {
       x = rnd(999);
       y = rnd(999)
       if (tiles[x][y] == 0) {
         tiles[x][y] = 3; }}}

  function generateLand() {
    tileOwned[playerX][playerY] = true;
    layerSq(true, playerX, playerY, 1, 3, tileOwned); }

  function expansion(val, def, gen, array = map) {
    for (let i = 0; i < def; i++) {
      for (let y = 0; y <= mapHeight; y++) {
        for (let x = 0; x <= mapWidth; x++) {
          if (array[x][y] != val) {
            let seed = checkAdj(val, x, y, array);
            if (rnd(100 * seed) > gen) {
              array[x][y] = val; }}}}}}

  function expandSnow() {
    expansion(1, 5, 15);
    expansion(1, 5, 30);
    expansion(1, 1, 75); }

  function expandWater() {
    expansion(2, 2, 20, tiles);
    expansion(2, 2, 40, tiles);
    expansion(2, 2, 80, tiles); }

  function expandTrees() {
    expansion(3, 1, 35, tiles);
    expansion(3, 1, 60, tiles);
    expansion(3, 1, 85, tiles); }

  function logic() {
    if (rightPressed) {
      cameraX = range(++cameraX, 0, mapWidth - 59); }
    if (downPressed) {
      cameraY = range(++cameraY, 0, mapHeight - 33); }
    if (leftPressed) {
      cameraX = range(--cameraX, 0, mapWidth - 59); }
    if (upPressed) {
      cameraY = range(--cameraY, 0, mapHeight - 33); }

    if (buildHouse)
    {
      let x = cameraX + cursorMapX;
      let y = cameraY + cursorMapY;
      if (clickEnd != 0 && playerGold >= 25 && tileOwned[x][y]
        && ![1,4].includes(tiles[x][y])) {
        tiles[x][y] = 4;
        tileAction[x][y] = 1;
        tileCompleted[x][y] = Date.now() + 10000;
        tileLevel[x][y] = 1;
        playerGold -= 25;
      }
    }
  }

  function logic1000() {

    //units.set(new Tuple(cameraX + rnd(60), camera y + rnd(34), 0), "blue");
    for (y = 0; y <= mapHeight; y++) {
      for (x = 0; x <= mapWidth; x++) {
        if (tileOwned[x][y])
        {
          if (tileAction[x][y] != 0) {
            if (tileCompleted[x][y] <= Date.now()) {
              let tile = tiles[x][y];
              if (Number.isInteger(tile) && tile == 4) {
                tileCompleted[x][y] = Date.now() + 10000;
                playerGold += tileLevel[x][y];
              }
            }
          }
        }
      }
    }
  }

  function set(val, x, y, array) {
    array[x][y] = val;
  }

	function drawMap() {
		let size = 32;
		for (let y = 0; y < 34; y++) {
			for (let x = 0; x < 60; x++) {
        let land = map[x + cameraX][y + cameraY];
        let tile = tiles[x + cameraX][y + cameraY];

        let outlineColor;
        if (tileOwned[x + cameraX][y + cameraY] == true)
        {
          outlineColor = "rgba(0,0,255,0.35)";
        }
        else
        {
          outlineColor = "rgba(0,0,0,0.05)";
        }
				ctx.beginPath();
				ctx.rect(x * 32, y * 32, size, size);
				ctx.fillStyle = biomeDraws[land];
				ctx.strokeStyle = outlineColor;
				ctx.lineWidth = "1";
				ctx.fill();
				ctx.stroke();

        ctx.beginPath();
        if (tileSelectX != 0 && tileSelectY != 0)
        {
          ctx.rect((tileSelectX - cameraX) * 32, (tileSelectY - cameraY) * 32, 32, 32);
        }
        else {
          ctx.rect(cursorMapX * 32, cursorMapY * 32, 32, 32);
        }
        ctx.strokeStyle = "darkgray";
        ctx.lineWidth = "3";
        ctx.stroke();

        if (Number.isInteger(tile) && tile != 0)
        {
          if (tile == 3)
          {
            ctx.beginPath();
            ctx.moveTo(x * 32 + 16, y * 32 + 8);
            ctx.lineTo(x * 32 + 28, y * 32 + 28);
            ctx.lineTo(x * 32 + 4, y * 32 + 28);
    				ctx.fillStyle = "#6E2C00";
            //ctx.lineTo(x * 32 + 16, y * 32 + 8);
            ctx.fill();
          }
          else if (tile == 4)
          {
            drawHouse(x * 32, y * 32, 1, "rgba(69,69,69,0.7)", true);
          }
          else {
    				ctx.beginPath();
    				ctx.rect(x * 32, y * 32, size, size);
    				ctx.fillStyle = tileDraws[tile];
    				//ctx.strokeStyle = "rgba(0,0,0,0.05)";
    				//ctx.lineWidth = "1";
    				ctx.fill();
    				//ctx.stroke();
          }
        }
      }
    }


    if (buyLand) {
      traceProperty(playerX, playerY); }

    if (tileIndex) {
    	for (let y = 0; y < 34; y++)
      {
    		for (let x = 0; x < 60; x++)
        {
    			ctx.font = "30px Arial";
    			ctx.fillStyle = "black";
    			ctx.fillText(tiles[x + cameraX][y + cameraY], 8 + x * 32, 28 + y * 32);
        }
      }
    }
  }

  function drawMod()
  {

  }

  function drawText(text, x, y, font, color, stroke = false, strokeColor = "black", strokeWidth = 4)
  {
    ctx.font = font;
    if (stroke)
    {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.strokeText(text, x, y);
    }
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
  }

  function drawHouse(x, y, scale, color, stroke = false, strokeColor = "black", strokeWidth = 3)
  {
    size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    ctx.beginPath();
    ctx.moveTo(x + 16 * scale, y + 4 * scale - size);
    ctx.lineTo(x + 28 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 25 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 28 * scale);
    ctx.lineTo(x + 7 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 4 * scale, y + 16 * scale - size);
    ctx.lineTo(x + 16 * scale, y + 4 * scale - size);
    if (stroke)
    {
      ctx.strokeStyle = strokeColor;
      ctx.lineWidth = strokeWidth;
      ctx.stroke();
    }
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawUnit(x, y, scale, color)
  {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x + (16 * scale), y + (10 * scale), 6 * scale, 0, Math.PI * 2, true);
    ctx.moveTo(x + 16 * scale, y + 16 * scale);
    ctx.lineTo(x + 24 * scale, y + 28 * scale);
    ctx.lineTo(x + 8 * scale, y + 28 * scale);
    ctx.fill();
  }

  function drawMenu(x, y, width, height, func, menuID = 0) { //128, 64, 320, 32
    height += 64 * (menuLogic[menuID].length - 1);
    ctx.beginPath();
    ctx.rect(x, y, width, height);
    ctx.fillStyle = "rgba(0,0,0,0.05)";
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = "3";
    ctx.fill();
    ctx.stroke();

    if (menuID != 0)
    {
      for (let i = 1; i < menuLogic[menuID].length; i++)
      {
        drawMenu(144, y - 32 + (64 * (i)), 288, 32, menuLogic[menuID][i]);
        drawText(menuText[menuID][i], 164, y - 8 + (64 * (i)), "24px Arial", "lightgray", true);
      }
    }
    else if (contains(x, y, width, height, cursorX, cursorY))
    {
      clickLock = true;
      ctx.beginPath();
      ctx.rect(x, y, width, height);
      ctx.strokeStyle = "rgba(255,255,255,1)";
      ctx.lineWidth = "5";
      ctx.stroke();

      if (clickEnd != 0)
      {
        func();
      }
    }
  }

  function drawObj()
  {
    ctx.beginPath();
    ctx.rect((playerX - cameraX) * 32 + 4, (playerY - cameraY) * 32 + 4, 24, 24);
    ctx.fillStyle = "rgba(169,169,169,0.35)";
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    ctx.lineWidth = "3";
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.rect((playerX - cameraX) * 32 + 10, (playerY - cameraY) * 32 + 10, 12, 12)
    ctx.fill();

    units.forEach( (unit, key, map) => {
      drawText(key.x + key.y, 100, 100, "24px Arial", "gold");
      drawUnit((key.x - cameraX) * 32, (key.y - cameraY) * 32, 1, unit);
    });
  }

  function drawUI()
  {
    let rectangle;
    let x;
    let y;

    if (buildHouse) {
      drawHouse(cursorMapX * 32, cursorMapY * 32, 1, "rgba(69,69,69,0.7)", true);
    }

    ctx.font = "30px Arial";
    ctx.fillStyle = "black";
    ctx.fillText(cursorMapX, 8, 28);
    ctx.font = "30px Arial";
    ctx.fillStyle = "black";
    ctx.fillText(cursorMapY, 8 + 32, 28);
    ctx.font = "30px Arial";
    ctx.fillStyle = "gold";
    ctx.fillText(playerGold, 8 + 128, 28);
    ctx.font = "30px Arial";
    ctx.fillStyle = "silver";
    ctx.fillText(playerSilver, 8 + 192, 28);
    ctx.font = "30px Arial";
    ctx.fillStyle = "black";
    ctx.fillText(fps, 8, 28 + 50);

    // info menu button
    rect = [32, 64, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[1][0]);
    ctx.font = "60px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("i", 57, 118);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY))
    {
      activeMenu = (activeMenu == 0) ? 1 : 0;
    }

    // home menu button
    rect = [32, 160, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[2][0]);
    drawHouse(rect[0], rect[1], 2, "rgba(69,69,69,0.7)", true);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY))
    {
      activeMenu = (activeMenu == 0) ? 2 : 0;
    }

    // unit menu button
    rect = [32, 256, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[3][0]);
    drawUnit(rect[0], rect[1], 2, "rgba(0,0,200,.5)")
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY))
    {
      activeMenu = (activeMenu == 0) ? 3 : 0;
    }

    // lovely button
    rect = [32, 352, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[4][0]);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY))
    {
      activeMenu = (activeMenu == 0) ? 4 : 0;
    }

    let width = 320;
    let height = 224;
    if (tileSelectX != 0 && tileSelectY != 0)
    {
      x = tileSelectX;
      y = tileSelectY;
      if (![0,1,2,3].includes(tiles[x][y])) {
        height = 448; }
    }
    else {
      x = cameraX + cursorMapX;
      y = cameraY + cursorMapY;
    }
    ctx.beginPath();
    ctx.rect(1568, 32, width, height);
    ctx.fillStyle = "rgba(0,0,0,0.05)";
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = "3";
    ctx.fill();
    ctx.stroke();
    ctx.font = "40px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText(biomeNames[map[x][y]], 1600, 100);
    ctx.font = "40px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText(tileNames[tiles[x][y]], 1600, 150);
    ctx.font = "40px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("Owned: " + ((!tileOwned[x][y]) ? false : true), 1600, 200);

    if (![0,1,2,3].includes(tiles[x][y]))
    {
      ctx.font = "40px Arial";
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillText("Level: " + tileLevel[x][y], 1600, 250);
      ctx.font = "40px Arial";
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillText("Action: " + tileAction[x][y], 1600, 300);
      ctx.font = "40px Arial";
      ctx.fillStyle = "rgba(0,0,0,0.7)";
      ctx.fillText("Pay In: " + Math.ceil((tileCompleted[x][y] - Date.now()) / 1000), 1600, 350);
      drawMenu(1600, 416, 112, 32, () => {});
      drawMenu(1744, 416, 112, 32, () => {});
    }

    if (activeMenu != 0)
    {
      drawMenu(128, 64, 320, 32, menuLogic[0][0], activeMenu);
    }

    clickEnd = 0;
  }

	function draw() {
    clickLock = false;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawMap();
    drawMod();
    drawObj();
    drawUI(); }

	generateMap();
  generateLand();

  document.addEventListener("keydown", keyDownHandler, false);
  document.addEventListener("keyup", keyUpHandler, false);
  document.addEventListener("mousedown", mouseDownHandler, false);
  document.addEventListener("mouseup", mouseUpHandler, false);

  function mouseDownHandler(e) {
    clickStart = Date.now();

    if (activeMenu == 2) {
      let x = playerX;
      let y = playerY;
      do {
        y = y + movement[1][4];
      } while (tileOwned[x][y]);

      let xi = x;
      let yi = y;
      let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
      if (playerGold >= 1 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY))
      {
        tileOwned[xi][yi] = true;
        playerGold--;
        return;
      }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      do {
        if (playerGold >= 1 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY))
        {
          tileOwned[xi][yi] = true;
          playerGold--;
          return;
        }

        direction = loop(direction + 1, 1, 4);

        if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
          do {
            direction = loop(direction - 1, 1, 4);
          } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]);
        }

        xi = xi + movement[0][direction];
        yi = yi + movement[1][direction];

        if (xi == x && yi == y) { return; }
      } while (true);
    }
  }

  function mouseUpHandler(e) {
    if (clickStart != 0)
    {
      clickEnd = Date.now() - clickStart;
      clickStart = 0;
    }

    if (cameraX + cursorMapX == tileSelectX && cameraY + cursorMapY == tileSelectY)
    {
      tileSelectX = 0;
      tileSelectY = 0;
    }
    else if (!clickLock) {
      tileSelectX = cameraX + cursorMapX;
      tileSelectY = cameraY + cursorMapY;
    }
  }

  function keyDownHandler(e) {
      if(e.key == "d") {
          rightPressed = true; }
      if(e.key == "s") {
          downPressed = true; }
      if(e.key == "a") {
          leftPressed = true; }
      if(e.key == "w") {
          upPressed = true; }
      if (e.key == "Escape"){
        activeMenu = 0;
        buildHouse = false;
        buyLand = false;
        tileIndex = false;
        tileSelectX = 0;
        tileSelectY = 0; }}

  function keyUpHandler(e) {
      if(e.key == "d") {
          rightPressed = false; }
      if(e.key == "s") {
          downPressed = false; }
      if(e.key == "a") {
          leftPressed = false; }
      if(e.key == "w") {
          upPressed = false; }}

  window.onload = init;
  function init() {
    if (window.Event) {
    document.captureEvents(Event.MOUSEMOVE);
    }
    document.onmousemove = getCursorXY;
  }

  function getCursorXY(e) {
    let rect = canvas.getBoundingClientRect();
    cursorX = (event.clientX - rect.left) / (rect.right - rect.left) * canvas.width;
    cursorY = (event.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height;
    cursorMapX = Math.floor(cursorX / 32);
    cursorMapY = Math.floor(cursorY / 32);
  }

  const times = [];
  let fps;

  function refreshLoop() {
    window.requestAnimationFrame(() => {
      const now = performance.now();
      while (times.length > 0 && times[0] <= now - 1000) {
        times.shift();
      }
      times.push(now);
      fps = times.length;
      refreshLoop();
    });
  }

  // uploadData();

  refreshLoop();
	setInterval(logic, 20);
	setInterval(logic1000, 1000);
	setInterval(draw, 20);
</script>

</body>
</html>
