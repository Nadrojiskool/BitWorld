<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Indie RPG Project</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
    <script type="text/javascript" src="https://unpkg.com/bsv@0.27.2/bsv.min.js"></script>
</head>
<body>

<canvas id="canvas" width="1920" height="1080"></canvas>

<script src="https://unpkg.com/clientside-require/dist/bundle.js"></script>
<script src="https://www.moneybutton.com/moneybutton.js"></script>
<script src='https://unpkg.com/datapay'></script>
<script src='https://unpkg.com/databutton'></script>
<div id='my-money-button'></div>



<script>
// BSV Library // https://bico.media/150a366b2142fcab0c4a951884162a25bb50d1ee1188449769ddf966da27c11d

  let bnMax = 99999999999999999999999999999999999999999999999999999999999999999999999999999n;
  let GX;
  let GY;
  let GI = 1;
  let priv = bsv.PrivateKey.fromRandom();
  let pub = bsv.PublicKey.fromPrivateKey(priv);
  let priv2 = bsv.PrivateKey.fromRandom();
  let pub2 = bsv.PublicKey.fromPrivateKey(priv2);
  let bn = priv.toBigNumber();
  let bn2 = priv2.toBigNumber();
  let bigNum = BigInt(bn) * BigInt(bn2);
  let bnPub = pub.point.getX();
  let bnPub2 = pub2.point.getX();
  let bigNumPub = BigInt(bnPub) * BigInt(bnPub2);

  function gOf(val) {
    GX = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getX().toString();
    GY = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getY().toString();
  }

</script>

<script>

  // currently testing button events
  // if condition(input) evaluates true, run action
  class Element {
    constructor(i, o) {
      this.condition = i;
      this.action = o; }
    evaluate(input = 0) {
      return this.condition(input); }
  }

  class GPS {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z; }}
  GPS.prototype.toString = function () {
    return (padXYZ(this.x, this.y, this.z)); };

  class Coord {
    constructor(x, y, xx = 0, yy = 0) {
      this.x = x;
      this.y = y;
      this.xx = xx;
      this.yy = yy; }}
  Coord.prototype.toString = function () {
    return (getCoord(this.x, this.y, this.xx, this.yy)); }

  class Land {
	  constructor(owner = padXYZ(playerX, playerY, 0)) {
      this.owner = owner; }
  }

  // Property is an advanced and detailed piece of land (32x32 square)
  // Will replace BUILDING (or build on top)
  class Property {
	  constructor(type, terrain = [[]], objects = new Map(), capitol = null, production = 0) {
      this.type = type; // Draw/Structure ID
      this.terrain = terrain; // X&Y array of 32x32
      this.objects = objects; // Populated tiles
      this.capitol = capitol; // Logical parent tile
      this.production = production; // multiplier?
      this.units = new Map(); }
    calcProduction(skill) {
      let list = [ ...this.units.values() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
  }

  // Contracts alpha
  // Default no expiration and always active (24/7)
  class Contract {
	  constructor(promisor, promisee, period,
        pay = [1, 0], interval = 0, exp = 0, active = 0, 
        payFrom = promisor, payTo = promisee) {
      this.promisor = promisor;
      this.promisee = promisee;
      this.period = period;
      this.payment = new Payment(payFrom, payTo, pay[0], pay[1]);
      this.interval = interval;
      this.expiration = exp;
      this.active = active; }
  }

  class Payment {
    constructor(i, o, $, r, f = (()=>{})) {
      this.in = i;
      this.out = o;
      this.amount = $;
      this.resource = r;
      this.settlement = f;
    }
  }

  class Building {
    constructor(id) {
      this.id = id;
      this.units = new Map(); // contracts mapped to ssn
		  this.production = 0;
      this.condition = 0; }
    calcProduction(skill) {
      let list = [ ...this.units.keys() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
  }

  class Unit {
	  constructor(ssn, home, stats = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], name = genName()) {
      this.ssn = ssn; // unit list number
      this.home = home;
      this.name = name;
      this.stats = stats;
      this.work = null;
      this.skills = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      this.equipment = [];
      this.events = []; // list of events
      this.scenarios = new Map(); }} // progress by scenario index

  /// Class to convert Stats array into object
  /// 0: Level (LVL) = 1 + Stats 10-30
  /// 1: Health (HP) = 10 * (2 + Tenacity(1) + Physique(2))
  /// 2: Attack (ATK) = 1 + Valor(5) * (Agility(3) + Physique(2))
  /// 3: Defense (DEF) = 1 + Valor(5) * (Agility(3) + Physique(2) + Tenacity(1))
  /// 4: Speed (SPD) = 1 / (101 - (Agility(3) * Tenacity(1)))
  class Stats { // must have array of length 10
    constructor(stats) {
      this.xp = stats[0];
      this.tenacity = stats[1];
      this.physique = stats[2];
      this.agility = stats[3];
      this.precision = stats[4];
      this.valor = stats[5];
      this.charisma = stats[6];
      this.intellect = stats[7];
      this.wisdom = stats[8];
      this.expertise = stats[9]; }}

  /// Class to convert skill xp pools into object
  class Skills {
    constructor(skills) {
      this.xp = skills[0];
      this.gathering = skills[1];
      this.lumbering = skills[2];
      this.mining = skills[3];
      this.hunting = skills[4];
      this.cooking = skills[5]; }}

  class Event {
    constructor(id, input, output) {
      this.id = id;
      this.seed = input;
      this.value = output;
    }
  }
  // classes to conceptualize optimal citizen event tree progression
  class Scenario {
    constructor(events = []) {
      this.events = events;
    }
  }

  // Tasks:
  // 01: Patrol
  // 02: Gather Resource
	class Army {
    units = [];
	  constructor(tileX, tileY, color, level = 0) {
      this.tileX = tileX;
      this.tileY = tileY;
      this.color = color;
      this.units = new Map();
      this.level = level;
      this.production = 0;
      this.health = 0;
      this.attack = 0;
      this.defense = 0;
      this.speed = 0;
      this.task = 0;
      this.action = 0;
      this.direction = 0;
      this.moveX = 0;
      this.moveY = 0; }
      
      setStats() {

      }
      calcProduction(skill) {
        let list = [ ...this.units.keys() ];
        this.production = list.reduce((prod, ssn) =>
          prod + (Math.floor(units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
      setTask(task = 0, action = 0) {
        this.task = task;
        this.action = action; }
    }

  class Region { // resources = [0, food, currency, culture, lumber, stone, 0, 0, 0, 0]
    constructor(lord, domain = [], resources = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.lord = lord;
      this.domain = domain;
      this.resources = resources; }
  }

  class Tech {
	  constructor(name, id, requiredTechs, researched = false) {
      this.name = name;
      this.id = id;
      this.requiredTechs = requiredTechs;
      this.researched = researched; }}

  /*let { MoneyButtonClient } = require('@moneybutton/api-client');
  let moneyButtonClient = new MoneyButtonClient(b3536e2a2b10f7fbf0177c9660aa5d35);
  moneyButtonClient.requestAuthorization('auth.user_identity:read', OAUTH_REDIRECT_URI);
  await moneyButtonClient.handleAuthorizationResponse();
  const { id: moneyButtonId } = await moneyButtonClient.getIdentity();*/

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
  //canvas.offscreenCanvas = document.createElement('canvas');
  //canvas.offscreenCanvas.width = canvas.width;
  //canvas.offscreenCanvas.height = canvas.height;
  let isMobile = (/Mobile/i.test(navigator.userAgent));
  let snd = new Audio("https://bico.media/150a366b2142fcab0c4a951884162a25bb50d1ee1188449769ddf966da27c11d");
	snd.volume = 0.2;
  let fieldX = 1920;
	let fieldY = 1080;
	let biomeDraws = ['#055000', 'white', "goldenrod"];
  let biomeNames = ["Grassland", "Snowy Region", "Desert"];
  let tileDraws = ['black', 'black', 'darkblue', '#808000', "rgba(150,150,150,1)", "rgba(69,69,69,1)", "rgba(69,69,69,1)"];
  let canvasImages = [
    [
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ],
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ],
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ]
    ],
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas')
  ];
  canvasImages[0][0][0].width = 32;
  canvasImages[0][0][0].height = 32;
  canvasImages[0][0][1].width = 32;
  canvasImages[0][0][1].height = 32;
  canvasImages[0][1][0].width = 32;
  canvasImages[0][1][0].height = 32;
  canvasImages[0][1][1].width = 32;
  canvasImages[0][1][1].height = 32;
  canvasImages[0][2][0].width = 32;
  canvasImages[0][2][0].height = 32;
  canvasImages[0][2][1].width = 32;
  canvasImages[0][2][1].height = 32;
  canvasImages[1].width = 32;
  canvasImages[1].height = 32;
  canvasImages[2].width = 32;
  canvasImages[2].height = 32;
  canvasImages[3].width = 32;
  canvasImages[3].height = 32;
  canvasImages[4].width = 32;
  canvasImages[4].height = 32;
  canvasImages[5].width = 32;
  canvasImages[5].height = 32;
  canvasImages[6].width = 32;
  canvasImages[6].height = 32;
  canvasImages[7].width = 32;
  canvasImages[7].height = 32;
  canvasImages[8].width = 32;
  canvasImages[8].height = 32;
  let ctxImages = [
    [
      [
        canvasImages[0][0][0].getContext("2d"),
        canvasImages[0][0][1].getContext("2d")
      ],
      [
        canvasImages[0][1][0].getContext("2d"),
        canvasImages[0][1][1].getContext("2d")
      ],
      [
        canvasImages[0][2][0].getContext("2d"),
        canvasImages[0][2][1].getContext("2d")
      ]
    ],
    canvasImages[1].getContext("2d"),
    canvasImages[2].getContext("2d"),
    canvasImages[3].getContext("2d"),
    canvasImages[4].getContext("2d"),
    canvasImages[5].getContext("2d"),
    canvasImages[6].getContext("2d"),
    canvasImages[7].getContext("2d"),
    canvasImages[8].getContext("2d")
  ];
  let microImages = [
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas')
  ];
  microImages[0].width = 8;
  microImages[0].height = 8;
  microImages[1].width = 8;
  microImages[1].height = 8;
  microImages[2].width = 8;
  microImages[2].height = 8;
  let tileNames = ["Zero", "Fill", "Water", "Forest", "Mountain", "House", "Building", "Mine", "Lumber Mill"];
  let mNames = ["John",	"William",	"Robert",	"James",	"Charles",	"George",	"Joseph",	"Edward",	"Frank",	"Richard",	"Thomas",	"Harold",	"Walter",	"Paul",	"Raymond",	"Donald",	"Henry",	"Arthur",	"Albert",	"Jack",	"Harry",	"Ralph",	"Kenneth",	"Howard",	"David",	"Clarence",	"Carl",	"Louis",	"Willie",	"Eugene",	"Earl",	"Roy",	"Fred",	"Francis",	"Joe",	"Lawrence",	"Ernest",	"Leonard",	"Warren",	"Stanley",	"Herbert",	"Alfred",	"Anthony",	"Samuel",	"Elmer",	"Bernard",	"Norman",	"Leo",	"Andrew",	"Michael",	"Russell",	"Daniel",	"Edwin",	"Melvin",	"Chester",	"Leroy",	"Peter",	"Lloyd",	"Clifford",	"Frederick",	"Floyd",	"Marvin",	"Theodore",	"Gerald",	"Vernon",	"Herman",	"Ray",	"Clyde",	"Lester",	"Charlie",	"Philip",	"Lewis",	"Vincent",	"Milton",	"Leon",	"Alvin",	"Cecil",	"Martin",	"Jesse",	"Glenn",	"Victor",	"Lee",	"Benjamin",	"Sam",	"Gordon",	"Wayne",	"Harvey",	"Willard",	"Edgar",	"Oscar",	"Arnold",	"Claude",	"Wallace",	"Allen",	"Everett",	"Stephen",	"Gilbert",	"Wilbur",	"Johnnie",	"Homer",	"Virgil",	"Maurice",	"Roger",	"Eddie",	"Dale",	"Douglas",	"Sidney",	"Morris",	"Marion",	"Leslie",	"Jessie",	"Max",	"Hubert",	"Roland",	"Hugh",	"Irving",	"Alexander",	"Manuel",	"Franklin",	"Curtis",	"Bill",	"Glen",	"Luther",	"Nicholas",	"Julius",	"Jerome",	"Steve",	"Horace",	"Wesley",	"Jose",	"Tom",	"Billy",	"Willis",	"Orville",	"Oliver",	"Tony",	"Ben",	"Edmund",	"Calvin",	"Earnest",	"Mike",	"Alex",	"Jacob",	"Jerry",	"Archie",	"Otis",	"Jimmie",	"Don",	"Bruce",	"Delbert",	"Lyle",	"Matthew",	"Clayton",	"Guy",	"Angelo",	"Clifton",	"Salvatore",	"Clinton",	"Patrick",	"Wilbert",	"Bennie",	"Marshall",	"Ervin",	"Phillip",	"Jim",	"Nathaniel",	"Emil",	"Ronald",	"Rudolph",	"Ira",	"Merle",	"Nathan",	"Gene",	"Sylvester",	"Keith",	"Wilfred",	"Leland",	"Forrest",	"Ivan",	"Dean",	"Elbert",	"Irvin",	"Woodrow",	"Johnny",	"Dan",	"Lonnie",	"Nelson",	"Rufus",	"Bob",	"Antonio",	"Isaac",	"Johnie",	"Junior",	"Nick",	"Julian",	"Grover",	"Alton",	"Lowell",	"Aaron",	"Felix",	"Jay",	"Seymour",	"Abraham",	"Ellis",	"Pete",	"Otto",	"Dennis",	"Dewey",	"Emmett",	"Rex",	"August",	"Carroll",	"Juan",	"Roscoe",	"Grady",	"Percy",	"Owen",	"Bert",	"Mark",	"Elwood",	"Wilson",	"Loyd",	"Adam",	"Byron",	"Dominick",	"Fredrick",	"Malcolm",	"Laurence",	"Myron",	"Ross",	"Ted",	"Wendell",	"Perry",	"Dominic",	"Allan",	"Mack",	"Loren",	"Jesus",	"Murray",	"Billie",	"Adolph",	"Troy",	"Eldon",	"Norbert",	"Karl",	"Amos",	"Neil",	"Sherman",	"Charley",	"Harley",	"Preston",	"Aubrey",	"Austin",	"Reuben",	"Erwin",	"Boyd",	"Duane",	"Freddie",	"Wilmer",	"Carlton",	"Larry",	"Morton",	"Alan",	"Burton",	"Cornelius",	"Edmond",	"Carlos",	"Louie",	"Millard",	"Steven",	"Mitchell",	"Tommie",	"Dwight",	"Lynn",	"Gerard",	"Mario",	"Harrison",	"Garland",	"Elmo",	"Doyle",	"Elton",	"Grant",	"Russel",	"Jasper",	"Ramon",	"Moses",	"Kermit",	"Emanuel",	"Laverne",	"Maynard",	"Dave",	"Rocco",	"Neal",	"Will",	"Wade",	"Jake",	"Thurman",	"Francisco",	"Darrell",	"Monroe",	"Roosevelt",	"Cleveland",	"Solomon",	"Rodney",	"Cleo",	"Dallas",	"Earle",	"Joel",	"Tommy",	"Simon",	"Clair",	"Quentin",	"Odell",	"Ruben",	"Delmar",	"Irwin",	"Jess",	"Elvin",	"Harlan",	"Alphonse",	"Dick",	"Stuart",	"Armand",	"Weldon",	"Jimmy",	"Marcus",	"Andy",	"Merlin",	"Gus",	"Claud",	"Ed",	"Alonzo",	"Clark",	"Clement",	"Emory",	"Conrad",	"Thaddeus",	"Orval",	"Christopher",	"Randolph",	"Bruno",	"Carmen",	"Forest",	"Ollie",	"Merrill",	"Patsy",	"Ward",	"Adrian",	"Alfonso",	"Ned",	"Emery",	"Pedro",	"Alva",	"Buford",	"Cyril",	"Elijah",	"Jean",	"Vito",	"Reginald",	"Vern",	"Hollis",	"Benny",	"Lionel",	"Stewart",	"Hyman",	"Timothy",	"Wilburn",	"Sammie",	"Barney",	"Wiley",	"Truman",	"Anton",	"Emerson",	"Sterling",	"Levi",	"Eli",	"Mervin",	"Wilford",	"Roman",	"Sol",	"Ellsworth",	"Herschel",	"Basil",	"Noah",	"Coy",	"Travis",	"Teddy",	"Lavern",	"Jackson",	"Miles",	"Harding",	"Milford",	"Spencer",	"Norris",	"Winfred",	"Harris",	"Hiram",	"Silas",	"Milo",	"Van",	"Luis",	"Sanford",	"Carmine",	"Rolland",	"Winston",	"Ambrose",	"Pasquale",	"Abe",	"Buster",	"Jeff",	"Mathew",	"Vance",	"Casimir",	"Noel",	"Saul",	"Pat",	"Salvador",	"Foster",	"Freeman",	"Gabriel",	"Lenard",	"Bertram",	"Royal",	"Sheldon",	"Dudley",	"Isadore",	"Noble",	"Shirley",	"Booker",	"Mary",	"Aloysius",	"Hershel",	"Odis",	"Frederic",	"Hal",	"Scott",	"Denver",	"Lorenzo",	"Newton",	"Omer",	"Ulysses",	"Delmer",	"Olin",	"Bud",	"Eric",	"Ferdinand",	"Lamar",	"Lyman",	"Orlando",	"Alden",	"Anderson",	"Chris",	"Elliott",	"Gregory",	"Raul",	"Sydney",	"Gale",	"Guadalupe",	"Burl",	"Darwin",	"Houston",	"Micheal",	"Cletus",	"Royce",	"Marlin",	"Gail",	"Randall",	"Bobby",	"Major",	"Elias",	"Hobert",	"Luke",	"Riley",	"Augustus",	"Everette",	"Hoyt",	"Olen",	"Armando",	"Hugo",	"Linwood",	"Morgan",	"Evan",	"Warner",	"Wilton",	"Arlie",	"Nolan",	"Rupert",	"Jefferson",	"Dewitt",	"Junius",	"Walker",	"Wilber",	"Al",	"Merton",	"Waldo",	"Mckinley",	"Roberto",	"Clay",	"Lemuel",	"Shelby"];
  let fNames = ["Mary",	"Dorothy",	"Helen",	"Margaret",	"Ruth",	"Mildred",	"Virginia",	"Elizabeth",	"Frances",	"Anna",	"Betty",	"Evelyn",	"Marie",	"Doris",	"Alice",	"Florence",	"Irene",	"Lillian",	"Louise",	"Rose",	"Catherine",	"Gladys",	"Martha",	"Marjorie",	"Eleanor",	"Ruby",	"Edna",	"Josephine",	"Lucille",	"Ethel",	"Thelma",	"Edith",	"Jean",	"Hazel",	"Annie",	"Pauline",	"Grace",	"Lois",	"Esther",	"Bernice",	"Beatrice",	"Gertrude",	"Marion",	"Clara",	"Katherine",	"Emma",	"Barbara",	"Jane",	"Ann",	"Sarah",	"Elsie",	"Rita",	"June",	"Agnes",	"Julia",	"Shirley",	"Bertha",	"Eva",	"Viola",	"Geraldine",	"Juanita",	"Pearl",	"Laura",	"Vivian",	"Anne",	"Ida",	"Kathryn",	"Myrtle",	"Norma",	"Lorraine",	"Bessie",	"Phyllis",	"Marian",	"Willie",	"Vera",	"Nellie",	"Violet",	"Wilma",	"Charlotte",	"Alma",	"Maxine",	"Stella",	"Mabel",	"Jessie",	"Sylvia",	"Genevieve",	"Minnie",	"Ella",	"Leona",	"Lillie",	"Kathleen",	"Ellen",	"Marguerite",	"Lucy",	"Nancy",	"Mattie",	"Jennie",	"Lena",	"Mae",	"Eileen",	"Opal",	"Blanche",	"Audrey",	"Patricia",	"Velma",	"Geneva",	"Elaine",	"Theresa",	"Beulah",	"Dolores",	"Sara",	"Harriet",	"Georgia",	"Jeanne",	"Eunice",	"Rosa",	"Wanda",	"Christine",	"Emily",	"Loretta",	"Carrie",	"Inez",	"Muriel",	"Janet",	"Hilda",	"Jeanette",	"Fannie",	"Alberta",	"Sophie",	"Maria",	"Anita",	"Hattie",	"Dora",	"Naomi",	"Verna",	"Ada",	"Cora",	"Madeline",	"Lula",	"Miriam",	"Rosemary",	"Mamie",	"Joan",	"Roberta",	"Arlene",	"Olga",	"Lola",	"Mable",	"Flora",	"Carolyn",	"Olive",	"Erma",	"Joyce",	"Bonnie",	"Daisy",	"Rachel",	"Nora",	"Estelle",	"Caroline",	"Winifred",	"Marcella",	"Rosie",	"Susie",	"Irma",	"Constance",	"Lucile",	"Lorene",	"Margie",	"Eula",	"Fern",	"Henrietta",	"Maggie",	"Victoria",	"Sadie",	"Rebecca",	"Adeline",	"Lottie",	"Eloise",	"Nina",	"Antoinette",	"Nettie",	"Carol",	"Della",	"Katie",	"Lydia",	"Regina",	"Dorothea",	"Laverne",	"Jeannette",	"Amelia",	"Cleo",	"Veronica",	"Angelina",	"Claire",	"Gloria",	"Bette",	"Essie",	"Goldie",	"Isabel",	"Rosalie",	"Freda",	"Donna",	"Sally",	"May",	"Ollie",	"Adele",	"Beverly",	"Faye",	"Angeline",	"Melba",	"Addie",	"Billie",	"Isabelle",	"Effie",	"Ora",	"Jewell",	"Cecelia",	"Lela",	"Peggy",	"Annette",	"Ernestine",	"Iva",	"Johnnie",	"Luella",	"Susan",	"Leola",	"Lila",	"Jewel",	"Imogene",	"Etta",	"Sallie",	"Bettie",	"Selma",	"Elva",	"Janie",	"Gwendolyn",	"Carmen",	"Cecilia",	"Ola",	"Eleanore",	"Delores",	"Celia",	"Teresa",	"Alta",	"Lizzie",	"Sue",	"Yvonne",	"Reba",	"Maude",	"Fay",	"Ina",	"Helene",	"Frieda",	"Janice",	"Angela",	"Nell",	"Elinor",	"Nannie",	"Francis",	"Priscilla",	"Matilda",	"Iris",	"Amy",	"Estella",	"Elnora",	"Elma",	"Lenora",	"Elvira",	"Nadine",	"Harriett",	"Eugenia",	"Arline",	"Annabelle",	"Ila",	"Mollie",	"Neva",	"Clarice",	"Natalie",	"Sophia",	"Flossie",	"Lee",	"Jacqueline",	"Margery",	"Gracie",	"Virgie",	"Leah",	"Olivia",	"Marilyn",	"Myra",	"Carmela",	"Edythe",	"Connie",	"Rena",	"Winnie",	"Mavis",	"Sybil",	"Cecile",	"Millie",	"Adelaide",	"Hannah",	"Bernadine",	"Carmella",	"Madge",	"Odessa",	"Aileen",	"Frankie",	"Cornelia",	"Zelma",	"Berniece",	"Aline",	"Lorena",	"Avis",	"Dorthy",	"Josie",	"Alyce",	"Letha",	"Willa",	"Rhoda",	"Rosetta",	"Concetta",	"Allie",	"Rosella",	"Leila",	"Merle",	"Lenore",	"Dollie",	"Eliza",	"Corinne",	"Claudia",	"Loraine",	"Lily",	"Jimmie",	"Christina",	"Helena",	"Amanda",	"Corine",	"Joy",	"Iona",	"Ramona",	"Lora",	"Judith",	"Ione",	"Tillie",	"Florine",	"Callie",	"Hester",	"Marcia",	"Ophelia",	"Beth",	"Hope",	"Katharine",	"Linda",	"Dolly",	"Paula",	"Leota",	"Althea",	"Lou",	"Earline",	"Wilda",	"Bernadette",	"Maudie",	"Gussie",	"Iola",	"Dixie",	"Lessie",	"Guadalupe",	"Reva",	"Yolanda",	"Mercedes",	"Kay",	"Stephanie",	"Tessie",	"Antonia",	"Beryl",	"Pearlie",	"Lilly",	"Eddie",	"Bertie",	"Nola",	"Augusta",	"Madelyn",	"Johanna",	"Charlene",	"Bobbie",	"Theda",	"Polly",	"Robbie",	"Cynthia",	"Suzanne",	"Georgie",	"Lupe",	"Dessie",	"Delia",	"Roxie",	"John",	"Melva",	"Lelia",	"Aurora",	"Darlene",	"Harriette",	"Oma",	"Allene",	"Verda",	"Philomena",	"Deloris",	"Glenna",	"Evangeline",	"Maurine",	"Alene",	"Consuelo",	"Mona",	"Enid",	"Elisabeth",	"Erna",	"Kate",	"Margarita",	"Mozelle",	"Alvina",	"Hallie",	"Isabella",	"Nona",	"Garnet",	"Isabell",	"James",	"Dortha",	"Jannie",	"Molly",	"Corrine",	"Zella",	"Vesta",	"Jaunita",	"Lorine",	"Rubye",	"Marjory",	"Clare",	"Belle",	"Lorna",	"Marietta",	"Pansy",	"Tommie",	"Valeria",	"Ruthie",	"Diana",	"Jo",	"Birdie",	"Queen",	"Ester",	"Leta",	"Madeleine",	"Syble",	"Nelda",	"Hortense",	"Dorris",	"Fanny",	"Winona",	"Elouise",	"Phoebe",	"Vida",	"Oleta",	"Roslyn",	"Louella",	"Monica",	"Leora",	"Wilhelmina",	"Cecil",	"Jayne",	"Elvera",	"Mayme",	"Rosalind",	"Elise",	"Joanne",	"Zelda",	"Agatha",	"Alfreda",	"Catharine",	"Robert",	"William",	"Gene",	"Marianne",	"Minerva",	"Ferne",	"Katheryn",	"Judy",	"Julie",	"Lucinda",	"Manuela",	"Freida",	"Leone",	"Elda",	"Rae",	"Charlie",	"Adell",	"Patsy",	"Dovie",	"Rowena",	"Vada",	"Emilie",	"Veda",	"Ilene",	"Louisa"];
  let surNames = ["Abraham",	"Adler",	"Allen",	"Ankins",	"Arandt",	"Arthur",	"Avery",	"Baker",	"Barnham",	"Basis",	"Belanger",	"Bentz",	"Bessler",	"Best",	"Bevard",	"Bhenki",	"Blakely",	"Bleeker",	"Bouche",	"Boursaw",	"Brant",	"Brawley",	"Bretz",	"Brock",	"Brockman",	"Bruce",	"Buchman",	"Burnett",	"Burnette",	"Burns",	"Buss",	"Butterfield",	"Caffey",	"Cantin",	"Christopher",	"Click",	"Codere",	"Collins",	"Coutu",	"Cowell",	"Cowman",	"Crankovitch",	"Cuthburt",	"Cuttling",	"Darwin",	"Davis",	"Dorman",	"Drafs",	"Drefs",	"Eakley",	"Eddie",	"Edwards",	"Elliott",	"Elsner",	"English",	"Ernlaid",	"Fahlett",	"Fanbrick",	"Fandrick",	"Farwell",	"Feigel",	"Felten",	"Fenske",	"Fergin",	"Feigel",	"Fillman",	"Finley",	"Firske",	"Flatt",	"Floria",	"Fralich",	"Fralich",	"Franklin",	"Freeman",	"Frisbe",	"Furlong",	"Gager",	"Garvin",	"Germain",	"Gohl",	"Goodwin",	"Gray",	"Greenwald",	"Greenwalt",	"Griffen",	"Griffith",	"Hahn",	"Halsted",	"Hammermeister",	"Hancock",	"Harmal",	"Hass",	"Hastings",	"Hayes",	"Heminger",	"Henchal",	"Hessen",	"Hidland",	"Hilt",	"Hogue",	"Hollister",	"Hollman",	"Howell",	"Hyde",	"Kasper",	"Kegley",	"Kinney",	"Kisro",	"Kleeman",	"Kloburcher",	"Leach",	"Lehman",	"Len",	"Lesatz",	"Levard",	"Lindh",	"Lraise",	"Luckstrim",	"Lynch",	"Madison",	"Manse",	"Mantei",	"Marcus",	"Markus",	"Markwart",	"Matchinski",	"Mathews",	"McAlpine",	"McBurney",	"McCarney",	"McCown",	"McCutchen",	"McCutcheon",	"McDonald",	"McGraw",	"Merrick",	"Metic",	"Molzan",	"Mondt",	"Morris",	"Moses",	"Neyenquam",	"Nickels",	"Norval",	"O'Connell",	"Olson",	"O'Neal",	"O'Neil",	"Ozanich",	"Pantiel",	"Patterson",	"Patzer",	"Peppin",	"Perkins",	"Porter",	"Posch",	"Price",	"Proton",	"Rapin",	"Rapp",	"Raslo",	"Razner",	"Renaldt",	"Rifenberg",	"Riley",	"Ripley",	"Rosental",	"Rossini",	"Russell",	"Sawyer",	"Schiltgan",	"Schiltzen",	"Schliske",	"Schmidt",	"School",	"Schroeder",	"Schuthosk",	"Schwarm",	"Schwartz",	"Shane",	"Shattuck",	"Shaw",	"Simmons",	"Slack",	"Smith",	"Speltzer",	"St. Dennis",	"Stewart",	"Stimac",	"Strenburg",	"Strong",	"Stroshine",	"Swanson",	"Syveran",	"Tenker",	"Thomas",	"Traver",	"Urton",	"Vallier",	"Wagner",	"Wall",	"Walsted",	"Warner",	"Webber",	"Welch",	"Wentlandt",	"Westin",	"White",	"Wilkilgon",	"Wiltsey",	"Winters",	"Woods",	"Yeske",	"Zibart"];
  let eventIndex = ["It's been a long day.",
    "Today was a good day.",
    "I met someone nice today.",
    "I'm late for work!",
    "I'm bored.",
    "I need a vacation.",
    "I'm in love.",
    "I love my job.",
    "I need a new job.",
    "I'm exhausted."
  ] // eventually replace with event generator and event trees
  
  // need to add flexibility for embedded scenario events,
  // as well as exclusivity/decision/RNG branches
  // need to add support for repeatable events
  let scenarioIndex = [ // "Scenario types"
    0,
    [ // "Work related"
      0,
      [
        "Good at job.",
        "Boss said I good.",
        "Eligible for promotion.",
        "I've been promoted!"
      ],
      [
        "Bad at job.",
        "I messed up.",
        "Boss doesn't like me.",
        "My last warning.",
        "I've been demoted."
      ],
      [
        "Happy with job.",
        "I feel motivated today.",
        "I'm staying late today.",
        "Complimented on hard work."
      ],
      [
        "Not happy here.",
        "Maybe I should apply elsewhere.",
        "I can't keep up with my work.",
        "I'm stuck late today.",
        "I got scolded for falling behind."
      ]
    ],
    [ // Love related
      0,
      [
        "I met someone new.",
        "We went on our first date.",
        "I think I'm in love.",
        "Should I propose?",
        "We're engaged!",
        "It's time to start a family.",
        "Baby on the way!",
        "Our first child is born."
      ]
    ],
    [ // Life related
      0,
      [
        "I don't feel well.",
        "Going to the doctor.",
        "Everything checks out.",
        "Not getting better.",
        "Seeing the doctor again.",
        "I have cancer.",
        "Treatment makes me sick.",
        "I'm nearly out of time.",
        "I'll enjoy what's left.",
        "Going out with a bang.",
        "This is the end."
      ]
    ]
  ];

  let missionProgress = 10;
  let showMissionText = true;
  let missionIndex = [
    [],
    [
      "Welcome to BitWorld!",
      "You and your companions have traveled to this land seeking a place to stake your claim.",
      "You sold everything you had to settle this land, now you must gather the materials needed to build your home.",
      "First, let's select the location of your Manor.",
      "Simply open up the Build menu and choose a location for the residence of your Manor.",
      () => { return (buildings.size > 0) ? true : false; },
      [
        "Great! Your companions have already set their homes to your manor.",
        "Your residence hasn't been completed, however. You must assist your companions in building it.",
        "Select your army and click the ARMY icon to send them on their first expedition.",
        () => { return (selectedArmy && armies.get(selectedArmy).task == 1) ? true : false; },
        "As your units explore the region, they will gain experience while gathering necessary materials.",
        "You can also manually assign them to gather resources from a tile by moving them there.",
        "Move a unit just by clicking it and then clicking on a destination.",
        "If the destination is a resource, the unit will start gathering from the tile.",
        () => { return (selectedArmy && armies.get(selectedArmy).task == 2) ? true : false; },
        [
          "Now that you've understood the basics, gather 100 wood and complete your manor.",
          () => { return (buildings.get(padXYZ(playerX, playerY, 0)).condition == 100) ? true : false; },
          "Superb!",
          "",
          ""
        ]
      ]
    ]
  ];

  let tileIndex = false; // render tile layer index for testing
  let infoMenu = false;
  let buyLand = false;
  let paintLand = false;
  let mainMenu = true;
  let testString = "string";

	let mapWidth = 999;
	let mapHeight = 999;
  let cameraX = 50 - 30;
  let cameraY = 50 - 17;
  let cursorX = 0;
  let cursorY = 0;
  let cursorMapX = 0;
  let cursorMapY = 0;
  let cursorMoved = 0;
  let playerX = 50;
  let playerY = 50;
  let playerIncome = 0;
  let playerIncomeS = 0;
 // let GDP = 100000; // denominated in copper pieces, G:Cx10000
  let playerBank = [1000,0,0,0,0]; // $C, Food, Wood, Stone, Ore
  let selectedTile = 0;
  let selectedTileX = 0;
  let selectedTileY = 0;
  let selectedUnit = null;
  let selectedArmy = null;
  let selectedBuilding = null;
  let keyMap = {};
  let clickStart = 0;
  let clickEnd = 0;
  let clickLock = false;
  let tileAdded = false;
  let buildLand = 0;
  let uploading = false;
  let showUI = true;
  let showTech = false;

  let mapBuffer = [
    new Map(),
    new Map(),
    new Map()
  ]
  let refreshBuffer = true;
  let refreshCanvas = true;
  let tileMap = new Map();
	let map = [];
	let tiles = [];
  let tileOwned = [];
  let tileLevel = [];
  let activeMenu = 0;
  let activeSubMenu = 0;
  let menuPage = 0;
  let nextPage = false;
  let planInfo = 0;

  let tileLogic = [];
  
  let techs = [
    [new Tech("Agriculture", [0, 0], [], true)],
    [new Tech("Pottery", [1, 0], []), new Tech("Animal Husbandry", [1, 1], []), 
      new Tech("Archery", [1, 2], []), new Tech("Mining", [1, 3], [])], 
    [new Tech("Sailing", [2, 0], [[1, 0]]), new Tech("Calendar", [2, 1], [[1, 0]]), new Tech("Writing", [2, 2], [[1, 0]]), 
      new Tech("Trapping", [2, 3], [[1, 1]]), new Tech("The Wheel", [2, 4], [[1, 1], [1, 2]]), 
      new Tech("Masonry", [2, 5], [[1, 3]]), new Tech("Bronze Working", [2, 6], [[1, 3]])],
    [new Tech("Optics", [3, 0], [[2, 0]]), new Tech("Horseback Riding", [3, 1], [[2, 3], [2, 4]]), 
      new Tech("Mathematics", [3, 2], [[2, 4]]), new Tech("Construction", [3, 3], [[2, 4], [2, 5]])],
    [new Tech("Philosophy", [4, 0], [[2, 1], [2, 2]]), new Tech("Drama", [4, 1], [[2, 2]]), new Tech("Currency", [4, 2], [[3, 2]]),
      new Tech("Engineering", [4, 3], [[3, 2], [3, 3]]), new Tech("Iron Working", [4, 4], [[2, 6]])]
  ]; // [tier][id]

  let menuText = [
    [],
    ["Btn", "Draw Tile Index", "Schematics", "Blueprints", "Technology"],
    ["Btn", "Build", "Buy Land", "Level Up (10X:1)", "", ""],
    ["Btn", "Citizens", "Spawn Unit"],
    ["Btn"],
    ["Btn", "Wood Pick", "Wood Axe", "Wood Sword", "Wood Spear", "Wood Shield", 
      "Stone Pick", "Stone Axe", "Stone Sword", "Stone Spear", "Stone Shield"],
    ["Btn", "House", "Lumbermill", "Mine", "Castle"],
    ["Btn"],
    ["Btn", "Zero", "Water", "Forest", "Mountain", "House", "Building", "Mine", "Lumber Mill"],
    ["Btn", "Deploy"]];

  let menuLogic = [[],[],[],[],[],[],[],[],[],[]];
  menuLogic[0][0] = () => {};

  menuLogic[1][0] = () => {}; // info menu main button function
  menuLogic[1][1] = () => {
    tileIndex = !tileIndex; };
  menuLogic[1][2] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 5 : 0; };
  menuLogic[1][3] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 6 : 0; };
  menuLogic[1][4] = () => {
    showUI = false;
    showTech = true; };

  menuLogic[2][0] = () => {}; // home menu main button function
  menuLogic[2][1] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 8 : 0; };
  menuLogic[2][2] = () => {
    buyLand = !buyLand; };
  menuLogic[2][3] = () => {
    if (playerBank[0] >= 100 * tileLevel[selectedTileX][selectedTileY]) {
      playerBank[0] -= 100 * tileLevel[selectedTileX][selectedTileY];
      tileLevel[selectedTileX][selectedTileY]++; }};
  menuLogic[2].push(() => {});
  menuLogic[2].push(() => {});

  menuLogic[3][0] = () => {}; // army menu main button function
  menuLogic[3][1] = () => {
    activeSubMenu = (activeSubMenu == 0) ? 7 : 0; };
  menuLogic[3][2] = () => {
    let x = rnd(fieldX) + cameraX;
    let y = rnd(fieldY) + cameraY;
    createArmy(x, y, [createUnit(new GPS(0, 0, 0), true)]); };
    
  menuLogic[4][0] = () => {
    clearUI();
    playerBank[0] += 100;
    showMissionText = true;
    refreshBuffer = true; }; // lovely button function

  menuLogic[5][0] = () => { menuPage++; }; // schematics menu
  menuLogic[5][1] = () => {};
  menuLogic[5][2] = () => {};
  menuLogic[5][3] = () => {};
  menuLogic[5][4] = () => {};
  menuLogic[5][5] = () => {};
  menuLogic[5][6] = () => {};
  menuLogic[5][7] = () => {};
  menuLogic[5][8] = () => {};
  menuLogic[5][9] = () => {};
  menuLogic[5][10] = () => {};

  menuLogic[6][0] = () => {}; // blueprints menu
  menuLogic[6][1] = () => {};
  menuLogic[6][2] = () => {};
  menuLogic[6][3] = () => {};
  menuLogic[6][4] = () => {};

  menuLogic[7][0] = () => { nextPage = true; }; // citizen list

  menuLogic[8][0] = () => {}; // build list
  menuLogic[8][1] = () => { buildLand = 1; };
  menuLogic[8][2] = () => { buildLand = 2; };
  menuLogic[8][3] = () => { buildLand = 3; };
  menuLogic[8][4] = () => { buildLand = 4; };
  menuLogic[8][5] = () => { buildLand = 5; };
  menuLogic[8][6] = () => { buildLand = 6; };
  menuLogic[8][7] = () => { buildLand = 7; };
  menuLogic[8][8] = () => { buildLand = 8; };

  menuLogic[9][0] = () => {}; // unit screen
  menuLogic[9][1] = () => { assignUnit(); };

  let units = [];
  // TEMP // push hidden unit to SSN 0 for logical simplicity
  units.push(new Unit(units.length, new GPS(0, 0, 0), rndArray(), "Satoshi Nakamoto"));
  // !!! // IMPORTANT NOTE // TEMPORARY FIX // !!! //
  // army keys are handled by converting to and from STRING manually //
  // this was implemented to solve anonymous map access issues //
  // ideal solution is to be able to access map values with anonymous keys //
  // I.E. comparing objects by likeness, instead of memory value (cached) //
  // NOT IDEAL, IMO //
  let armies = new Map();
  {
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createArmy(50, 50, [units[1], units[2], units[3], units[4]]);
  }

  let regions = new Map();
  let buildings = new Map();
  let properties = new Map();
	let ID = [];
  let movement = [[0, 1, 0, -1, 0], [0, 0, 1, 0, -1]];
  let movementFull = [[0, 1, 1, 0, -1, -1, -1, 0, 1], [0, 0, 1, 1, 1, 0, -1, -1, -1]];

  const div = document.getElementById('my-money-button');

  /*
  var query = {
    v: 3,
    q: { find: {}, limit: 5 }
  };
  var b64 = btoa(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;

  var header = {
    headers: { key: "1CRKrBCUJDFyU3LsBAQRzwBkBPrjmDQasV" }
  };

  fetch(url, header).then(function(r) {
    return r.json()
  }).then(function(r) {
    var result = JSON.stringify(r, null, 2);
    document.querySelector("pre").innerHTML = result;
  })

  /*moneyButton.render(div, { // 
    to: "12cRRk9wn2LofWKE2wwxb7mw5qNeMaW7zH",
    amount: ".1",
    currency: "USD",
    label: "Hi",
    clientIdentifier: "RPG",
    buttonId: "IndieRPGProject",
    buttonData: "{}",
    type: "tip",
    onPayment: function (arg) { console.log('onPayment', arg) },
    onError: function (arg) { console.log('onError', arg) }
  })

  function upload(data)
  {
    /*moneyButton.render(div, {
      outputs: [{
        type: 'SCRIPT',
        script: data,
        amount: '.002',
        currency: 'USD'
      }]
    })
  }

  function uploadData(data)
  {
    //upload(bsv.Script.buildDataOut(arrMny).toASM());
  }*/

  // UNTESTED // Padding functions may malfunction if NUM has >1 significant digits
  // ALSO // Current default length of 3 relies on a map with max size of 999
  function padVal(val, length = 3, num = 0) {
    return val.toString().padStart(length, num) }

  function valPad(val, length = 3, num = 0) {
    return val.toString().padEnd(length, num) }

  // padXYZ() converts x, y, z into a single string for standardized use as an index //
  function padXYZ(x, y, z, length = 3, num = 0) {
    return (padVal(x, length, num) + padVal(y, length, num) + padVal(z, length, num)); }

  // sliceXYZ() reverts standardized index strings into a new GPS(x, y, z)
  function sliceXYZ(str) {
    return (new GPS(Number(str.slice(0, 3)), Number(str.slice(3, 6)), Number(str.slice(6, 9)))); }

  function getCoord(x, y, xx, yy) { // 000-00-000-00 // xx-x-yy-y
    return ((padVal(x) + padVal(xx, 2)) + (padVal(y) + padVal(yy, 2))); }

  function sliceCoord(str) { // x, y, xx, yy
    return ([Number(str.slice(0,3)), Number(str.slice(5,8)), Number(str.slice(3,5)), Number(str.slice(8,10))]) }

  function set(val, x, y, array) {
    array[x][y] = val; }

  function getSign(num) {
    return ((num == 0) ? 0 : (Math.abs(num) / num)); }
    
  function modulo(num, max) {
    return (num % max) }

	function rnd(max, min = 0) {
		return min + Math.floor(Math.random() * max); }

	function rndCeil(max, min = 0) {
		return min + Math.ceil(Math.random() * max); }

  function rndArray(length = 10, max = 4, min = 0, arr = []) {
    for (i = 0; i < length; i++) { 
      arr[i] = rnd(max, min); }
    return (arr); }

  // loop() returns num after looping it until within range //
  function loop(num, min, max) {
    range = max - min;
    if (num > max) {
      num -= range + 1; }
    else if (num < min) {
      num += range + 1; }
    if (num > max || num < min) {
      loop(num, min, max); }
    return num; }

  // JAVASCRIPT STRUGGLE-BUS //
  // I've tried and tried and tried, but can't figure out how this breaks //
  // When running the function traceProperty for BuyLand movement breaks //
  // I've currently removed range checking from movement pending tests //
  // This may require reverting this function to a true/false //
  // I liked adjusting value to edges of boundaries, but I give up on this //
  // This is one more beyond baffling and frustrating struggle with JavaScript //
  function range(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  function range2(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  function min(num, min) { return (num < min) ? min : num; }

  function max(num, max) { return (num > max) ? max : num; }

  // inRange() returns true if num is within min && max //
  // Solves issues of range() failing to return/set the correct value //
  function inRange(num, min = 0, max = 999) {
    return ((num <= max && num >= min) ? true : false ) }

  // contains() returns true if within rectangle bounds (x, y, width, height) //
  function contains(x, y, width, height, checkX, checkY) {
      return ((x <= checkX && checkX <= x + width && y <= checkY && checkY <= y + height) ? true : false); }

  // get the side length of a right isosceles triangle from hypotenuse
  function getSides(hypotenuse) { return Math.round(hypotenuse / Math.sqrt(2)); }

  function checkAdjacent(val, x, y, array = map) { // returns seed percentage
    let seed = 0;
    for (let i = 1; i <= 4; i++) {
      if (array[range(x + movement[0][i], 0, 999)][range(y + movement[1][i], 0, 999)] == val) {
        seed += .25; }}
    return seed; }

  function wrapText(text, width, index = 0, array = []) {
    let i = 0;
    if (text.length < width) {
      array[index] = text;
      return array; }
    for (ii = 0; ii < width; ii++) {
      if (text[ii] == " ") { i = ii + 1; }}
    if (!i) { i = width; }
    array[index] = text.slice(0, i);
    return wrapText(text.slice(i, text.length), width, index + 1, array);
  }

  // extract element from embedded array with digit index
  function extractText(num, array = scenarioIndex, i = 0) {
    let index = (''+num)[i];
    let extraction = array[index];
    if (i < (''+num).length - 1) { 
      i++;
      extraction = extractText(num, extraction, i); }
    return extraction;
  }

  function checkEvent(index, array) {
    element = extractText(index + 1, array);
    return (typeof element == "function") ? element() : false; }

  function nextEvent(index, array) {
    element = extractText(index+1, array);
    if (typeof element == "string") { return index+1; }
    if (typeof element == "function") { 
      if (element() == false) { showMissionText = false; return index; }
      else { return nextEvent(index+1, array); }}
    if (Array.isArray(element)) {
      return (index+1)*10; }
  }

  function techAvailable(tech) {
    for (let i = 0; i < tech.requiredTechs.length; i++) {
      if (!techs[tech.requiredTechs[i][0]][tech.requiredTechs[i][1]].researched) {
        return false; }}
    return true; }

  function createUnit(home = new GPS(0, 0, 0), r = false) {
    let unit = new Unit(units.length, home, rndArray());
    units.push(unit);
    menuText[7].push("Unit " + (units.length - 1));
    menuLogic[7].push(() => { clearUI();
      selectTile(unit.home.x, unit.home.y);
      selectedUnit = unit.ssn; });
    if (r) return unit; }

  function genName(sex = rnd(2), sur = surNames[rnd(surNames.length)]) {
    return [(sex) ? mNames[rnd(mNames.length)]
      : fNames[rnd(fNames.length)], sur]; }

  function assignUnit(tile = new GPS(selectedTileX, selectedTileY, 0),
      unit = units[selectedUnit]) {
    let key = padXYZ(tile.x, tile.y, 0);
    let building = buildings.get(key);
    if (building && building.units.size < 4 && !unit.work) {
      unit.work = key;
      unit.events.push("I'm employed at the " + tileNames[tiles[tile.x][tile.y]] + "!")
      building.units.set(selectedUnit, new Contract(key, unit.ssn, Date.now() + 30000));
      building.calcProduction(0); }
    else if (!building && !unit.work) {
      (armies.get(key)) ? armies.get(key).units.set(unit.ssn, unit)
        : createArmy(tile.x, tile.y, [unit], true);
      armies.get(key).calcProduction(0);
      unit.work = true; }
  }

  function createArmy(x, y, units = 0, r = false) {
    let army = new Army(0, 0, "blue", 10);
    let key = padXYZ(x, y, 0);
    if (units != 0) {
      for (let i = 0; i < units.length; i++) {
        army.units.set(units[i].ssn, units[i]); }
    armies.set(key, army); }
    if (r) { return army; }}

  function genScenario(array = scenarioIndex, index = "") {
    let seed = rnd(array.length - 1, 1);
    index = index.concat((typeof array[0] == "string") ? 0 : seed);
    if (typeof array[index[index.length - 1]] != "string") {
      index = genScenario(array[seed], index); }
    return Number(index);
    }
/*
  function setResources(region) {
    let res = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let workBonus;
    for (let i = 0; i < region.domain.length; i++) {
      gps = region.domain[i];
      key = padXYZ(gps.x, gps.y, gps.z);
      workBonus = (armies.has(key)) ? armies.get(key).level : 1;
      if (tiles[gps.x][gps.y] > 4) {
        res[3] += workBonus;
        res[2] += workBonus;
      }
      else {
        res[1] += workBonus;
      }
    }
    region.resources = res;
  } */

  function traceProperty(x, y) {
    do {
      y = y + movement[1][4];
    } while (tileOwned[x][y]);

    let xi = x;
    let yi = y;
    let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
    drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");
    xi = xi + movement[0][direction];
    yi = yi + movement[1][direction];

    do {
      drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

      direction = loop(direction + 1, 1, 4);
      if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
        do {
          direction = loop(direction - 1, 1, 4);
        } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }
      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];
      
      if (xi == x && yi == y) { return; }
    } while (buyLand);
  }

	async function generateMap() {
		for (let y = 0; y <= mapHeight; y++) {
			for (let x = 0; x <= mapWidth; x++) {
        if (y == 0) {
          map[x] = [];
          tiles[x] = [];
          tileOwned[x] = [];
          tileLevel[x] = []; }
				map[x][y] = 0;
				tiles[x][y] = 0; }}

    generateSnow();
    expandSnow();
    generateDesert();
    expandDesert();
    generateWater();
    expandWater();
    generateForests();
    expandForests();
    generateMountains();
    expandMountains(); }

  function layer(val, x, y, min, max, array = map, func = ((x, y) => {})) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 8; ii++) {
        for (let iii = 0; iii < i; iii++) {
          x += movementFull[0][ii];
          y += movementFull[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
          func(x, y); }}}}

 function layerSq(val, x, y, min, max, array = map, addDomain = false) {
    for (let i = min; i <= max; i++) {
      let gps;
      let domainKey = padXYZ(playerX, playerY, 0);
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 4; ii++) {
        for (let iii = 0; iii < i * 2; iii++) {
          x += movement[0][ii];
          y += movement[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; 
          if (addDomain) {
            gps = new GPS(x, y, 0);
            regions.get(domainKey).domain.push(gps);
          }}}}}

  function pool(val, x, y, array) {
    let i = 0;
    let slope = 0;
    do {
      layer(val, x, y, i, i + 1, array);
      slope = rnd(9);
      i++; } while (slope == 0);
    return (slope); }

	function generateSnow() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 100; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 1;
      layer(1, x, y, 1, size, map); }}

	function generateDesert() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 150; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 2;
      layer(2, x, y, 1, size, map); }}

	function generateWater() {
    let slope;
    let current;
    let flow;
    let x;
    let y;
    for (let i = 0; i < 800; i++) {
      slope = rnd(9); // 0 causes a pool, forces new flow, !chance of new river
      flow = 3 * (rndCeil(30));
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      tiles[x][y] = 2;
      
      if (slope == 0) {
        slope = pool(2, x, y, tiles); }

      do {
        x = range((x + movementFull[0][slope]), 0, 999);
        y = range((y + movementFull[1][slope]), 0, 999);
        tiles[x][y] = 2;
        if (rnd(5) < 1) {
          slope = rnd(9);
          if (slope == 0) {
            slope = pool(2, x, y, tiles); }}

        flow--; } while (flow > 0); }}

	function generateForests() {
     let x;
     let y;
     for (let i = 0; i < 200000; i++) {
       x = rnd(999);
       y = rnd(999)
       if (tiles[x][y] == 0 && map[x][y] != 2) {
         tiles[x][y] = 3; }}}

	function generateMountains() {
    let x;
    let y;
    for (let i = 0; i < 100000; i++) {
      x = rnd(999);
      y = rnd(999)
      if (tiles[x][y] == 0) {
        tiles[x][y] = 4; }
      if (map[x][y] == 1 && rnd(7) >= 5) {
        layer(4, x, y, 1, 1, tiles); }}}

  function generateRegion(key) {
    let gps = sliceXYZ(key);
    playerX = gps.x;
    playerY = gps.y;
    //tileMap.set(key, new Land());
    // regions.get(key).domain.push(gps);
    layerSq(true, playerX, playerY, 1, 3, tileOwned); }

  function expansion(val, def, gen, array = map) {
    for (let i = 0; i < def; i++) {
      for (let y = 0; y <= mapHeight; y++) {
        for (let x = 0; x <= mapWidth; x++) {
          if (array[x][y] != val) {
            let seed = checkAdjacent(val, x, y, array);
            if (rnd(100 * seed) > gen) {
              array[x][y] = val; }}}}}}

  function expandSnow() {
    expansion(1, 5, 15);
    expansion(1, 5, 30);
    expansion(1, 1, 75); }

  function expandDesert() {
    expansion(2, 5, 15);
    expansion(2, 5, 30);
    expansion(2, 2, 75); }

  function expandWater() {
    expansion(2, 2, 20, tiles);
    expansion(2, 2, 40, tiles);
    expansion(2, 2, 80, tiles); }

  function expandForests() {
    expansion(3, 1, 35, tiles);
    expansion(3, 1, 60, tiles);
    expansion(3, 1, 85, tiles); }

  function expandMountains() {
    expansion(4, 1, 25, tiles);
    expansion(4, 1, 50, tiles);
    expansion(4, 1, 80, tiles); }

  onkeydown = onkeyup = function(e) {
    e = e || event; // IE Compatibility
    keyMap[e.keyCode] = e.type == 'keydown'; }

  function moveTowards(army, location) {
    let distance = (army.moveX * army.moveY == 0) ? 2 : 3;
    let moveX = distance * (army.moveX != 0) ? 
      (army.moveX / (Math.abs(army.moveX))) : -(army.tileX / (Math.abs(army.tileX)));
    let moveY = distance * (army.moveY != 0) ? 
      (army.moveY / (Math.abs(army.moveY))) : -(army.tileY / (Math.abs(army.tileY)));
    if ((army.moveX != 0 || army.tileX != 0)
      && !armies.has(padXYZ(location.x + moveX, location.y, location.z))) {
      army.tileX += moveX;
      if (!inRange(army.tileX, -15, 16)) {
        army.tileX = loop(army.tileX, -15, 16);
        army.moveX -= moveX;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.x += moveX;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
    if ((army.moveY != 0 || army.tileY != 0) 
      && !armies.has(padXYZ(location.x, location.y + moveY, location.z))) {
      army.tileY += moveY;
      if (!inRange(army.tileY, -15, 16)) {
        army.tileY = loop(army.tileY, -15, 16);
        army.moveY -= moveY;
        armies.delete(padXYZ(location.x, location.y, location.z));
        location.y += moveY;
        armies.set(padXYZ(location.x, location.y, location.z), army);
      }
    }
  }
  
  function patrol(key, x = playerX, y = playerY, range = 25, hop = 5) {
    let army = armies.get(key);
    let location = sliceXYZ(key);
    let destination = new GPS(
      range2(location.x + (rnd(hop * 2) - hop), x - range, x + range),
      range2(location.y + (rnd(hop * 2) - hop), y - range, y + range), 0);
    army.moveX = destination.x - location.x;
    army.moveY = destination.y - location.y;
    army.action = new Contract(destination.toString(), key, 0, [army.units.size, rnd(3, 1)]);
  }

  function gather(army) {
    payContract2(army.action)
  }

  function logic() {
    if (clickStart) {
      cursorMoved = [ cursorX - clickStart[0][0], cursorY - clickStart[0][1]]; }
    if (cursorMoved) {
      cameraX = range2(cameraX + Math.round(cursorMoved[0] / 64), 0, mapWidth - fieldX - 1);
      cameraY = range2(cameraY + Math.round(cursorMoved[1] / 64), 0, mapHeight - fieldY - 1); }

    if (nextPage) { menuPage++; nextPage = false; }
    if (keyMap[68] && inRange(cameraX + 1, 0, mapWidth - fieldX - 1)) { // d
      cameraX++; }
    if (keyMap[83] && inRange(cameraY + 1, 0, mapHeight - fieldY - 1)) { // s
      cameraY++; }
    if (keyMap[65] && inRange(cameraX - 1)) { // a
      cameraX--; }
    if (keyMap[87] && inRange(cameraY - 1)) { // w
      cameraY--; }
      
    if (keyMap[27]) { clearUI(); }

    if (!showMissionText && checkEvent(missionProgress, missionIndex)) {
      missionProgress = nextEvent(missionProgress, missionIndex);
      showMissionText = true; }

    if (buildLand != 0)
    {
      let x = cameraX + cursorMapX;
      let y = cameraY + cursorMapY;
      if (buildLand == 1 && clickEnd != 0) {
        tiles[x][y] = 0; }
      else {
        if (clickEnd != 0 && playerBank[0] >= 250 /*&& tileOwned[x][y]*/
          && tiles[x][y] == 0) {
          tiles[x][y] = buildLand;
          if (buildLand >= 5) {
            key = padXYZ(x, y, 0);
            tileLevel[x][y] = 1;
            building = new Building(buildings.length);
            if (buildings.size == 0) { 
              regions.set(key, new Region(1));
              generateRegion(key);
              for (i = 1; i <= 4; i++) {
                units[i].home = sliceXYZ(key);
                building.units.set(i, new Contract(i, key, Date.now() + 30000)); }}
            buildings.set(key, building);
            playerBank[0] -= 250;
    }}}}
  }

  function logic1000() {
    testString = genScenario();
    //let key = padXYZ(playerX, playerY, 0);
    //let region = regions.get(key);
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++){
      let location = sliceXYZ(key[i]);
      let arm = army[i];
      let contract = army[i].action;
      if (army[i].moveX != 0 || army[i].moveY != 0
          || army[i].tileX != 0 || army[i].tileY != 0) {
        moveTowards(army[i], location); }
      else if (army[i].task == 1) {
        if (!army[i].action) {
          patrol(key[i]);
        }
        else if (army[i].action.period == 0) {
          if (!army[i].action.expiration) {
            army[i].action.expiration = Date.now() + 30000; }
          if (Date.now() - army[i].action.expiration >= 0) { army[i].action = 0; }
          else { army[i].action.period = Date.now() + 1000; }
        }
        else if (Date.now() - army[i].action.period >= 0) {
          gather(army[i]);
          army[i].action.period = 0;
        }
      }
      else if (arm.task == 2) {
        if (!contract.period) {
          if (tiles[location.x][location.y] == 4) {
            contract.payment.settlement = function() {
              if (rnd(10) == 4) { playerBank[4] += arm.units.size; }}}
          contract.period = Date.now() + 7000;
        }
        else if (Date.now() - contract.period >= 0) {
          gather(arm);
          contract.period = Date.now() + 1000;
        }
      }
    }

    key = [ ...buildings.keys() ];
    let building = [ ...buildings.values() ];

    for (let i = 0; i < building.length; i++) {
      let gps = sliceXYZ(key[i]);
      let contract = [ ...building[i].units.values() ];

      if (building[i].condition < 100 && playerBank[2] > 0) { 
        playerBank[2]--;
        building[i].condition++; } 

      if (contract.length > 0) { settleContracts(gps, building[i], contract); }

      if (tiles[gps.x][gps.y] == 5 && rnd(50) >= 5 && building[i].units.size < 4) {
        let unit = createUnit(gps, true);
        unit.events.push("I now live at " + gps + "!")
        building[i].units.set(unit.ssn, new Contract(unit.ssn, key[i], Date.now() + 30000)); }
        
      building[i].calcProduction(0); }

    /*for (y = 0; y <= mapHeight; y++) {
      for (x = 0; x <= mapWidth; x++) {
        if (tileOwned[x][y]) {
              let tile = tiles[x][y];
              if (Number.isInteger(tile) && tile == 5) {
                playerGold += tileLevel[x][y] * 10; }}
      }
    }*/
    let list = units;
    for (const unit of list) {
      let seed = rnd(100);
      if (seed == 50) {
        unit.events.push(eventIndex[rnd(10)]); }
      else if (seed >= 80) {
        let scenario = genScenario();
        let progress = 0;
        if (scenario > 9 && unit.scenarios.has(scenario)) {
          progress = unit.scenarios.get(scenario) + 1;
          array = extractText(Math.floor(scenario / 10));
          if (progress < array.length) {
            unit.events.push(scenario + progress);
            unit.scenarios.set(scenario, progress);
          }
        }
        else {
          unit.events.push(scenario + progress);
          unit.scenarios.set(scenario, progress);
        }
      }
    }
  }

  function logic5000() {
    // snd.play(); // MetaNet is great and all.. but..
    
  }

  function settleContracts(gps, property, contracts) {
    for(const contract of contracts) {
      if (contract.period < Date.now()) {
        payContract(gps, property, contract);
        contract.period = Date.now() + 30000; }
    }
  }

  function payContract(gps, property, contract) {
    let index = tiles[gps.x][gps.y];
    if (units[contract.promisee]) {
      units[contract.promisee].skills[0]++; }

    if (index == 5) {
      playerBank[0] += 10 + property.production; }
    else if (index == 6) {
      playerBank[1] += 1 * property.production; }
    else if (index == 7) {
      playerBank[3] += 1 * property.production; }
    else if (index == 8) {
      playerBank[2] += 1 * property.production; }
  }

  function payContract2(contract) {
    playerBank[contract.payment.resource] += contract.payment.amount;
    contract.payment.settlement();
  }

/*
  function setBuffer() {
    let size = 32;
    mapBuffer[0] = [];
    mapBuffer[1] = [];
    mapBuffer[2] = [];
    // draw first layer (land/biome) //
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        land = map[x + cameraX][y + cameraY];
        key = padXYZ(x + cameraX, y + cameraY, 0);
        outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
          "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
        mapBuffer[land].push(
          [x * 32, y * 32, size, size, true, true,
            biomeDraws[land], outlineColor, "1"])
        }}
    refreshBuffer = false;
  }

  function cutBuffer() {
    for (let i = 0; i < mapBuffer.length; i++) {
      keys = mapBuffer[i].keys();
      for (let ii = 0; ii < keys.length; ii++) {
        gps = sliceXYZ(keys[ii]);
        if (!inRange(gps.x, cameraX, cameraX + fieldX)
          || !inRange(gps.y, cameraY, cameraY + fieldY)
          || i != map[x][y]) {
          mapBuffer[i].delete(keys[ii]);
        }
      }
    }
  }

  function drawBuffer() {
    for (let i = 0; i < mapBuffer.length; i++) {
      funcs = mapBuffer[i];
      for (let ii = 0; ii < funcs.length; ii++) {
        params = funcs[ii];
        drawRectangle(params[0], params[1], params[2], params[3],
          params[4], params[5], params[6], params[7], params[8]);
      }
    }
  }
*/

	function drawMap() {
		let size = 32;
    let key;
    let land;
    let tile;
    let outlineColor;

    // draw first layer (land/biome) //
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        land = map[x + cameraX][y + cameraY];
        ctx.drawImage(canvasImages[0][land][(tileOwned[x + cameraX][y + cameraY]) ? 1 : 0], x * 32, y * 32);
        /*outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
          "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
        drawRectangle(x * 32, y * 32, size, size, true, true,
          biomeDraws[land], outlineColor, "1");*/ }}

    // draw selected tile || tile @ cursor position //
    let rect = (selectedTileX || selectedTileY) 
      ? [(selectedTileX - cameraX) * 32, (selectedTileY - cameraY) * 32, 32, 32] 
      : [cursorMapX * 32, cursorMapY * 32, 32, 32];
    //drawRectangle(rect[0], rect[1], rect[2], rect[3], false, true, "black", "darkgray");
    drawMenu(rect[0], rect[1], rect[2], rect[3], ()=>{}, 0, "white", "1");
    clickLock = false;

    // draw second layer (tiles)
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        //if (tileMap.has(padXYZ(x + cameraX, y + cameraY, 0))) { // if explored
          tile = tiles[x + cameraX][y + cameraY];
          if (Number.isInteger(tile) && tile != 0) {
            if (tile >= 2 && tile <= 8) {
              ctx.drawImage(canvasImages[tile], x * 32, y * 32); }
            else {
              drawRectangle(x * 32, y * 32, size, size, true, false, "black"); }
          }
        //}
        //else { // else fog
        //  drawRectangle(x * 32, y * 32, size, size, true, false, "rgba(0,0,0,0.7)"); }
      }
    }

    // trace the domain to show available lands for purchase //
    if (buyLand) {
      traceProperty(playerX, playerY); }

    // draw second layer index value on top of each tile //
    if (tileIndex) {
    	for (let y = 0; y < fieldY; y++) {
    		for (let x = 0; x < fieldX; x++) {
          drawText(tiles[x + cameraX][y + cameraY], 8 + x * 32, 28 + y * 32, "30px Arial"); }}}
  }

  function drawMod() {

  }

  function drawText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4, canvas = ctx) {
    canvas.font = font;
    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.strokeText(text, x, y); }
    canvas.fillStyle = color;
    canvas.fillText(text, x, y); }

  // 32px Lucida Console has width of ~19
  function drawWrappedText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4, canvas = ctx,
      size = Number(font.slice(0, 2)), iX = 0, iY = size) {
    x += size + Math.floor(size * 1/16);
    y += size + Math.floor(size * 7/8);
    canvas.font = font;
    for (i = 0; i < text.length; i++) {
      if (stroke) {
        canvas.strokeStyle = strokeColor;
        canvas.lineWidth = strokeWidth;
        canvas.strokeText(text[i], x + (i * iX), y + (i * iY)); }
      canvas.fillStyle = color;
      canvas.fillText(text[i], x + (i * iX), y + (i * iY)); }
  }

  function drawRectangle(x, y, width, height, fill = true, stroke = true,
      fillColor = "black", strokeColor = "black", strokeWidth = "3", canvas = ctx) {
    canvas.beginPath();
    canvas.rect(x, y, width, height);
    if (fill) { 
      canvas.fillStyle = fillColor; 
      canvas.fill();
    if (stroke) { 
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }}}

  function drawTriangle(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 2, canvas = ctx) {
    size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 28 * scale, y + 28 * scale - size);
    canvas.lineTo(x + 4 * scale, y + 28 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill();
  }
  
  function drawTree(x, y) {
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 4);
    ctx.lineTo(x + 28, y + 10);
    ctx.lineTo(x + 20, y + 10);
    ctx.lineTo(x + 28, y + 14);
    ctx.lineTo(x + 20, y + 14);
    ctx.lineTo(x + 28, y + 18);
    ctx.lineTo(x + 4, y + 18);
    ctx.lineTo(x + 12, y + 14);
    ctx.lineTo(x + 4, y + 14);
    ctx.lineTo(x + 12, y + 10);
    ctx.lineTo(x + 4, y + 10);
    ctx.lineTo(x + 16, y + 4);
    ctx.lineTo(x + 4, y + 28);
    ctx.fillStyle = "green";
    ctx.fill();
    ctx.beginPath();
    ctx.rect(x + 14, y + 18, 4, 10);
    ctx.fillStyle = "saddlebrown";
    ctx.fill();
  }

  function drawHouse(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 3, canvas = ctx) {
    let size = 0;
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 28 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 25 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 25 * scale, y + 28 * scale);
    canvas.lineTo(x + 7 * scale, y + 28 * scale);
    canvas.lineTo(x + 7 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 4 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill(); }

  function drawBuilding(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 3, canvas = ctx) {
    let size = 0;
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 27 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 27 * scale, y + 28 * scale);
    canvas.lineTo(x + 5 * scale, y + 28 * scale);
    canvas.lineTo(x + 5 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill(); }

  function drawArmy(x, y, scale, color) {
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.arc(x + (16 * scale), y + (10 * scale), 6 * scale, 0, Math.PI * 2, true);
    ctx.moveTo(x + 16 * scale, y + 16 * scale);
    ctx.lineTo(x + 24 * scale, y + 28 * scale);
    ctx.lineTo(x + 8 * scale, y + 28 * scale);
    ctx.fill(); }

  function drawCapitol() {
    drawRectangle((playerX - cameraX) * 32 + 4, (playerY - cameraY) * 32 + 4, 24, 24,
      true, true, "rgba(169,169,169,0.35)", "rgba(0,0,0,0.5)");
    drawRectangle((playerX - cameraX) * 32 + 10, (playerY - cameraY) * 32 + 10, 12, 12,
      true, false, "rgba(0,0,0,0.8)");
  }

  function drawMenu(x, y, width, height, func = (() => {}), menuID = 0, 
      strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3", hoverFunc = (() => {}),
      color = "rgba(0,0,0,0.05)") {
    let overflow = (menuLogic[menuID].length <= 8) ? 0 : (8 * menuPage);
    let length = menuLogic[menuID].length - overflow;
    let menuLength = (length <= 8) ? length : 9;
    height += 64 * (menuLength - 1);
    if (contains(x, y, width, height, cursorX, cursorY)) {
      clickLock = true;
      strokeColor = "rgba(255,255,255,1)";
      strokeWidth = "5";
      { (clickEnd != 0 || selectedTile) ? func() : hoverFunc(); }
    }
    drawRectangle(x, y, width, height, true, true, color, strokeColor);

    if (menuID != 0) {
      for (let i = 1 + overflow; i < menuLength + overflow; i++) {
        if (menuID == 7) { hoverFunc = (() => { 
          drawMenu(cursorX + 25, cursorY + 25, 320, 96);
          drawText(units[i].name, cursorX + 25 + 32, cursorY + 32 + 32, "24px Arial", "lightgray", true);
          drawText(units[i].stats, cursorX + 25 + 32, cursorY + 32 + 64, "24px Arial", "lightgray", true);
        }); }
        drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288, 32, menuLogic[menuID][i], 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
        drawText(menuText[menuID][i], x + 32, y - 8 + (64 * (i - overflow)), "24px Arial", "lightgray", true); }}}
        // CURRENTLY CLICK TO CHANGE PAGE, NEED BUTTON FOR OVERFLOW MENUS

  function drawTileUnits(tile, height, width) {
    drawMenu((fieldX - 11) * 32, 32 + height + 32, width, 192);
    drawText("Production: " + (tile.production), (fieldX - 10) * 32, height + 96, "30px Arial", "White");
    let func = (tile instanceof Army) ? () => { armies.get(selectedArmy).setTask(1); } : () => {};
    drawMenu((fieldX - 3) * 32, 32 + height + 32, 64, 64, func);
    drawArmy((fieldX - 3) * 32, 32 + height + 32, 2, "rgba(0,0,200,.5)");
	  let ssns = [ ...tile.units.keys() ];
      for (i = 0; i < ssns.length; i++) {
        drawMenu((fieldX - 11) * 32, 128 + height + (32 * (i)), width, 32,
          () => { selectedUnit = ssns[i]; });
        drawText(units[ssns[i]].name + ": " + units[ssns[i]].stats, 
          (fieldX - 11) * 32 + 24, 160 + height - 8 + (32 * (i)), "24px Arial", "lightgray", true); }}

  function drawObj() {
    drawCapitol();

    // draw all standing armies //
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++) {
      let location = sliceXYZ(key[i]);
      drawArmy((location.x - cameraX) * 32 + army[i].tileX, (location.y - cameraY) * 32
        + army[i].tileY, 1, army[i].color); }}
        
  function drawUI() {
    let rect;
    let font;
    let color;
    let x;
    let y;
    let key = padXYZ(playerX, playerY, 0);

    if (buildLand != 0) {
      ctx.drawImage(canvasImages[buildLand], cursorMapX * 32, cursorMapY * 32); }

    //let buf = bsv.crypto.Random.getRandomBuffer(32);
    //let bn3 = modulo(bigNum, bnMax);
    //let bnPub3 = modulo(bigNumPub, bnMax);
    //let buf2 = bsv.crypto.BN.fromString(bn3.toString()).toBuffer();
    //let bufPub = bsv.crypto.BN.fromString(bnPub3.toString()).toBuffer();
    //let priv3 = bsv.PrivateKey.fromBuffer(buf2);
    //let pub3 = bsv.PublicKey.fromX(true, bnPub3);
    //let pub3Priv = bsv.PublicKey.fromPrivateKey(priv3).point.getX();
    //let priv3 = bsv.
    // draw toolbar at top of screen //
    font = "30px Arial";
    drawText(cameraX, 8, 28, font);
    drawText(cameraY, 8 + 54, 28, font);
    drawText(playerBank[0] / 100, 8 + 112, 28, font, "silver");
    drawText("Food: " + playerBank[1], 8 + 112, 28 + 32, font, "red");
    drawText("Lumber: " + playerBank[2], 8 + 112 + 148, 28 + 32, font, "brown");
    drawText("Stone: " + playerBank[3], 8 + 112 + 320, 28 + 32, font, "gray");
    drawText("Ore: " + playerBank[4], 8 + 112 + 460, 28 + 32, font, "dark gray");
    drawText(fieldX, 8 + 176, 28, font);
    drawText(fieldY, 8 + 230, 28, font);
    /*drawText(priv, 8 + 192, 28, font, "silver");
    drawText(pub, 8 + 192, 28+32, font, "silver");
    drawText(priv2, 8 + 192,28+32+32, font, "silver");
    drawText(pub2, 8 + 192, 28+32+32+32, font, "silver");
    drawText(bn, 8 + 192,   28+32+32+32+32, font, "silver");
    drawText(bn2, 8 + 192,  28+32+32+32+32+32, font, "silver");
    drawText(bn3, 8 + 192,  28+32+32+32+32+32+32, font, "silver");
    drawText(bnPub, 8 + 192, 28+32+32+32+32+32+32+32, font, "silver");
    drawText(bnPub2, 8 + 192, 28+32+32+32+32+32+32+32+32, font, "silver");
    drawText(bnPub3, 8 + 192, 28+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(priv3, 8 + 192, 28+32+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(pub3.point.getX(), 8 + 192, 28+32+32+32+32+32+32+32+32+32+32+32, font, "silver");
    drawText(pub3Priv, 8 + 192, 28+32+32+32+32+32+32+32+32+32+32+32+32, font, "silver");*/
    drawText(fps, 8, 28 + 32, font);

    // info menu button
    rect = [32, 64, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[1][0]);
    ctx.font = "60px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("i", 57, 118);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 1 : 0; }

    // home menu button
    rect = [32, 160, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[2][0]);
    drawHouse(rect[0], rect[1], 2, "rgba(69,69,69,0.7)", true);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 2 : 0; }

    // army menu button
    rect = [32, 256, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[3][0]);
    drawArmy(rect[0], rect[1], 2, "rgba(0,0,200,.5)")
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 3 : 0; }

    // lovely button
    rect = [32, 352, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[4][0]);
    if (clickEnd != 0 && contains(rect[0], rect[1], rect[2], rect[3], cursorX, cursorY)) {
      activeMenu = (activeMenu == 0) ? 4 : 0; }

    // set menu size for tooltip menu //
    let width = 320;
    let height = 224;
    if (selectedTileX || selectedTileY) {
      x = selectedTileX;
      y = selectedTileY;
      if (![0,1,2,3].includes(tiles[x][y])) {
        height = 448; } }
    else {
      x = cameraX + cursorMapX;
      y = cameraY + cursorMapY; }

    // draw tooltip menu //
    drawRectangle((fieldX - 11) * 32, 32, width, height, true, true, "rgba(0,0,0,0.05)", "rgba(0,0,0,0.25)");
    font = "40px Arial";
    color = "rgba(0,0,0,0.7)";
    drawText(biomeNames[map[x][y]], (fieldX - 10) * 32, 100, font, color);
    drawText(tileNames[tiles[x][y]], (fieldX - 10) * 32, 150, font, color);
    drawText("Owned: " + tileOwned[x][y]/*((!tileMap.has(padXYZ(x, y, 0))) ? false : true)*/, (fieldX - 10) * 32, 200, font, color);
    // if tile has logic, draw expanded tooltip menu elements //
    if (![0,1,2,3,4].includes(tiles[x][y])) {
      drawText("Level: " + tileLevel[x][y], (fieldX - 10) * 32, 250, font, color);
      drawText("Condition: " + buildings.get(padXYZ(x, y, 0)).condition,
        (fieldX - 10) * 32, 300, font, color);
      drawText("Pay In: ", (fieldX - 10) * 32, 350, font, color);
      drawMenu((fieldX - 10) * 32, 416, 112, 32);
      drawMenu((fieldX - 5.5) * 32, 416, 112, 32); }

    // if army is selected, draw underlying units info below tooltip menu //
    key = padXYZ(x, y, 0);
    if (armies.has(key)) {
      army = armies.get(key);
      drawTileUnits(army, height, width); }
    if (buildings.has(key)) {
      building = buildings.get(key);
      drawTileUnits(building, height, width); }
    if (selectedUnit && activeMenu == 0) {
      let unit = units[selectedUnit];
      let length = 32 * unit.events.length;
      drawText(unit.name + " " + unit.ssn, 128 + 16, 88);
      drawMenu(128, 64, 320, 96 + length, menuLogic[9][0], 9);
      drawText("Stats: " + unit.stats, 128 + 16, 160);
      drawText("Skills: " + unit.skills, 128 + 16, 192)
      for (let i = 0; i < unit.events.length; i++) {
        let text = (typeof unit.events[i] == "number") ? 
          extractText(unit.events[i]) : unit.events[i];
        drawText(text, 128+16, 224 + (32 * i));
      }
    }

    // if main menu is active, draw from index with embedded menuLogic[] //
    if (activeMenu != 0) {
      drawMenu(128, 64, 320, 32, menuLogic[activeMenu][0], activeMenu); }

    // if main menu child is active, draw with indexed logic //
    if (activeSubMenu != 0) {
      drawMenu(480, 64, 320, 32, menuLogic[activeSubMenu][0], activeSubMenu); }

    // !!! INACTIVE !!! divert to new hoverFunc in drawMenu() //
    if (planInfo != 0) {
      drawMenu(832, 64, 128, 64); }
  }

  function clearUI() {
    activeMenu = 0;
    activeSubMenu = 0;
    menuPage = 0;
    buildLand = 0;
    buyLand = false;
    tileIndex = false;
    selectedTileX = 0;
    selectedTileY = 0;
    selectedUnit = null;
    selectedArmy = null;
    selectedBuilding = null;
    showUI = true;
    showTech = false;
    showMissionText = false; }

  // draw technology tree //
  function drawTech() {
    if (clickLock) { clickEnd = 0; } // spend click on first pass //
    let x;
    let y;
    for (i = 0; i < 5; i++) {
      for (ii = 0; ii < techs[i].length; ii++) {
        x = 64 + (i * 192);
        y = 64 + (ii * 96);

        if (techs[i][ii].researched) {
          drawMenu(x, y, 160, 64, () => {}, 0, "rgba(255,255,255,1)"); }
        else if (techAvailable(techs[i][ii])) {
          drawMenu(x, y, 160, 64, () => { techs[i][ii].researched = true; }, 0, "rgba(0,255,0,1)"); }
        else {
          drawMenu(x, y, 160, 64); }

        drawText(techs[i][ii].name, x + 32, y - 8, "24px Arial", "lightgray", true); }}
  }

  function drawMainMenu() {
    drawRectangle(0, 0, canvas.width, canvas.height);
    let x = fieldX / 2 * 32;
    let y = fieldY / 2 * 32;
    for (yi = 0; yi < 32; yi++) {
      for (xi = 0; xi < 68; xi++) {
        ctx.drawImage(microImages[map[cameraX + xi][cameraY + yi]],
          x - 272 + (8 * xi), y - 256 + (8 * yi));
      }
    }
    drawMenu(x - 272, y - 256, 544, 256, ()=>{}, 0,
      "LightGray", "20", ()=>{}, "rgba(32,32,32,0.8)");
    drawText("BitWorld", x - 256 + 25, y - 160 + 58, "bold 96px Courier New", "Gray", true, "LightGray");
    drawMenu(x - 128, y + 32, 256, 96, () => { mainMenu = false; /*openFullscreen();*/ }, 0,
      "BlueViolet", "10", ()=>{}, "rgba(55,55,55,1)");
    drawText("START", x-128+76, y+32+58, "32px Arial", "White", true, "Indigo")
  }

  function drawTextBox(x = fieldX / 2 * 32 - 256, y = fieldY * 32 - 288, width = 512, height = 256,
      text = extractText(missionProgress, missionIndex), size = 32) {
    drawMenu(x, y, width, height, () => { missionProgress = nextEvent(missionProgress, missionIndex); });
    drawWrappedText(wrapText(text, Math.ceil((width - (2 * size)) / (size * 19/32))),
      x, y, size + "px Lucida Console", "White", true);
  }

  // draw canvas elements //
	async function draw() {
    clickLock = false;
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.canvas.width  = window.innerWidth;
		ctx.canvas.height = window.innerHeight;
		fieldX = Math.ceil(ctx.canvas.width / 32);
		fieldY = Math.ceil(ctx.canvas.height / 32);
		
    if (mainMenu) {
      drawMainMenu();
    }
    else { 
      drawMap();
      drawMod();
      drawObj();
      if (showMissionText) { drawTextBox(); }
      if (showUI) { drawUI(); }
      if (showTech) { drawTech(); }
    }
    
    if (selectedTile) { 
      if (!clickLock) { clickActions(); }
      else { getCursorXY(null, selectedTile[0], selectedTile[1]); }
      selectedTile = 0; }
    clickEnd = 0;
  }

  function bufferDraw() {

  }

	generateMap();

  if (isMobile) {
    let el = document.getElementsByTagName("canvas")[0];
    el.addEventListener("touchstart", touchStart);
    el.addEventListener("touchmove", touchMoved);
    el.addEventListener("touchend", touchEnd);
    //el.addEventListener("touchcancel", handleCancel);
  }
  else {
    window.onload = init;
    function init() {
      if (window.Event) {
        document.captureEvents(Event.MOUSEMOVE); }
      document.onmousemove = getCursorXY; }
    document.addEventListener("mousedown", mouseDownHandler, false);
    document.addEventListener("mouseup", mouseUpHandler, false);
  }
  
  function touchStart(e) {
    selectedTile = [cursorX, cursorY];
    getCursorXY(e, e.touches[0].clientX, e.touches[0].clientY);
    mouseDownHandler(e);
    e.preventDefault();
  }

  function touchEnd(e) {
    mouseUpHandler(e);
    e.preventDefault();
  }

  function touchMoved(e) {
    getCursorXY(e, e.touches[0].clientX, e.touches[0].clientY);
  }

  function mouseDownHandler(e) {
    clickStart = [[cursorX, cursorY], Date.now()];

    if (!clickLock && !selectedTile) { clickActions(); }

    if (buyLand) {
      let x = playerX;
      let y = playerY;
      do {
        y = y + movement[1][4];
      } while (tileOwned[x][y]);

      let xi = x;
      let yi = y;
      let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
      if (playerBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
        tileOwned[xi][yi] = true;
        playerBank[0] -= 10;
        return; }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      do {
        if (playerBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
          tileOwned[xi][yi] = true;
          playerBank[0] -= 10;
          return; }

        direction = loop(direction + 1, 1, 4);
        if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
          do {
            direction = loop(direction - 1, 1, 4);
          } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }

        xi = xi + movement[0][direction];
        yi = yi + movement[1][direction];

        if (xi == x && yi == y) { return; }
      } while (true); }}

  function clickActions(e) {
    selectTile(cameraX + cursorMapX, cameraY + cursorMapY);

    if (selectedArmy) {
      let army = armies.get(selectedArmy);
      let location = sliceXYZ(selectedArmy);
      let destination = new GPS(cameraX + cursorMapX, cameraY + cursorMapY, 0);
      army.moveX = (destination.x) - location.x;
      army.moveY = (destination.y) - location.y;
      army.task = 0;
      army.action = 0;
      if (!army.task && (tiles[destination.x][destination.y] == 3
        || tiles[destination.x][destination.y] == 4)) {
          army.setTask(2, new Contract(destination.toString(), selectedArmy,
            0, [army.units.size, tiles[destination.x][destination.y] - 1])); }}
  }

  function mouseUpHandler(e) {
    if (clickStart) {
      clickEnd = Date.now() - clickStart[1];
      clickStart = 0;
      cursorMoved = 0; } 
  }

  function selectTile(x, y) {
    if (x == selectedTileX && y == selectedTileY) {
      selectedTileX = 0; selectedTileY = 0;
      selectedBuilding = null; selectedArmy = null; }
    else {
      selectedTileX = x;
      selectedTileY = y;
      let key = padXYZ(x, y, 0);
      if (buildings.has(key)) { selectedBuilding = key; }
      if (armies.has(key)) { selectedArmy = key; } }}

  function getCursorXY(e, x = e.clientX, y = e.clientY) {
    let rect = canvas.getBoundingClientRect();
    cursorX = (x - rect.left) / (rect.right - rect.left) * canvas.width;
    cursorY = (y - rect.top) / (rect.bottom - rect.top) * canvas.height;
    cursorMapX = Math.floor(cursorX / 32);
    cursorMapY = Math.floor(cursorY / 32); }


  function openFullscreen() {
    if (canvas.requestFullscreen) { canvas.requestFullscreen(); }
    else if (canvas.mozRequestFullScreen) { /* Firefox */
      canvas.mozRequestFullScreen(); }
    else if (canvas.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
      canvas.webkitRequestFullscreen(); }
    else if (canvas.msRequestFullscreen) { /* IE/Edge */
      canvas.msRequestFullscreen(); }}

  const times = [];
  let fps;
  function refreshLoop() {
    window.requestAnimationFrame(() => {
      const now = performance.now();
      while (times.length > 0 && times[0] <= now - 1000) {
        times.shift(); }
      times.push(now);
      fps = times.length;
      refreshLoop(); }); }

  // uploadData();


  let tileDrawFuncs = [
    (x, y, color = "black", toStroke = false) => { 
      drawRectangle(x, y, 32, 32, true, toStroke, color, "rgba(0,0,0,0.05)", "1"); }, 
    (x, y) => {}, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, false, "darkblue", "black", "0", ctxImages[2]); },
    (x, y) => { 
      ctxImages[3].beginPath();
      ctxImages[3].moveTo(x + 16, y + 8);
      ctxImages[3].lineTo(x + 24, y + 24);
      ctxImages[3].lineTo(x + 8, y + 24);
      ctxImages[3].lineTo(x + 16, y + 8);
      ctxImages[3].fillStyle = "#6E2C00";
      ctxImages[3].strokeStyle = "black";
      ctxImages[3].lineWidth = "2";
      ctxImages[3].stroke();
      ctxImages[3].fill(); },
    (x, y) => { drawTriangle(x, y, 1, "rgba(150,150,150,0.7)", true, "black", "3", ctxImages[4]); },
    (x, y) => { drawHouse(x, y, 1, "rgba(69,69,69,0.7)", true, "black", "3", ctxImages[5]); },
    (x, y) => { drawBuilding(x, y, 1, "rgba(69,69,69,0.7)", true, "black", "3", ctxImages[6]); },
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[7]);
      drawText("M", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[7]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[8]);
      drawText("L", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[8]); }]

  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[0], "rgba(0,0,0,0.05)", "1", ctxImages[0][0][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[0], "rgba(0,0,255,0.35)", "1", ctxImages[0][0][1]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[1], "rgba(0,0,0,0.05)", "1", ctxImages[0][1][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[1], "rgba(0,0,255,0.35)", "1", ctxImages[0][1][1]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[2], "rgba(0,0,0,0.05)", "1", ctxImages[0][2][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[2], "rgba(0,0,255,0.35)", "1", ctxImages[0][2][1]);
  tileDrawFuncs[1](0, 0);
  tileDrawFuncs[2](0, 0);
  tileDrawFuncs[3](0, 0);
  tileDrawFuncs[4](0, 0);
  tileDrawFuncs[5](0, 0);
  tileDrawFuncs[6](0, 0);
  tileDrawFuncs[7](0, 0);
  tileDrawFuncs[8](0, 0);
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[0], "black", "1", microImages[0].getContext('2d'));
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[1], "black", "1", microImages[1].getContext('2d'));
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[2], "black", "1", microImages[2].getContext('2d'));

  function main() {
    //if (refreshCanvas) { setTimeout(bufferDraw, 50); }
  }

  refreshLoop();
  //setInterval(main, 20);
  setInterval(logic, 20);
  setInterval(logic1000, 1000);
  setInterval(logic5000, 5000);
  setInterval(draw, 20);
</script>

</body>
</html>
