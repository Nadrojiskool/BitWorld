<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Explore and build in an asset-based digital world.">
    <meta name="author" content="Dubby the Goldfish">
    <title>BitWorld</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="canvas" width="1920" height="1080"></canvas>

<script type="text/javascript" src="https://unpkg.com/bsv@1.3.0/bsv.min.js"></script>
<script src="https://www.moneybutton.com/moneybutton.js"></script>
<script src='https://unpkg.com/datapay'></script>
<script src='https://unpkg.com/databutton'></script>
<div id='my-money-button'></div>



<script>
// BSV Library // https://bico.media/150a366b2142fcab0c4a951884162a25bb50d1ee1188449769ddf966da27c11d

  let bnMax = 99999999999999999999999999999999999999999999999999999999999999999999999999999n;
  let GX;
  let GY;
  let GI = 1;
  let priv = bsv.PrivateKey.fromRandom();
  let pub = bsv.PublicKey.fromPrivateKey(priv);
  let priv2 = bsv.PrivateKey.fromRandom();
  let pub2 = bsv.PublicKey.fromPrivateKey(priv2);
  let bn = priv.toBigNumber();
  let bn2 = priv2.toBigNumber();
  let bigNum = BigInt(bn) * BigInt(bn2);
  let bnPub = pub.point.getX();
  let bnPub2 = pub2.point.getX();
  let bigNumPub = BigInt(bnPub) * BigInt(bnPub2);

  function gOf(val) {
    GX = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getX().toString();
    GY = bsv.crypto.Point.getG().mul(bsv.crypto.BN.fromNumber(val)).getY().toString();
  }

</script>

<script>
  class User {
    constructor(mbid, mbn, mbt,  id = mbid, name = mbn) {
      this.id = id; // App User ID
      this.name = name; // Username
      this.mbid = mbid; // Money Button User ID
      this.mbn = mbn; // Money Button Name
      this.mbt = mbt; // Session Token // Money Button Access Token
    }
  }

  // currently testing button events
  // if condition(input) evaluates true, run action
  class Element {
    constructor(i, o) {
      this.condition = i;
      this.action = o; }
    evaluate(input = 0) {
      return this.condition(input); }
  }

  class Elements {
    constructor(n, f) {
      this.names = n;
      this.funcs = f; }
  }

  class GPS {
    constructor(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z; }}
  GPS.prototype.toString = function () {
    return (padXYZ(this.x, this.y, this.z)); };

  class Coord {
    constructor(x, y, xx = 0, yy = 0) {
      this.x = x;
      this.y = y;
      this.xx = xx;
      this.yy = yy; }}
  Coord.prototype.toString = function () {
    return (getCoord(this.x, this.y, this.xx, this.yy)); }

  class Land {
	  constructor(owner = padXYZ(manorX, manorY, 0)) {
      this.owner = owner; }
  }

  class Properties { // Cached Game Data Properties
    constructor(p = [10, 999, 999, (50-30), (50-17), 50, 50, [1000,0,0,0,0]]) {
            // current length : 8
        this.missionProgress = p[0];
        this.mapWidth = p[1];
        this.mapHeight = p[2];
        this.cameraX = p[3];
        this.cameraY = p[4];
        this.manorX = p[5];
        this.manorY = p[6];
        // let GDP = 100000; // denominated in copper pieces, G:Cx10000
        this.manorBank = p[7]; // $C, Food, Wood, Stone, Ore 
    }
    assignProperties() {

    }
  }

  // Property is an advanced and detailed piece of land (32x32 square)
  // Will replace BUILDING (or build on top)
  class Property {
	  constructor(type, terrain = [[]], objects = new Map(), capitol = null, production = 0) {
      this.type = type; // Draw/Structure ID
      this.terrain = terrain; // X&Y array of 32x32
      this.objects = objects; // Populated tiles
      this.capitol = capitol; // Logical parent tile
      this.production = production; // multiplier?
      this.units = new Map(); }
    calcProduction(skill) {
      let list = [ ...this.units.values() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor((skill == 0) ? units[ssn].skills[0][0] : units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
  }

  // Contracts alpha
  // Default no expiration and always active (24/7)
  class Contract {
	  constructor(promisor, promisee, period,
        pay = [1, 0], interval = 0, exp = 0, active = 0, 
        payFrom = promisor, payTo = promisee) {
      this.promisor = promisor;
      this.promisee = promisee;
      this.period = period;
      this.payment = new Payment(payFrom, payTo, pay[0], pay[1]);
      this.interval = interval;
      this.expiration = exp;
      this.active = active; }
      unWrap() {
          return [
              this.promisor, this.promise, this.period,
              this.payment.i, this.payment.o,
              this.payment.amount, this.payment.resource, this.payment.settlement,
              this.interval, this.expiration, this.active ]; }
      fill(terms, r = false) {
          //console.log(terms);
        this.promisor = terms[0];
        this.promisee = terms[1];
        this.period = terms[2];
        this.payment = new Payment(terms[3], terms[4], terms[5], terms[6], terms[7]);
        this.interval = terms[8];
        this.expiration = terms[9];
        this.active = terms[10];
        if (r) { return this; }}
  }
/*
  function unWrapBuildings(b = [ ...buildings.values() ]) {
      let arr = [];
      for (let i = 0; i < b.length; i++) {
          arr.push(b[i].unWrap());
      }
      return arr;
  }

  function unWrapContracts(building) {
      let contracts = [ ...building.units.values() ];
      let arr = [];
      for (let i = 0; i < contracts.length; i++) {
          arr.push(contracts[i].unWrap())
      }
      return arr;
  }
*/
  class Payment {
    constructor(i, o, $, r, f = (()=>{})) {
      this.i = i;
      this.o = o;
      this.amount = $;
      this.resource = r;
      this.settlement = f;
    }
  }

  class Building {
    constructor(id, u = new Map(), p = 0, c = 0) {
      this.id = id;
      this.units = u; // contracts mapped to ssn
        this.production = p;
      this.condition = c; }
    calcProduction(skill) {
      let list = [ ...this.units.keys() ];
      this.production = list.reduce((prod, ssn) =>
        prod + (Math.floor((skill == 0) ? units[ssn].skills[0][0] : units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
    assignUnits(keys = [], values = []) {
        //console.log(keys);
        //console.log(values);
        for (let i = 0; i < keys.length; i++) {
            let c = new Contract(0,0,0);
            //console.log(values[i]);
            c.fill(values[i]);
            this.units.set(keys[i], c); }}
    getContracts(vals = [...this.units.values()], arr = []) {
        vals.forEach(e => arr.push(e.unWrap()));
        return arr; }
    unWrap() {
        return [this.id, [ ...this.units.keys() ], unWrapContracts(this), this.production, this.condition];
    }
  }

  class Unit {
	  constructor(ssn, home, stats = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], sex = rnd(2), name = genName(sex), work = null,
            skills = [[0,0,0,0,0,0], 0, 0, 0, 0, 0, 0, 0, 0, 0], eq = [], ev = [], s = new Map()) {
        this.ssn = ssn; // unit list number
        this.home = home;
        this.stats = stats;
        this.name = name;
        this.img = null;
        this.iCan = document.createElement('canvas');
        this.iCan.height = 64;
        this.iCan.width = 64;
        this.iCtx = this.iCan.getContext("2d");
        drawArmy(0, 0, 2, (sex) ? "blue" : "pink", this.iCtx);
        this.work = null;
        this.skills = skills;
        this.equipment = [];
        this.events = []; // list of events
        this.scenarios = new Map(); }
    assignScenarios(keys, values) {
        for (let i = 0; i < keys.length; i++) { this.scenarios.set(keys[i], values[i]); }}
      unWrap() {
          return [this.ssn, this.home, this.name,
            this.stats, this.work, this.skills,
            this.equipment, this.events,
            this.scenarios.keys, this.scenarios.values()];
      }
      } // progress by scenario index

  /// Class to convert Stats array into object
  /// 0: Level (LVL) = 1 + Stats
  /// 1: Health (HP) = (10 + Tenacity(1)) * (Physique(2) ^ 2)
  /// 2: Attack (ATK) = (1 + Valor(5)) * (2 * Precision(4) + Physique(2))
  /// 3: Defense (DEF) = (1 + Valor(5)) * (2 * Tenacity(1) + Physique(2))
  /// 4: Speed (SPD) = 120 - Expertise(9) - (Agility(3) * Physique(2))
  class Stats { // must have array of length 10
    // xp, tenacity, physique, agility, precision, valor, charisma, intellect, wisdom, expertise //
    constructor(stats) {
      this.xp = stats[0];
      this.tenacity = stats[1];
      this.physique = stats[2];
      this.agility = stats[3];
      this.precision = stats[4];
      this.valor = stats[5];
      this.charisma = stats[6];
      this.intellect = stats[7];
      this.wisdom = stats[8];
      this.expertise = stats[9]; }}

  /// Class to convert skill xp pools into object
  class Skills {
    constructor(skills) {
      this.experience = [[skills[0][0]],[skills[0][1]],[skills[0][2]],
        [skills[0][3]],[skills[0][4]],[skills[0][5]]];
      this.gathering = skills[1];
      this.lumbering = skills[2];
      this.mining = skills[3];
      this.hunting = skills[4];
      this.cooking = skills[5]; }}

  class Event {
    constructor(id, input, output) {
      this.id = id;
      this.seed = input;
      this.value = output;
    }
  }
  // classes to conceptualize optimal citizen event tree progression
  class Scenario {
    constructor(events = []) {
      this.events = events;
    }
  }

  // Class of Notification Objects
  class Notification {
    constructor(text = "Blerg", func = ()=>{}, time = Date.now()){
      this.text = text; this.func = func; this.time = time; }}

  // Tasks:
  // 01: Patrol
  // 02: Gather Resource
	class Army { // Max Size in 32x32 tile, 128 units, 2x4 spacing
    units = [];
	  constructor(tileX, tileY, color, units = new Map(),
            l = 10, p = 0, h = 0, a = 0, d = 0, s = 0,
            t = 0, ac = 0, di = 0, mx = 0, my = 0) {
        this.tileX = tileX;
        this.tileY = tileY;
        this.color = color;
        this.units = units; // 
        this.level = l;
        this.production = p;
        this.health = h;
        this.attack = a;
        this.defense = d;
        this.speed = s;
        this.task = t;
        this.action = ac;
        this.direction = di;
        this.moveX = mx;
        this.moveY = my; }
      
        setStats() {

        }
        calcProduction(skill) {
            let list = [ ...this.units.keys() ];
            this.production = list.reduce((prod, ssn) =>
            prod + (Math.floor((skill == 0) ? units[ssn].skills[0][0] : units[ssn].skills[skill] / 10) + 1), 0) / list.length; }
        setTask(task = 0, action = 0) {
            this.task = task;
            this.action = action; }
        assignUnits(keys = [], values = []) {
            for (let i = 0; i < keys.length; i++) { this.units.set(keys[i], values[i]); }}
        unWrap() {
            return [this.tileX, this.tileY, this.color,
                unWrapUnits(this),
                this.level, this.production, this.health, this.attack,
                this.defense, this.speed, this.task, this.action,
                this.direction, this.moveX, this.moveY];
        }
    }
/*
    function unWrapArmies(a = [ ...armies.values() ]) {
      let arr = [];
      for (let i = 0; i < a.length; i++) {
          arr.push(a[i].unWrap());
      }
      return arr;
    }

    function unWrapUnits(army) {
      let units = [ ...army.units.values() ];
      let arr = [];
      for (let i = 0; i < units.length; i++) {
          arr.push(units[i].unWrap())
      }
      return arr;
    }
*/
  class Region { // resources = [0, food, currency, culture, lumber, stone, 0, 0, 0, 0]
    constructor(lord, domain = [], resources = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) {
      this.lord = lord;
      this.domain = domain;
      this.resources = resources; }
  }

  class Tech {
	  constructor(name, id, requiredTechs, researched = false) {
      this.name = name;
      this.id = id;
      this.requiredTechs = requiredTechs;
      this.researched = researched; }}

  class Effect {
    constructor(drawFunc, frames) {
      this.draw = drawFunc;
      this.frame = frames; }
  }

  /*let { MoneyButtonClient } = require('@moneybutton/api-client');
  let moneyButtonClient = new MoneyButtonClient(b3536e2a2b10f7fbf0177c9660aa5d35);
  moneyButtonClient.requestAuthorization('auth.user_identity:read', OAUTH_REDIRECT_URI);
  await moneyButtonClient.handleAuthorizationResponse();
  const { id: moneyButtonId } = await moneyButtonClient.getIdentity();*/

	let canvas = document.getElementById("canvas");
	let ctx = canvas.getContext("2d");
  let defaultAlpha = ctx.globalAlpha;
  canvas.offscreenCanvas = document.createElement('canvas');
  canvas.offscreenCanvas.width = canvas.width;
  canvas.offscreenCanvas.height = canvas.height;
  let isMobile = (/Mobile/i.test(navigator.userAgent));
  const oApp = "01c0a789feb65c24222346e36b080df0"; // MB App oAuth ID
  const bUrl = "https://main.bitworld.life/"; // Back-end Endpoint
  const fUrl = "https://www.bitworld.life/"; // Hosted on Infinity Free
  let cUrl = window.location.href; // Current URL
  let authCode; // URL Code to Retrieve Token
  let Token; // oAuth Token to Retrieve Data
  let UserID;
  let UserName;
  let Users = new Map();
  const mbUrls = { 'Token': "https://www.moneybutton.com/oauth/v1/token",
      'Identity': "https://www.moneybutton.com/api/v1/auth/user_identity",
      'Auth': "https://www.moneybutton.com/oauth/v1/authorize".concat(
        "?response_type=" + 'code',
        "&client_id=" + oApp,
        "&redirect_uri=" + fUrl,
        "&scope=" + 'auth.user_identity:read',
        "&state=" + 'supersecurestring')};
            
    console.log(window.location.href)
  console.log(mbUrls.Auth);
  
  let Workers = new Map();
  let Cache = window.localStorage;
  let snd = new Audio("https://bico.media/150a366b2142fcab0c4a951884162a25bb50d1ee1188449769ddf966da27c11d");
	snd.volume = 0.2;
  let fieldX = 0;
	let fieldY = 0;
	let biomeDraws = ['#055000', 'white', "goldenrod"];
  let biomeNames = ["Plains", "Arctic", "Desert"];
  let tileDraws = ['black', 'black', 'darkblue', '#808000', "rgba(150,150,150,1)", "rgba(69,69,69,1)", "rgba(69,69,69,1)"];
  let canvasObjects = [
    [ document.createElement('canvas'), document.createElement('canvas') ]
  ];
  canvasObjects[0][0].width = 64;
  canvasObjects[0][0].height = 64;
  canvasObjects[0][1].width = 64;
  canvasObjects[0][1].height = 64;
  let canvasImages = [
    [
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ],
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ],
      [
        document.createElement('canvas'),
        document.createElement('canvas')
      ]
    ],
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas')
  ];
  canvasImages[0][0][0].width = 32;
  canvasImages[0][0][0].height = 32;
  canvasImages[0][0][1].width = 32;
  canvasImages[0][0][1].height = 32;
  canvasImages[0][1][0].width = 32;
  canvasImages[0][1][0].height = 32;
  canvasImages[0][1][1].width = 32;
  canvasImages[0][1][1].height = 32;
  canvasImages[0][2][0].width = 32;
  canvasImages[0][2][0].height = 32;
  canvasImages[0][2][1].width = 32;
  canvasImages[0][2][1].height = 32;
  canvasImages[1].width = 32;
  canvasImages[1].height = 32;
  canvasImages[2].width = 32;
  canvasImages[2].height = 32;
  canvasImages[3].width = 32;
  canvasImages[3].height = 32;
  canvasImages[4].width = 32;
  canvasImages[4].height = 32;
  canvasImages[5].width = 32;
  canvasImages[5].height = 32;
  canvasImages[6].width = 32;
  canvasImages[6].height = 32;
  canvasImages[7].width = 32;
  canvasImages[7].height = 32;
  canvasImages[8].width = 32;
  canvasImages[8].height = 32;
  canvasImages[9].width = 32;
  canvasImages[9].height = 32;
  canvasImages[10].width = 32;
  canvasImages[10].height = 32;
  canvasImages[11].width = 32;
  canvasImages[11].height = 32;
  canvasImages[12].width = 32;
  canvasImages[12].height = 32;
  canvasImages[13].width = 32;
  canvasImages[13].height = 32;
  canvasImages[14].width = 32;
  canvasImages[14].height = 32;
  canvasImages[15].width = 32;
  canvasImages[15].height = 32;
  let ctxObjects = [
    [ canvasObjects[0][0].getContext("2d"), canvasObjects[0][1].getContext("2d") ]
  ];
  let ctxImages = [
    [
      [
        canvasImages[0][0][0].getContext("2d"),
        canvasImages[0][0][1].getContext("2d")
      ],
      [
        canvasImages[0][1][0].getContext("2d"),
        canvasImages[0][1][1].getContext("2d")
      ],
      [
        canvasImages[0][2][0].getContext("2d"),
        canvasImages[0][2][1].getContext("2d")
      ]
    ],
    canvasImages[1].getContext("2d"),
    canvasImages[2].getContext("2d"),
    canvasImages[3].getContext("2d"),
    canvasImages[4].getContext("2d"),
    canvasImages[5].getContext("2d"),
    canvasImages[6].getContext("2d"),
    canvasImages[7].getContext("2d"),
    canvasImages[8].getContext("2d"),
    canvasImages[9].getContext("2d"),
    canvasImages[10].getContext("2d"),
    canvasImages[11].getContext("2d"),
    canvasImages[12].getContext("2d"),
    canvasImages[13].getContext("2d"),
    canvasImages[14].getContext("2d"),
    canvasImages[15].getContext("2d")
  ];
  let microImages = [
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas')
  ];
  microImages[0].width = 8;
  microImages[0].height = 8;
  microImages[1].width = 8;
  microImages[1].height = 8;
  microImages[2].width = 8;
  microImages[2].height = 8;
  let drawTile1 = [
    document.createElement('canvas'),
    document.createElement('canvas'),
    document.createElement('canvas')
  ];
  drawTile1[0].width = 1;
  drawTile1[0].height = 1;
  drawTile1[1].width = 1;
  drawTile1[1].height = 1;
  drawTile1[2].width = 1;
  drawTile1[2].height = 1;

  let WorkerTemplates = {
    'NetWorker': function netWorker() {
      const oApp = "01c0a789feb65c24222346e36b080df0"; // MB App oAuth ID
      const bUrl = "https://main.bitworld.life/"; // Back-end Endpoint
      const fUrl = "https://www.bitworld.life/"; // Hosted on Infinity Free
      const mbUrls = { 'Token': "https://www.moneybutton.com/oauth/v1/token",
          'Identity': "https://www.moneybutton.com/api/v1/auth/user_identity",
          'Auth': "https://www.moneybutton.com/oauth/v1/authorize".concat(
            "?response_type=" + 'code',
            "&client_id=" + oApp,
            "&redirect_uri=" + fUrl,
            "&scope=" + 'auth.user_identity:read',
            "&state=" + 'supersecurestring')};

      let requests = {
          'GET' : (headers) => { return new Request(bUrl, {
              method: 'GET',
              headers: new Headers(),
              mode: 'cors' })},
          'POST' : (body) => { return new Request(bUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'text/plain' },
              mode: 'cors',
              body: body })},
          'MB' : (body) => { return new Request(mbUrls.Token, {
              method: 'POST',
              headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
              body: body })},
          'MBR' : (token) => { return new Request(mbUrls.Identity, {
              method: 'GET',
              headers: new Headers({'Authorization': 'Bearer ' + token}),
              mode: 'cors' })}
      };
      
      function getMap(method = 'GET', headers = new Headers()) {
          console.log("Data requested.");
          fetch(requests[method](headers))
              .then(function(response) {
                  console.log(response);
                  return response.text(); })
              .then(function(text) {
                  self.postMessage([JSON.parse(text)]);
                  console.log('Request successful', text); })
              .catch(function(error) {
                  console.log('Request failed', error) });
      }

      function postMap(method = 'POST', 
              body = JSON.stringify({ x: 100, y: 100, val: 1 })) {
          fetch(requests[method](body))
              .then(function(response) {
                  console.log(response);
                  return response.text(); })
              .then(function(text) {
                  token = JSON.parse(text).access_token;
                  console.log('Request successful', text);
                  if (method == 'MB') { getMap('MBR', token); }})
              .catch(function(error) {
                  console.log('Request failed', error) });
      }

      self.onmessage = function (msg) {
        method = msg.data[0];
        body = msg.data[1];
        (method == 'GET') ? getMap(method, body) : postMap(method, body);
      }
      
      //setInterval(postMap, 10000);
      //setTimeout(logger, 10000);
    },

    'MapWorker': function mapWorker() {
      let fieldX;
      let fieldY;
      let biomeDraws = ['#055000', 'white', "goldenrod"];
      let drawTile1;
      let canvas;
      let ctx;
      let map;

      function inRange(num, min = 0, max = 999) {
        return ((num <= max && num >= min) ? true : false ) }

      function genCanvas(x = fieldX, y = fieldY) {
        canvas = new OffscreenCanvas(x * 32, y * 32);
        ctx = canvas.getContext("2d");
        drawTile1 = [
          new OffscreenCanvas(1, 1),
          new OffscreenCanvas(1, 1),
          new OffscreenCanvas(1, 1)
        ];
        drawRectangle(0, 0, 1, 1, true, false, biomeDraws[0], "black", "1", drawTile1[0].getContext('2d'));
        drawRectangle(0, 0, 1, 1, true, false, biomeDraws[1], "black", "1", drawTile1[1].getContext('2d'));
        drawRectangle(0, 0, 1, 1, true, false, biomeDraws[2], "black", "1", drawTile1[2].getContext('2d'));
      }

      function drawRectangle(x, y, width, height, fill = true, stroke = true,
          fillColor = "black", strokeColor = "black", strokeWidth = "3", canvas = ctx) {
        canvas.beginPath();
        canvas.rect(x, y, width, height);
        if (fill) { 
          canvas.fillStyle = fillColor; 
          canvas.fill();
        if (stroke) { 
          canvas.strokeStyle = strokeColor;
          canvas.lineWidth = strokeWidth;
          canvas.stroke(); }}}

      function createChunks() {
        tileChunks = [];
        for (let x = 0; x < fieldX; x++) {
          tileChunks[x] = [];
          for (let y = 0; y < fieldY; y++) {
            tileChunks[x][y] = new OffscreenCanvas(32, 32); }}}

      function fillChunks() {
        for (let y = 0; y < fieldY; y++) {
          for (let x = 0; x < fieldX; x++) {
            for (let yy = 0; yy < 32; yy++) {
              for (let xx = 0; xx < 32; xx++) {
                tileChunks[x][y].getContext("2d").drawImage((inRange(xx + (x * 32)) && inRange(yy + (y * 32))) ? 
                  drawTile1[map[xx + (x * 32)][yy + (y * 32)]] : drawTile1[0], xx, yy); }}
            canvas.getContext("2d").drawImage(tileChunks[x][y], x * 32, y * 32); }}}

      self.onmessage = function (msg) {
        fieldX = msg.data[0];
        fieldY = msg.data[1];
        map = msg.data[2];
        genCanvas();
        createChunks();
        fillChunks();
        self.postMessage([canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height)]);
        self.close();
      }
    }
  }

  function getProperties() { // 8
      return [ missionProgress, mapWidth, mapHeight, cameraX, cameraY, manorX, manorY, manorBank ]; }

  function setProperties(p) { // 8
      missionProgress = p[0];
      mapWidth = p[1];
      mapHeight = p[2];
      cameraX = p[3];
      cameraY = p[4];
      manorX = p[5];
      manorY = p[6];
      manorBank = p[7];
  }

  let notifications = [];

  let animations = [new Map(), new Map(), new Map()];

  let timeScale = 24;
  let tileScale = 32;
  let tileChunks = 0;
  let tileBigChunks = 0;
  let tileNames = ["Zero", "Fill", "Water", "Forest", "Mountain", "Cottage", "Shack", "Mine", "Lumber Mill", "Campsite",
    "Smithy", "Stable", "Store", "Pub", "Restaurant", "Inn"];
  let tileResourceIndex = [[0],[0],[2],[3],[4],[1],[1],[4],[3],[2],[0],[0],[0],[0],[0],[0]];
  let tileActionIndex = new Elements;
  tileActionIndex.names = [
      [], [],
      ["", "Build"],
      ["", "Build"],
      ["", "Build"],
      ["", "Details", "Residents", "Modify"],
      ["", "Details", "Residents", "Modify"],
      ["", "Details", "Workers", "Modify"],
      ["", "Details", "Workers", "Modify"],
      ["", "Details", "Residents", "Modify"],
      ["", "Details", "Workers", "Modify"], // [10]
      ["", "Details", "Workers", "Modify"],
      ["", "Details", "Workers", "Modify", "Wares"],
      ["", "Details", "Workers", "Modify"],
      ["", "Details", "Workers", "Modify"],
      ["", "Details", "Workers", "Modify"]
  ]
  tileActionIndex.funcs = [
      [()=>{}], [()=>{}],
      [()=>{}, ()=>{}],
      [()=>{}, ()=>{}],
      [()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}], // [10]
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}, ()=>{ menus[1] = (menus[1] == 1) ? 15 : 1; }],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}],
      [()=>{}, ()=>{}, ()=>{}, ()=>{}]
  ]
  let tileDetails = [
      [], [], [], [], [],
      [(data) => {}],
      []
  ]

  let mNames = ["John",	"William",	"Robert",	"James",	"Charles",	"George",	"Joseph",	"Edward",	"Frank",	"Richard",	"Thomas",	"Harold",	"Walter",	"Paul",	"Raymond",	"Donald",	"Henry",	"Arthur",	"Albert",	"Jack",	"Harry",	"Ralph",	"Kenneth",	"Howard",	"David",	"Clarence",	"Carl",	"Louis",	"Willie",	"Eugene",	"Earl",	"Roy",	"Fred",	"Francis",	"Joe",	"Lawrence",	"Ernest",	"Leonard",	"Warren",	"Stanley",	"Herbert",	"Alfred",	"Anthony",	"Samuel",	"Elmer",	"Bernard",	"Norman",	"Leo",	"Andrew",	"Michael",	"Russell",	"Daniel",	"Edwin",	"Melvin",	"Chester",	"Leroy",	"Peter",	"Lloyd",	"Clifford",	"Frederick",	"Floyd",	"Marvin",	"Theodore",	"Gerald",	"Vernon",	"Herman",	"Ray",	"Clyde",	"Lester",	"Charlie",	"Philip",	"Lewis",	"Vincent",	"Milton",	"Leon",	"Alvin",	"Cecil",	"Martin",	"Jesse",	"Glenn",	"Victor",	"Lee",	"Benjamin",	"Sam",	"Gordon",	"Wayne",	"Harvey",	"Willard",	"Edgar",	"Oscar",	"Arnold",	"Claude",	"Wallace",	"Allen",	"Everett",	"Stephen",	"Gilbert",	"Wilbur",	"Johnnie",	"Homer",	"Virgil",	"Maurice",	"Roger",	"Eddie",	"Dale",	"Douglas",	"Sidney",	"Morris",	"Marion",	"Leslie",	"Jessie",	"Max",	"Hubert",	"Roland",	"Hugh",	"Irving",	"Alexander",	"Manuel",	"Franklin",	"Curtis",	"Bill",	"Glen",	"Luther",	"Nicholas",	"Julius",	"Jerome",	"Steve",	"Horace",	"Wesley",	"Jose",	"Tom",	"Billy",	"Willis",	"Orville",	"Oliver",	"Tony",	"Ben",	"Edmund",	"Calvin",	"Earnest",	"Mike",	"Alex",	"Jacob",	"Jerry",	"Archie",	"Otis",	"Jimmie",	"Don",	"Bruce",	"Delbert",	"Lyle",	"Matthew",	"Clayton",	"Guy",	"Angelo",	"Clifton",	"Salvatore",	"Clinton",	"Patrick",	"Wilbert",	"Bennie",	"Marshall",	"Ervin",	"Phillip",	"Jim",	"Nathaniel",	"Emil",	"Ronald",	"Rudolph",	"Ira",	"Merle",	"Nathan",	"Gene",	"Sylvester",	"Keith",	"Wilfred",	"Leland",	"Forrest",	"Ivan",	"Dean",	"Elbert",	"Irvin",	"Woodrow",	"Johnny",	"Dan",	"Lonnie",	"Nelson",	"Rufus",	"Bob",	"Antonio",	"Isaac",	"Johnie",	"Junior",	"Nick",	"Julian",	"Grover",	"Alton",	"Lowell",	"Aaron",	"Felix",	"Jay",	"Seymour",	"Abraham",	"Ellis",	"Pete",	"Otto",	"Dennis",	"Dewey",	"Emmett",	"Rex",	"August",	"Carroll",	"Juan",	"Roscoe",	"Grady",	"Percy",	"Owen",	"Bert",	"Mark",	"Elwood",	"Wilson",	"Loyd",	"Adam",	"Byron",	"Dominick",	"Fredrick",	"Malcolm",	"Laurence",	"Myron",	"Ross",	"Ted",	"Wendell",	"Perry",	"Dominic",	"Allan",	"Mack",	"Loren",	"Jesus",	"Murray",	"Billie",	"Adolph",	"Troy",	"Eldon",	"Norbert",	"Karl",	"Amos",	"Neil",	"Sherman",	"Charley",	"Harley",	"Preston",	"Aubrey",	"Austin",	"Reuben",	"Erwin",	"Boyd",	"Duane",	"Freddie",	"Wilmer",	"Carlton",	"Larry",	"Morton",	"Alan",	"Burton",	"Cornelius",	"Edmond",	"Carlos",	"Louie",	"Millard",	"Steven",	"Mitchell",	"Tommie",	"Dwight",	"Lynn",	"Gerard",	"Mario",	"Harrison",	"Garland",	"Elmo",	"Doyle",	"Elton",	"Grant",	"Russel",	"Jasper",	"Ramon",	"Moses",	"Kermit",	"Emanuel",	"Laverne",	"Maynard",	"Dave",	"Rocco",	"Neal",	"Will",	"Wade",	"Jake",	"Thurman",	"Francisco",	"Darrell",	"Monroe",	"Roosevelt",	"Cleveland",	"Solomon",	"Rodney",	"Cleo",	"Dallas",	"Earle",	"Joel",	"Tommy",	"Simon",	"Clair",	"Quentin",	"Odell",	"Ruben",	"Delmar",	"Irwin",	"Jess",	"Elvin",	"Harlan",	"Alphonse",	"Dick",	"Stuart",	"Armand",	"Weldon",	"Jimmy",	"Marcus",	"Andy",	"Merlin",	"Gus",	"Claud",	"Ed",	"Alonzo",	"Clark",	"Clement",	"Emory",	"Conrad",	"Thaddeus",	"Orval",	"Christopher",	"Randolph",	"Bruno",	"Carmen",	"Forest",	"Ollie",	"Merrill",	"Patsy",	"Ward",	"Adrian",	"Alfonso",	"Ned",	"Emery",	"Pedro",	"Alva",	"Buford",	"Cyril",	"Elijah",	"Jean",	"Vito",	"Reginald",	"Vern",	"Hollis",	"Benny",	"Lionel",	"Stewart",	"Hyman",	"Timothy",	"Wilburn",	"Sammie",	"Barney",	"Wiley",	"Truman",	"Anton",	"Emerson",	"Sterling",	"Levi",	"Eli",	"Mervin",	"Wilford",	"Roman",	"Sol",	"Ellsworth",	"Herschel",	"Basil",	"Noah",	"Coy",	"Travis",	"Teddy",	"Lavern",	"Jackson",	"Miles",	"Harding",	"Milford",	"Spencer",	"Norris",	"Winfred",	"Harris",	"Hiram",	"Silas",	"Milo",	"Van",	"Luis",	"Sanford",	"Carmine",	"Rolland",	"Winston",	"Ambrose",	"Pasquale",	"Abe",	"Buster",	"Jeff",	"Mathew",	"Vance",	"Casimir",	"Noel",	"Saul",	"Pat",	"Salvador",	"Foster",	"Freeman",	"Gabriel",	"Lenard",	"Bertram",	"Royal",	"Sheldon",	"Dudley",	"Isadore",	"Noble",	"Shirley",	"Booker",	"Mary",	"Aloysius",	"Hershel",	"Odis",	"Frederic",	"Hal",	"Scott",	"Denver",	"Lorenzo",	"Newton",	"Omer",	"Ulysses",	"Delmer",	"Olin",	"Bud",	"Eric",	"Ferdinand",	"Lamar",	"Lyman",	"Orlando",	"Alden",	"Anderson",	"Chris",	"Elliott",	"Gregory",	"Raul",	"Sydney",	"Gale",	"Guadalupe",	"Burl",	"Darwin",	"Houston",	"Micheal",	"Cletus",	"Royce",	"Marlin",	"Gail",	"Randall",	"Bobby",	"Major",	"Elias",	"Hobert",	"Luke",	"Riley",	"Augustus",	"Everette",	"Hoyt",	"Olen",	"Armando",	"Hugo",	"Linwood",	"Morgan",	"Evan",	"Warner",	"Wilton",	"Arlie",	"Nolan",	"Rupert",	"Jefferson",	"Dewitt",	"Junius",	"Walker",	"Wilber",	"Al",	"Merton",	"Waldo",	"Mckinley",	"Roberto",	"Clay",	"Lemuel",	"Shelby"];
  let fNames = ["Mary",	"Dorothy",	"Helen",	"Margaret",	"Ruth",	"Mildred",	"Virginia",	"Elizabeth",	"Frances",	"Anna",	"Betty",	"Evelyn",	"Marie",	"Doris",	"Alice",	"Florence",	"Irene",	"Lillian",	"Louise",	"Rose",	"Catherine",	"Gladys",	"Martha",	"Marjorie",	"Eleanor",	"Ruby",	"Edna",	"Josephine",	"Lucille",	"Ethel",	"Thelma",	"Edith",	"Jean",	"Hazel",	"Annie",	"Pauline",	"Grace",	"Lois",	"Esther",	"Bernice",	"Beatrice",	"Gertrude",	"Marion",	"Clara",	"Katherine",	"Emma",	"Barbara",	"Jane",	"Ann",	"Sarah",	"Elsie",	"Rita",	"June",	"Agnes",	"Julia",	"Shirley",	"Bertha",	"Eva",	"Viola",	"Geraldine",	"Juanita",	"Pearl",	"Laura",	"Vivian",	"Anne",	"Ida",	"Kathryn",	"Myrtle",	"Norma",	"Lorraine",	"Bessie",	"Phyllis",	"Marian",	"Willie",	"Vera",	"Nellie",	"Violet",	"Wilma",	"Charlotte",	"Alma",	"Maxine",	"Stella",	"Mabel",	"Jessie",	"Sylvia",	"Genevieve",	"Minnie",	"Ella",	"Leona",	"Lillie",	"Kathleen",	"Ellen",	"Marguerite",	"Lucy",	"Nancy",	"Mattie",	"Jennie",	"Lena",	"Mae",	"Eileen",	"Opal",	"Blanche",	"Audrey",	"Patricia",	"Velma",	"Geneva",	"Elaine",	"Theresa",	"Beulah",	"Dolores",	"Sara",	"Harriet",	"Georgia",	"Jeanne",	"Eunice",	"Rosa",	"Wanda",	"Christine",	"Emily",	"Loretta",	"Carrie",	"Inez",	"Muriel",	"Janet",	"Hilda",	"Jeanette",	"Fannie",	"Alberta",	"Sophie",	"Maria",	"Anita",	"Hattie",	"Dora",	"Naomi",	"Verna",	"Ada",	"Cora",	"Madeline",	"Lula",	"Miriam",	"Rosemary",	"Mamie",	"Joan",	"Roberta",	"Arlene",	"Olga",	"Lola",	"Mable",	"Flora",	"Carolyn",	"Olive",	"Erma",	"Joyce",	"Bonnie",	"Daisy",	"Rachel",	"Nora",	"Estelle",	"Caroline",	"Winifred",	"Marcella",	"Rosie",	"Susie",	"Irma",	"Constance",	"Lucile",	"Lorene",	"Margie",	"Eula",	"Fern",	"Henrietta",	"Maggie",	"Victoria",	"Sadie",	"Rebecca",	"Adeline",	"Lottie",	"Eloise",	"Nina",	"Antoinette",	"Nettie",	"Carol",	"Della",	"Katie",	"Lydia",	"Regina",	"Dorothea",	"Laverne",	"Jeannette",	"Amelia",	"Cleo",	"Veronica",	"Angelina",	"Claire",	"Gloria",	"Bette",	"Essie",	"Goldie",	"Isabel",	"Rosalie",	"Freda",	"Donna",	"Sally",	"May",	"Ollie",	"Adele",	"Beverly",	"Faye",	"Angeline",	"Melba",	"Addie",	"Billie",	"Isabelle",	"Effie",	"Ora",	"Jewell",	"Cecelia",	"Lela",	"Peggy",	"Annette",	"Ernestine",	"Iva",	"Johnnie",	"Luella",	"Susan",	"Leola",	"Lila",	"Jewel",	"Imogene",	"Etta",	"Sallie",	"Bettie",	"Selma",	"Elva",	"Janie",	"Gwendolyn",	"Carmen",	"Cecilia",	"Ola",	"Eleanore",	"Delores",	"Celia",	"Teresa",	"Alta",	"Lizzie",	"Sue",	"Yvonne",	"Reba",	"Maude",	"Fay",	"Ina",	"Helene",	"Frieda",	"Janice",	"Angela",	"Nell",	"Elinor",	"Nannie",	"Francis",	"Priscilla",	"Matilda",	"Iris",	"Amy",	"Estella",	"Elnora",	"Elma",	"Lenora",	"Elvira",	"Nadine",	"Harriett",	"Eugenia",	"Arline",	"Annabelle",	"Ila",	"Mollie",	"Neva",	"Clarice",	"Natalie",	"Sophia",	"Flossie",	"Lee",	"Jacqueline",	"Margery",	"Gracie",	"Virgie",	"Leah",	"Olivia",	"Marilyn",	"Myra",	"Carmela",	"Edythe",	"Connie",	"Rena",	"Winnie",	"Mavis",	"Sybil",	"Cecile",	"Millie",	"Adelaide",	"Hannah",	"Bernadine",	"Carmella",	"Madge",	"Odessa",	"Aileen",	"Frankie",	"Cornelia",	"Zelma",	"Berniece",	"Aline",	"Lorena",	"Avis",	"Dorthy",	"Josie",	"Alyce",	"Letha",	"Willa",	"Rhoda",	"Rosetta",	"Concetta",	"Allie",	"Rosella",	"Leila",	"Merle",	"Lenore",	"Dollie",	"Eliza",	"Corinne",	"Claudia",	"Loraine",	"Lily",	"Jimmie",	"Christina",	"Helena",	"Amanda",	"Corine",	"Joy",	"Iona",	"Ramona",	"Lora",	"Judith",	"Ione",	"Tillie",	"Florine",	"Callie",	"Hester",	"Marcia",	"Ophelia",	"Beth",	"Hope",	"Katharine",	"Linda",	"Dolly",	"Paula",	"Leota",	"Althea",	"Lou",	"Earline",	"Wilda",	"Bernadette",	"Maudie",	"Gussie",	"Iola",	"Dixie",	"Lessie",	"Guadalupe",	"Reva",	"Yolanda",	"Mercedes",	"Kay",	"Stephanie",	"Tessie",	"Antonia",	"Beryl",	"Pearlie",	"Lilly",	"Eddie",	"Bertie",	"Nola",	"Augusta",	"Madelyn",	"Johanna",	"Charlene",	"Bobbie",	"Theda",	"Polly",	"Robbie",	"Cynthia",	"Suzanne",	"Georgie",	"Lupe",	"Dessie",	"Delia",	"Roxie",	"John",	"Melva",	"Lelia",	"Aurora",	"Darlene",	"Harriette",	"Oma",	"Allene",	"Verda",	"Philomena",	"Deloris",	"Glenna",	"Evangeline",	"Maurine",	"Alene",	"Consuelo",	"Mona",	"Enid",	"Elisabeth",	"Erna",	"Kate",	"Margarita",	"Mozelle",	"Alvina",	"Hallie",	"Isabella",	"Nona",	"Garnet",	"Isabell",	"James",	"Dortha",	"Jannie",	"Molly",	"Corrine",	"Zella",	"Vesta",	"Jaunita",	"Lorine",	"Rubye",	"Marjory",	"Clare",	"Belle",	"Lorna",	"Marietta",	"Pansy",	"Tommie",	"Valeria",	"Ruthie",	"Diana",	"Jo",	"Birdie",	"Queen",	"Ester",	"Leta",	"Madeleine",	"Syble",	"Nelda",	"Hortense",	"Dorris",	"Fanny",	"Winona",	"Elouise",	"Phoebe",	"Vida",	"Oleta",	"Roslyn",	"Louella",	"Monica",	"Leora",	"Wilhelmina",	"Cecil",	"Jayne",	"Elvera",	"Mayme",	"Rosalind",	"Elise",	"Joanne",	"Zelda",	"Agatha",	"Alfreda",	"Catharine",	"Robert",	"William",	"Gene",	"Marianne",	"Minerva",	"Ferne",	"Katheryn",	"Judy",	"Julie",	"Lucinda",	"Manuela",	"Freida",	"Leone",	"Elda",	"Rae",	"Charlie",	"Adell",	"Patsy",	"Dovie",	"Rowena",	"Vada",	"Emilie",	"Veda",	"Ilene",	"Louisa"];
  let surNames = ["Abraham",	"Adler",	"Allen",	"Ankins",	"Arandt",	"Arthur",	"Avery",	"Baker",	"Barnham",	"Basis",	"Belanger",	"Bentz",	"Bessler",	"Best",	"Bevard",	"Bhenki",	"Blakely",	"Bleeker",	"Bouche",	"Boursaw",	"Brant",	"Brawley",	"Bretz",	"Brock",	"Brockman",	"Bruce",	"Buchman",	"Burnett",	"Burnette",	"Burns",	"Buss",	"Butterfield",	"Caffey",	"Cantin",	"Christopher",	"Click",	"Codere",	"Collins",	"Coutu",	"Cowell",	"Cowman",	"Crankovitch",	"Cuthburt",	"Cuttling",	"Darwin",	"Davis",	"Dorman",	"Drafs",	"Drefs",	"Eakley",	"Eddie",	"Edwards",	"Elliott",	"Elsner",	"English",	"Ernlaid",	"Fahlett",	"Fanbrick",	"Fandrick",	"Farwell",	"Feigel",	"Felten",	"Fenske",	"Fergin",	"Feigel",	"Fillman",	"Finley",	"Firske",	"Flatt",	"Floria",	"Fralich",	"Fralich",	"Franklin",	"Freeman",	"Frisbe",	"Furlong",	"Gager",	"Garvin",	"Germain",	"Gohl",	"Goodwin",	"Gray",	"Greenwald",	"Greenwalt",	"Griffen",	"Griffith",	"Hahn",	"Halsted",	"Hammermeister",	"Hancock",	"Harmal",	"Hass",	"Hastings",	"Hayes",	"Heminger",	"Henchal",	"Hessen",	"Hidland",	"Hilt",	"Hogue",	"Hollister",	"Hollman",	"Howell",	"Hyde",	"Kasper",	"Kegley",	"Kinney",	"Kisro",	"Kleeman",	"Kloburcher",	"Leach",	"Lehman",	"Len",	"Lesatz",	"Levard",	"Lindh",	"Lraise",	"Luckstrim",	"Lynch",	"Madison",	"Manse",	"Mantei",	"Marcus",	"Markus",	"Markwart",	"Matchinski",	"Mathews",	"McAlpine",	"McBurney",	"McCarney",	"McCown",	"McCutchen",	"McCutcheon",	"McDonald",	"McGraw",	"Merrick",	"Metic",	"Molzan",	"Mondt",	"Morris",	"Moses",	"Neyenquam",	"Nickels",	"Norval",	"O'Connell",	"Olson",	"O'Neal",	"O'Neil",	"Ozanich",	"Pantiel",	"Patterson",	"Patzer",	"Peppin",	"Perkins",	"Porter",	"Posch",	"Price",	"Proton",	"Rapin",	"Rapp",	"Raslo",	"Razner",	"Renaldt",	"Rifenberg",	"Riley",	"Ripley",	"Rosental",	"Rossini",	"Russell",	"Sawyer",	"Schiltgan",	"Schiltzen",	"Schliske",	"Schmidt",	"School",	"Schroeder",	"Schuthosk",	"Schwarm",	"Schwartz",	"Shane",	"Shattuck",	"Shaw",	"Simmons",	"Slack",	"Smith",	"Speltzer",	"St. Dennis",	"Stewart",	"Stimac",	"Strenburg",	"Strong",	"Stroshine",	"Swanson",	"Syveran",	"Tenker",	"Thomas",	"Traver",	"Urton",	"Vallier",	"Wagner",	"Wall",	"Walsted",	"Warner",	"Webber",	"Welch",	"Wentlandt",	"Westin",	"White",	"Wilkilgon",	"Wiltsey",	"Winters",	"Woods",	"Yeske",	"Zibart"];
  let eventIndex = ["It's been a long day.",
    "Today was a good day.",
    "I met someone nice today.",
    "I'm late for work!",
    "I'm bored.",
    "I need a vacation.",
    "I'm in love.",
    "I love my job.",
    "I need a new job.",
    "I'm exhausted."
  ] // eventually replace with event generator and event trees
  
  // need to add flexibility for embedded scenario events,
  // as well as exclusivity/decision/RNG branches
  // need to add support for repeatable events
  let scenarioIndex = [ // "Scenario types"
    0,
    [ // "Work related"
      0,
      [
        "Good at job.",
        "Boss said I good.",
        "Eligible for promotion.",
        "I've been promoted!"
      ],
      [
        "Bad at job.",
        "I messed up.",
        "Boss doesn't like me.",
        "My last warning.",
        "I've been demoted."
      ],
      [
        "Happy with job.",
        "I feel motivated today.",
        "I'm staying late today.",
        "Complimented on hard work."
      ],
      [
        "Not happy here.",
        "Maybe I should apply elsewhere.",
        "I can't keep up with my work.",
        "I'm stuck late today.",
        "I got scolded for falling behind."
      ]
    ],
    [ // Love related
      0,
      [
        "I met someone new.",
        "We went on our first date.",
        "I think I'm in love.",
        "Should I propose?",
        "We're engaged!",
        "It's time to start a family.",
        "Baby on the way!",
        "Our first child is born."
      ]
    ],
    [ // Life related
      0,
      [
        "I don't feel well.",
        "Going to the doctor.",
        "Everything checks out.",
        "Not getting better.",
        "Seeing the doctor again.",
        "I have cancer.",
        "Treatment makes me sick.",
        "I'm nearly out of time.",
        "I'll enjoy what's left.",
        "Going out with a bang.",
        "This is the end."
      ]
    ]
  ];

  let missionProgress = 10;
  let showMissionText = true;
  let missionIndex = [
    [],
    [
      "Welcome to BitWorld!",
      "You and your companions have traveled to this land seeking a place to stake your claim.",
      "You sold everything you had to settle this land, now you must gather the materials needed to build your home.",
      "First, let's select the location of your Manor.",
      "Simply open up the Build menu and choose a location for the residence of your Manor.",
      () => { return (buildings.size > 0) ? true : false; },
      [
        "Great! Your companions have already set their homes to your manor.",
        "Your residence hasn't been completed, however. You must assist your companions in building it.",
        "Select your army and click the ARMY icon to send them on their first expedition.",
        () => { return (selectedArmy && armies.get(selectedArmy).task == 1) ? true : false; },
        "As your units explore the region, they will gain experience while gathering necessary materials.",
        "You can also manually assign them to gather resources from a tile by moving them there.",
        "Move a unit just by clicking it and then clicking on a destination.",
        "If the destination is a resource, the unit will start gathering from the tile.",
        () => { return (selectedArmy && armies.get(selectedArmy).task == 2) ? true : false; },
        [
          "As you gather resources, they will automatically be used to build and repair structures.",
          "Now that you've understood the basics, gather 100 wood and complete your manor.",
          () => { return (buildings.get(padXYZ(manorX, manorY, 0)).condition == 100) ? true : false; },
          "Superb!",
          "",
          ""
        ]
      ]
    ]
  ];

  let keybinds = {
    esc : "Close/Reset",
    w : "Camera North",
    s : "Camera South",
    a : "Camera West",
    d : "Camera East",
    m : "Map",
    i : "Inventory / Assets",
    u : "Units",

  }

  // each menu is a stack of global menu IDs //
  // 0 is hide menu //
  // 1 is default menu behavior //
  let menus = [
      // top left
      [0],
      // top right
      [1],
      // bottom left
      [0],
      // bottom right
      [0]
  ]

  let tileIndex = false; // render tile layer index for testing
  let infoMenu = false;
  let buyLand = false;
  let paintLand = false;
  let mainMenu = true;
  let showMap = false;
  let interactionMode = false;
  let testString = "string";

	let mapWidth = 999;
	let mapHeight = 999;
  let cameraX = 50 - 30;
  let cameraY = 50 - 17;
  let cursorX = 0;
  let cursorY = 0;
  let cursorMapX = 0;
  let cursorMapY = 0;
  let cursorMoved = 0;
  let manorX = 50;
  let manorY = 50;
  let playerIncome = 0;
  let playerIncomeS = 0;
 // let GDP = 100000; // denominated in copper pieces, G:Cx10000
  let manorBank = [1000,0,0,0,0]; // $C, Food, Wood, Stone, Ore
  let selectedTile = 0;
  let selectedTileX = 0;
  let selectedTileY = 0;
  let selectedUnit = null;
  let selectedArmy = null;
  let selectedBuilding = null;
  let keyMap = {};
  let clickStart = 0;
  let clickEnd = 0;
  let clickLock = false;
  let tileAdded = false;
  let buildLand = 0;
  let uploading = false;
  let showUI = true;
  let showTech = false;

  let mapBuffer = [
    new Map(),
    new Map(),
    new Map()
  ]
  let bufferCompleted = false;
  //let refreshBuffer = true;
  //let refreshCanvas = true;
  let tileMap = new Map();
	let map = [];
	let tiles = [];
  let tileOwned = [];
  let tileLevel = [];
  let menuPage = 0;
  let nextPage = false;
  let pages = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  let planInfo = 0;

  let tileLogic = [];
  
  let techs = [
    [new Tech("Agriculture", [0, 0], [], true)],
    [new Tech("Pottery", [1, 0], []), new Tech("Animal Husbandry", [1, 1], []), 
      new Tech("Archery", [1, 2], []), new Tech("Mining", [1, 3], [])], 
    [new Tech("Sailing", [2, 0], [[1, 0]]), new Tech("Calendar", [2, 1], [[1, 0]]), new Tech("Writing", [2, 2], [[1, 0]]), 
      new Tech("Trapping", [2, 3], [[1, 1]]), new Tech("The Wheel", [2, 4], [[1, 1], [1, 2]]), 
      new Tech("Masonry", [2, 5], [[1, 3]]), new Tech("Bronze Working", [2, 6], [[1, 3]])],
    [new Tech("Optics", [3, 0], [[2, 0]]), new Tech("Horseback Riding", [3, 1], [[2, 3], [2, 4]]), 
      new Tech("Mathematics", [3, 2], [[2, 4]]), new Tech("Construction", [3, 3], [[2, 4], [2, 5]])],
    [new Tech("Philosophy", [4, 0], [[2, 1], [2, 2]]), new Tech("Drama", [4, 1], [[2, 2]]), new Tech("Currency", [4, 2], [[3, 2]]),
      new Tech("Engineering", [4, 3], [[3, 2], [3, 3]]), new Tech("Iron Working", [4, 4], [[2, 6]])]
  ]; // [tier][id]

  let menuText = [
    [],
    ["Btn", "Keybinds", "Draw Tile Index", "Schematics", "Blueprints", "Technology", "New Map", "Save Map"],
    ["Btn", "Build", "Buy Land", "Level Up (10X:1)", "", ""],
    ["Btn", "Citizens", "Lineage", "Spawn Unit", "Interaction Mode"],
    ["Btn", "Goals"],
    ["Btn", "Wood Pick", "Wood Axe", "Wood Sword", "Wood Spear", "Wood Shield", 
      "Stone Pick", "Stone Axe", "Stone Sword", "Stone Spear", "Stone Shield"],
    ["Btn", "House", "Lumbermill", "Mine", "Castle"],
    ["Btn"],
    tileNames,
    ["Btn", "Deploy", "Stats", "Skills", "Events", "Work", "Family"],
    [""], //10
    ["", "Gathering", "Lumbering", "Mining", "Hunting", "Cooking"],
    [""],
    ["", "esc : Close/ClearUI", "w : Camera North", "s : Camera South", "a : Camera West", "d : Camera East",
      "m : Map", "i : Inventory / Assets", "u : Units", "", ""],
    ["", "Establish Manor", "Complete First Building",
        "Reach Population 10", "Reach Population 20", "Reach Population 50",
        "Reach Population 100", "Reach Population 250", "Reach Population 500",
        "Reach Population 1000", "Reach Population 2500", "Reach Population 5000",
        "Reach Population 10000", "Reach Population 25000"],
    ["", "Materials", "Perishables", "Equipment", "Livestock"  ],
    ["", "Contract"],
    ["", "Family Tree", "Timeline/History", "Lineage"]];
  let menuLogic = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]];
  menuLogic[0][0] = () => {};

  menuLogic[1][0] = () => {
    menus[0] = (menus[0] == 0) ? 1 : 0; }; // info menu main button function
  menuLogic[1][1] = () => { 
    menus[0] = (menus[0] == 0) ? 13 : 0; };
  menuLogic[1][2] = () => {
    tileIndex = !tileIndex; };
  menuLogic[1][3] = () => {
    menus[0] = (menus[0] == 0) ? 5 : 0; };
  menuLogic[1][4] = () => {
    menus[0] = (menus[0] == 0) ? 6 : 0; };
  menuLogic[1][5] = () => {
    showUI = false;
    showTech = true; };
  menuLogic[1][6] = () => { generateMap(); };
  menuLogic[1][7] = () => { cacheMap(); };

  menuLogic[2][0] = () => {
    menus[0] = (menus[0] == 0) ? 2 : 0; }; // home menu main button function
  menuLogic[2][1] = () => {
    menus[0] = (menus[0] == 0) ? 8 : 0; };
  menuLogic[2][2] = () => {
    buyLand = !buyLand; };
  menuLogic[2][3] = () => {
    if (manorBank[0] >= 100 * tileLevel[selectedTileX][selectedTileY]) {
      manorBank[0] -= 100 * tileLevel[selectedTileX][selectedTileY];
      tileLevel[selectedTileX][selectedTileY]++; }};
  menuLogic[2].push(() => {});
  menuLogic[2].push(() => {});

  menuLogic[3][0] = () => {
    menus[0] = (menus[0] == 0) ? 3 : 0; }; // army menu main button function
  menuLogic[3][1] = () => {
    menus[0] = (menus[0] == 0) ? 7 : 0; };
  menuLogic[3][2] = () => { drawError("Lineage Not Implemented"); };
  menuLogic[3][3] = () => {
    let x = rnd(fieldX) + cameraX;
    let y = rnd(fieldY) + cameraY;
    createArmy(x, y, [createUnit(new GPS(0, 0, 0), true)]); };
  menuLogic[3][4] = () => {
    interactionMode = true;
    menus[0] = 0; };
    
  menuLogic[4][0] = () => { // lovely button function
    menus[0] = (menus[0] == 0) ? 4 : 0;
    manorBank[0] += 100;
    clearUI();
    showMissionText = true; };
  menuLogic[4][1] = () => {
    menus[0] = (menus[0] == 0) ? 14 : 0; };

  menuLogic[5][0] = () => { menuPage++; }; // schematics menu
  assignLogic(5, false, menuText[5].length);

  menuLogic[6][0] = () => {}; // blueprints menu
  assignLogic(6, false, menuText[6].length);

  menuLogic[7][0] = () => { nextPage = true; }; // citizen list

  menuLogic[8][0] = () => { menuPage++; }; // build list
  menuLogic[8][1] = () => { buildLand = 1; };
  menuLogic[8][2] = () => { buildLand = 2; };
  menuLogic[8][3] = () => { buildLand = 3; };
  menuLogic[8][4] = () => { buildLand = 4; };
  menuLogic[8][5] = () => { buildLand = 5; };
  menuLogic[8][6] = () => { buildLand = 6; };
  menuLogic[8][7] = () => { buildLand = 7; };
  menuLogic[8][8] = () => { buildLand = 8; };
  menuLogic[8][9] = () => { buildLand = 9; };
  menuLogic[8][10] = () => { buildLand = 10; };
  menuLogic[8][11] = () => { buildLand = 11; };
  menuLogic[8][12] = () => { buildLand = 12; };
  menuLogic[8][13] = () => { buildLand = 13; };
  menuLogic[8][14] = () => { buildLand = 14; };
  menuLogic[8][15] = () => { buildLand = 15; };

  menuLogic[9][0] = () => {}; // unit screen
  menuLogic[9][1] = () => { assignUnit(); }; // Assign unit to location
  menuLogic[9][2] = () => { menus[0] = 10; clickEnd = 0; }; // Show Stat Menu
  menuLogic[9][3] = () => { menus[0] = 11; clickEnd = 0; }; // Show Skill Menu
  menuLogic[9][4] = () => { menus[0] = 12; clickEnd = 0; }; // Show Event Menu
  menuLogic[9][5] = () => { menus[0] = 16; clickEnd = 0; }; // Show Work Menu
  menuLogic[9][6] = () => { menus[0] = 17; clickEnd = 0; }; // Show Family Menu

  menuLogic[10][0] = () => { }; // Unit Stat Menu
  menuLogic[10][1] = () => { };
  menuLogic[10][2] = () => { };
  menuLogic[10][3] = () => { };
  menuLogic[10][4] = () => { };
  menuLogic[10][5] = () => { };
  menuLogic[10][6] = () => { };
  menuLogic[10][7] = () => { };
  menuLogic[10][8] = () => { };
  menuLogic[10][9] = () => { };
  menuLogic[10][10] = () => { };

  menuLogic[11][0] = () => {  }; // Unit Skill Menu
  assignLogic(11, false, menuText[11].length);

  menuLogic[12][0] = () => { nextPage = true; }; // Unit Event Menu

  menuLogic[13][0] = () => { nextPage = true; }; // Keybinds Menu
  menuLogic[13][1] = () => {  };
  menuLogic[13][2] = () => {  };
  menuLogic[13][3] = () => {  };
  menuLogic[13][4] = () => {  };
  menuLogic[13][5] = () => {  };
  menuLogic[13][6] = () => {  };
  menuLogic[13][7] = () => {  };
  menuLogic[13][8] = () => {  };
  menuLogic[13][9] = () => {  };
  menuLogic[13][10] = () => {  };

  menuLogic[14][0] = () => { nextPage = true; }; // Goals Menu
  assignLogic(14, false, menuText[14].length);

  menuLogic[15][0] = () => { }; // Store Catalogue
  assignLogic(15, false, menuText[15].length);

  menuLogic[16][0] = () => { }; // Unit Work Menu
  assignLogic(16, false, menuText[16].length);

  menuLogic[17][0] = () => { }; // Unit Family / Lineage Menu
  assignLogic(17, false, menuText[17].length);

  let units = [];
  // TEMP // push hidden unit to SSN 0 for logical simplicity
  units.push(new Unit(units.length, new GPS(0, 0, 0), rndArray(), 0, "Satoshi Nakamoto"));
  // !!! // IMPORTANT NOTE // TEMPORARY FIX // !!! //
  // army keys are handled by converting to and from STRING manually //
  // this was implemented to solve anonymous map access issues //
  // ideal solution is to be able to access map values with anonymous keys //
  // I.E. comparing objects by likeness, instead of memory value (cached) //
  // NOT IDEAL, IMO //
  let armies = new Map();
  {
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createUnit(new GPS(0, 0, 0));
    createArmy(50, 50, [units[1], units[2], units[3], units[4]]);
  }

  let regions = new Map();
  let buildings = new Map();
	let ID = [];
  let movement = [[0, 1, 0, -1, 0], [0, 0, 1, 0, -1]];
  let movementFull = [[0, 1, 1, 0, -1, -1, -1, 0, 1], [0, 0, 1, 1, 1, 0, -1, -1, -1]];

  const div = document.getElementById('my-money-button');

  /*
  var query = {
    v: 3,
    q: { find: {}, limit: 5 }
  };
  var b64 = btoa(JSON.stringify(query));
  var url = "https://genesis.bitdb.network/q/1FnauZ9aUH2Bex6JzdcV4eNX7oLSSEbxtN/" + b64;

  var header = {
    headers: { key: "1CRKrBCUJDFyU3LsBAQRzwBkBPrjmDQasV" }
  };

  fetch(url, header).then(function(r) {
    return r.json()
  }).then(function(r) {
    var result = JSON.stringify(r, null, 2);
    document.querySelector("pre").innerHTML = result;
  })

  /*moneyButton.render(div, { // 
    to: "12cRRk9wn2LofWKE2wwxb7mw5qNeMaW7zH",
    amount: ".1",
    currency: "USD",
    label: "Hi",
    clientIdentifier: "RPG",
    buttonId: "IndieRPGProject",
    buttonData: "{}",
    type: "tip",
    onPayment: function (arg) { console.log('onPayment', arg) },
    onError: function (arg) { console.log('onError', arg) }
  })

  function upload(data)
  {
    /*moneyButton.render(div, {
      outputs: [{
        type: 'SCRIPT',
        script: data,
        amount: '.002',
        currency: 'USD'
      }]
    })
  }

  function uploadData(data)
  {
    //upload(bsv.Script.buildDataOut(arrMny).toASM());
  }*/
  
  function getAuth() {
    window.location.href = mbUrls.Auth }

  function checkAuth() {
    if (window.location.href != fUrl) {
      authCode = window.location.href.split("=")[1].split("&")[0];
      history.pushState(null, null, '/');
      getToken(authCode);
      console.log(authCode);
    }
  }

  function getToken(code) {
    var body = new URLSearchParams();
    body.append('grant_type', 'authorization_code');
    body.append('client_id', oApp);
    body.append('code', code);
    body.append('redirect_uri', fUrl);
    
    Workers.get('NetWorker').postMessage(['MB', body.toString()]);
  }

  function _for(val, logic, start = 0) {
      for (let i = start; i < val.length; i++) {
          logic(); }}

  // UNTESTED // Padding functions may malfunction if NUM has >1 significant digits
  // ALSO // Current default length of 3 relies on a map with max size of 999
  function padVal(val, length = 3, num = 0) {
    return val.toString().padStart(length, num) }

  function valPad(val, length = 3, num = 0) {
    return val.toString().padEnd(length, num) }

  // padXYZ() converts x, y, z into a single string for standardized use as an index //
  function padXYZ(x, y, z, length = 3, num = 0) {
    return (padVal(x, length, num) + padVal(y, length, num) + padVal(z, length, num)); }

  // sliceXYZ() reverts standardized index strings into a new GPS(x, y, z)
  function sliceXYZ(str) {
    return (new GPS(Number(str.slice(0, 3)), Number(str.slice(3, 6)), Number(str.slice(6, 9)))); }

  function getCoord(x, y, xx, yy) { // 000-00-000-00 // xx-x-yy-y
    return ((padVal(x) + padVal(xx, 2)) + (padVal(y) + padVal(yy, 2))); }

  function sliceCoord(str) { // x, y, xx, yy
    return ([Number(str.slice(0,3)), Number(str.slice(5,8)), Number(str.slice(3,5)), Number(str.slice(8,10))]) }

  function bea(a, b) { // b equals a //
    b = a; }

  function set(val, x, y, array) {
    array[x][y] = val; }

  function getSign(num) {
    return ((num == 0) ? 0 : (Math.abs(num) / num)); }
    
  function modulo(num, max) {
    return (num % max) }

	function rnd(max, min = 0) {
		return min + Math.floor(Math.random() * (max - min)); }

	function rndCeil(max, min = 0) {
		return min + Math.ceil(Math.random() * (max - min)); }

  // Generates random array of given length for provided max & min
  function rndArray(length = 10, max = 4, min = 0, arr = []) {
    for (i = 0; i < length; i++) { 
      arr[i] = rnd(max, min); }
    return (arr); }

  // loop() returns num after looping it until within range // 
  function loop(num, min, max, stop = false) {
    range = max - min;
    if (num > max) {
      num -= range + 1; }
    else if (num < min) {
      num += range + 1; }
    if (!stop && (num > max || num < min)) {
      loop(num, min, max); }
    return num; }

  // JAVASCRIPT STRUGGLE-BUS //
  // I've tried and tried and tried, but can't figure out how this breaks //
  // When running the function traceProperty for BuyLand movement breaks //
  // I've currently removed range checking from movement pending tests //
  // This may require reverting this function to a true/false //
  // I liked adjusting value to edges of boundaries, but I give up on this //
  // This is one more beyond baffling and frustrating struggle with JavaScript //
  function range(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  function range2(num, min = 0, max = 999) {
    return ((num > max) ? max : ((num < min) ? min : num)); }

  function min(num, min) { return (num < min) ? min : num; }

  function max(num, max) { return (num > max) ? max : num; }

  // inRange() returns true if num is within min && max //
  // Solves issues of range() failing to return/set the correct value //
  function inRange(num, min = 0, max = 999) {
    return ((num <= max && num >= min) ? true : false ) }

  // contains() returns true if within rectangle bounds (x, y, width, height) //
  function contains(x, y, width, height, checkX, checkY) {
      return ((x <= checkX && checkX <= x + width && y <= checkY && checkY <= y + height) ? true : false); }

  // get the side length of a right isosceles triangle from hypotenuse
  function getSides(hypotenuse) { return Math.round(hypotenuse / Math.sqrt(2)); }

  function checkAdjacent(val, x, y, array = map) { // returns seed percentage
    let seed = 0;
    for (let i = 1; i <= 4; i++) {
      if (array[range(x + movement[0][i], 0, 999)][range(y + movement[1][i], 0, 999)] == val) {
        seed += .25; }}
    return seed; }

  // input text string with max width in chars(num)
  // returns array of lines broken after " " within width
  function wrapText(text, width, index = 0, array = []) {
    let i = 0;
    if (text.length < width) {
      array[index] = text;
      return array; }
    for (ii = 0; ii < width; ii++) {
      if (text[ii] == " ") { i = ii + 1; }}
    if (!i) { i = width; }
    array[index] = text.slice(0, i);
    return wrapText(text.slice(i, text.length), width, index + 1, array);
  }

  // extract element from embedded array with digit index
  function extractText(num, array = scenarioIndex, i = 0) {
    let index = (''+num)[i];
    let extraction = array[index];
    if (i < (''+num).length - 1) { 
      i++;
      extraction = extractText(num, extraction, i); }
    return extraction;
  }

  // expects function at next event, returns false unless function returns true
  function checkEvent(index, array) {
    element = extractText(index + 1, array);
    return (typeof element == "function") ? element() : false; }

  // try to progress scenario by returning next event string 
  // if next element is function, must evaluate true to progress
  // ~ if function returns NUMBER, run @ index = nextEvent(NUM)
  // if next element is array, return string at array[0]
  function nextEvent(index, array) {
    element = extractText(index + 1, array);
    if (typeof element == "string") { return index + 1; }
    if (typeof element == "function") { 
      let elem = element();
      if (elem == false) { showMissionText = false; return index; }
      else if (typeof elem == "number") { return nextEvent(elem, array); }
      else { return nextEvent(index + 1, array); }}
    if (Array.isArray(element)) {
      return nextEvent((index + 1) * 10 - 1, array); }
  }

  // Take a unit and return event history for scenario index //
  function rebuildScenario(unit, index, array) {

  }

  // Takes a technology ID [x, y] from the technology array
  // Returns true if required technology IDs are researched
  function techAvailable(tech) {
    for (let i = 0; i < tech.requiredTechs.length; i++) {
      if (!techs[tech.requiredTechs[i][0]][tech.requiredTechs[i][1]].researched) {
        return false; }}
    return true; }

  // Creates a generic unit at home GPS and pushes to unit array
  function createUnit(home = new GPS(0, 0, 0), r = false) {
    let unit = new Unit(units.length, home, rndArray());
    units.push(unit);
    if (r) return unit; }

  // Generates unit forename and surname based on unit sex
  function genName(sex = rnd(2), sur = surNames[rnd(surNames.length)]) {
    return [(sex) ? mNames[rnd(mNames.length)]
      : fNames[rnd(fNames.length)], sur]; }
      
  function assignLogic(id, logics, length, start = 1) {
    for (let i = start; i < length; i++) {
      let l = (logics) ? logics[i - start] : ()=>{ drawError();};
      menuLogic[id][i] = l; }}

  // Attempts to assign provided unit at a given tile
  // Tries signing work contract if tile is building, then signs to army
  function assignUnit(tile = new GPS(selectedTileX, selectedTileY, 0),
      unit = units[selectedUnit]) {
    let key = padXYZ(tile.x, tile.y, 0);
    let building = buildings.get(key);
    if (building && building.units.size < 4 && !unit.work) {
      unit.work = key;
      unit.events.push("I'm employed at the " + tileNames[tiles[tile.x][tile.y]] + "!")
      notifications.push(new Notification("" + unit.name[0] + " " + unit.name[1] + " Employed at " + tileNames[tiles[tile.x][tile.y]]))
      building.units.set(selectedUnit, new Contract(key, unit.ssn, Date.now() + 30000, 
        [1, tileResourceIndex[building.id][0]]));
      building.calcProduction(0); }
    else if (!building && !unit.work) {
      (armies.get(key)) ? armies.get(key).units.set(unit.ssn, unit)
        : createArmy(tile.x, tile.y, [unit], true);
      armies.get(key).calcProduction(0);
      unit.work = true; }
  }

  // Create a new army at location x & y with provided units
  function createArmy(x, y, units = 0, r = false) {
    let army = new Army(0, 0, "blue");
    let key = padXYZ(x, y, 0);
    if (units != 0) {
      for (let i = 0; i < units.length; i++) {
        army.units.set(units[i].ssn, units[i]); }
    armies.set(key, army); }
    if (r) { return army; }}

  // Randomly dives into event tree until collision with event branch
  // Event branches have a string at array[0]
  // Returns index (NUMBER) of the first event in the branch
  function genScenario(array = scenarioIndex, index = "") {
    let seed = rnd(array.length - 1, 1);
    index = index.concat((typeof array[0] == "string") ? 0 : seed);
    if (typeof array[index[index.length - 1]] != "string") {
      index = genScenario(array[seed], index); }
    return Number(index);
    }
/*
  function setResources(region) {
    let res = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let workBonus;
    for (let i = 0; i < region.domain.length; i++) {
      gps = region.domain[i];
      key = padXYZ(gps.x, gps.y, gps.z);
      workBonus = (armies.has(key)) ? armies.get(key).level : 1;
      if (tiles[gps.x][gps.y] > 4) {
        res[3] += workBonus;
        res[2] += workBonus;
      }
      else {
        res[1] += workBonus;
      }
    }
    region.resources = res;
  } */

  function traceProperty(x, y) {
    do {
      y = y + movement[1][4];
    } while (tileOwned[x][y]);

    let xi = x;
    let yi = y;
    let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
    drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");
    xi = xi + movement[0][direction];
    yi = yi + movement[1][direction];

    do {
      drawText("+1", (xi - cameraX) * 32 + 4, (yi - cameraY + 1) * 32 - 8, "24px Arial", "gold");

      direction = loop(direction + 1, 1, 4);
      if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
        do {
          direction = loop(direction - 1, 1, 4);
        } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }
      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];
      
      if (xi == x && yi == y) { return; }
    } while (buyLand);
  }

  function cacheData(type, data) {
    Cache.setItem(type, JSON.stringify(data)); }

  function getCache(type) {
    return JSON.parse(Cache.getItem(type)); }

  function cacheMap() {
    cacheData('map', map);
    cacheData('tiles', tiles);
    cacheData('owned', tileOwned);
    cacheData('units', units);
    cacheData('properties', getProperties())
    cacheData('sk', units.map(u => u.scenarios.keys()));
    cacheData('sv', units.map(u => u.scenarios.values()));
    cacheData('bk', [ ...buildings.keys() ]);
    cacheData('bv', [ ...buildings.values() ]);
    cacheData('buk', [ ...buildings.values() ].map(b => b.units.keys()));
    cacheData('buv', [ ...buildings.values() ].map(b => b.getContracts()));
    cacheData('ak', [ ...armies.keys() ]);
    cacheData('av', [ ...armies.values() ]);
    cacheData('auk', [ ...armies.values() ].map(a => a.units.keys()));
    cacheData('auv', [ ...armies.values() ].map(a => a.units.values()));
    //console.log([ ...properties.values ]);
    //cacheData('properties', Array.from(properties.values()));
  }

  function setMap() {
    map = (Cache.hasOwnProperty('map')) ? getCache('map') : () => { generateMap(); return false; };
    tiles = (Cache.hasOwnProperty('tiles')) ? getCache('tiles') : () => { generateMap(); return false; };
    tileOwned = (Cache.hasOwnProperty('owned')) ? getCache('owned') : () => { generateMap(); return false; };
    buildings.clear();
    armies.clear()
    units = []
    setProperties(getCache('properties'));
    let u = getCache('units');
    let scenarioKeys = getCache('sk');
    let scenarioValues = getCache('sv');
    let buildingKeys = getCache('bk');
    let buildingValues = getCache('bv');
    let contractKeys = getCache('buk');
    let contractValues = getCache('buv');
    let armyKeys = getCache('ak');
    let armyValues = getCache('av');
    let soldierKeys = getCache('auk');
    let soldierValues = getCache('auv');
    for (let i = 0; i < u.length; i++) { 
        units.push(new Unit( u[i].ssn, u[i].home, u[i].stats, u[i].sex, u[i].name,
            u[i].work, u[i].skills, u[i].equipment, u[i].events, new Map() )); 
        units[u[i].ssn].assignScenarios(scenarioKeys[i], scenarioValues[i]); }
    for (let i = 0; i < buildingKeys.length; i++) { 
        let bi = buildingValues[i];
        let b = new Building(bi.id, new Map(), bi.production, bi.condition);
        b.assignUnits(contractKeys[i], contractValues[i]);
        b.calcProduction(0);
        buildings.set(buildingKeys[i], b); }
    for (let i = 0; i < armyKeys.length; i++) { 
        let ai = armyValues[i];
        let a = new Army(ai.tileX, ai.tileY, ai.color, new Map(),
            ai.level, ai.production, ai.health, ai.attack,
            ai.defense, ai.speed, ai.task, ai.action,
            ai.direction, ai.moveX, ai.moveY);
        a.assignUnits(soldierKeys[i], soldierValues[i]);
        armies.set(armyKeys[i], a); }
    initiateMap(false);
  }

  function initiateMap(all = true) {
    for (let x = 0; x <= mapWidth; x++) {
      if (all) {
        map[x] = [];
        tiles[x] = [];
        tileOwned[x] = [];
      }
      tileLevel[x] = []; }
  }

  function blankMap() {
		for (let y = 0; y <= mapHeight; y++) {
			for (let x = 0; x <= mapWidth; x++) {
				map[x][y] = 0;
				tiles[x][y] = 0; }}
  }

    function generateMap() {
    initiateMap();
    blankMap();
    generateSnow();
    expandSnow();
    generateDesert();
    expandDesert();
    generateWater();
    expandWater();
    generateForests();
    expandForests();
    generateMountains();
    expandMountains();
    cacheMap(); }

  function layer(val, x, y, min, max, array = map, func = ((x, y) => {})) {
    for (let i = min; i <= max; i++) {
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 8; ii++) {
        for (let iii = 0; iii < i; iii++) {
          x += movementFull[0][ii];
          y += movementFull[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
          func(x, y); }}}}

 function layerSq(val, x, y, min, max, array = map, addDomain = false) {
    for (let i = min; i <= max; i++) {
      let gps;
      let domainKey = padXYZ(manorX, manorY, 0);
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      x--;
      y--;
      array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val;
      for (let ii = 1; ii <= 4; ii++) {
        for (let iii = 0; iii < i * 2; iii++) {
          x += movement[0][ii];
          y += movement[1][ii];
          array[range(x, 0, mapWidth)][range(y, 0, mapHeight)] = val; 
          if (addDomain) {
            gps = new GPS(x, y, 0);
            regions.get(domainKey).domain.push(gps);
          }}}}}

  function pool(val, x, y, array) {
    let i = 0;
    let slope = 0;
    do {
      layer(val, x, y, i, i + 1, array);
      slope = rnd(9);
      i++; } while (slope == 0);
    return (slope); }

	function generateSnow() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 100; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 1;
      layer(1, x, y, 1, size, map); }}

	function generateDesert() {
    let size;
    let x;
    let y;
    for (let i = 0; i < 150; i++) {
      size = rnd(6) + 3;
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      map[x][y] = 2;
      layer(2, x, y, 1, size, map); }}

	function generateWater() {
    let slope;
    let current;
    let flow;
    let x;
    let y;
    for (let i = 0; i < 800; i++) {
      slope = rnd(9); // 0 causes a pool, forces new flow, !chance of new river
      flow = 3 * (rndCeil(30));
      x = rnd(mapWidth + 1);
      y = rnd(mapHeight + 1);
      tiles[x][y] = 2;
      
      if (slope == 0) {
        slope = pool(2, x, y, tiles); }

      do {
        x = range((x + movementFull[0][slope]), 0, 999);
        y = range((y + movementFull[1][slope]), 0, 999);
        tiles[x][y] = 2;
        if (rnd(5) < 1) {
          slope = rnd(9);
          if (slope == 0) {
            slope = pool(2, x, y, tiles); }}

        flow--; } while (flow > 0); }}

	function generateForests() {
     let x;
     let y;
     for (let i = 0; i < 200000; i++) {
       x = rnd(999);
       y = rnd(999)
       if (tiles[x][y] == 0 && map[x][y] != 2) {
         tiles[x][y] = 3; }}}

	function generateMountains() {
    let x;
    let y;
    for (let i = 0; i < 100000; i++) {
      x = rnd(999);
      y = rnd(999)
      if (tiles[x][y] == 0) {
        tiles[x][y] = 4; }
      if (map[x][y] == 1 && rnd(7) >= 5) {
        layer(4, x, y, 1, 1, tiles); }}}

  function generateRegion(key) {
    let gps = sliceXYZ(key);
    manorX = gps.x;
    manorY = gps.y;
    //tileMap.set(key, new Land());
    // regions.get(key).domain.push(gps);
    layerSq(true, manorX, manorY, 1, 3, tileOwned); }

  function expansion(val, def, gen, array = map) {
    for (let i = 0; i < def; i++) {
      for (let y = 0; y <= mapHeight; y++) {
        for (let x = 0; x <= mapWidth; x++) {
          if (array[x][y] != val) {
            let seed = checkAdjacent(val, x, y, array);
            if (rnd(100 * seed) > gen) {
              array[x][y] = val; }}}}}}

  function expandSnow() {
    expansion(1, 5, 15);
    expansion(1, 5, 30);
    expansion(1, 1, 75); }

  function expandDesert() {
    expansion(2, 5, 15);
    expansion(2, 5, 30);
    expansion(2, 2, 75); }

  function expandWater() {
    expansion(2, 2, 20, tiles);
    expansion(2, 2, 40, tiles);
    expansion(2, 2, 80, tiles); }

  function expandForests() {
    expansion(3, 1, 35, tiles);
    expansion(3, 1, 60, tiles);
    expansion(3, 1, 85, tiles); }

  function expandMountains() {
    expansion(4, 1, 25, tiles);
    expansion(4, 1, 50, tiles);
    expansion(4, 1, 80, tiles); }

  onkeydown = onkeyup = function(e) {
    e = e || event; // IE Compatibility
    keyMap[e.keyCode] = e.type == 'keydown'; }

    // WARNING UNFINISHED // Does not check for occupied army before changing tiles
  function moveTowards(army, location) {
    let step = timeScale * ((army.moveX * army.moveY == 0) ? 3 : 2);
    let moveX = (army.moveX != 0) ? (army.moveX / (Math.abs(army.moveX))) : -(army.tileX / (Math.abs(army.tileX)));
    let moveY = (army.moveY != 0) ? (army.moveY / (Math.abs(army.moveY))) : -(army.tileY / (Math.abs(army.tileY)));
    let distance = [ Math.abs(tileScale * army.moveX - army.tileX), Math.abs(tileScale * army.moveY - army.tileY) ]
    let stepX = (distance[0] < step) ? moveX * distance[0] : moveX * step;
    let stepY = (distance[1] < step) ? moveY * distance[1] : moveY * step;
    if ((army.moveX != 0 || army.tileX != 0) && !armies.has(padXYZ(location.x + moveX, location.y, location.z))) {
      army.tileX += stepX;
      if (!inRange(army.tileX, -15, 16)) {
        while (!inRange(army.tileX, -15, 16)) {
            army.tileX = loop(army.tileX, -15, 16, true);
            army.moveX -= moveX;
            armies.delete(padXYZ(location.x, location.y, location.z));
            location.x += moveX;
            armies.set(padXYZ(location.x, location.y, location.z), army);
        }
      }
    }
    if ((army.moveY != 0 || army.tileY != 0) && !armies.has(padXYZ(location.x, location.y + moveY, location.z))) {
      army.tileY += stepY;
      if (!inRange(army.tileY, -15, 16)) {
        while (!inRange(army.tileY, -15, 16)) {
            army.tileY = loop(army.tileY, -15, 16, true);
            army.moveY -= moveY;
            armies.delete(padXYZ(location.x, location.y, location.z));
            location.y += moveY;
            armies.set(padXYZ(location.x, location.y, location.z), army);
        }
      }
    }
  }
  
  function patrol(key, x = manorX, y = manorY, range = 25, hop = 5) {
    let army = armies.get(key);
    let location = sliceXYZ(key);
    let destination = new GPS(
      range2(location.x + (rnd(hop * 2) - hop), x - range, x + range),
      range2(location.y + (rnd(hop * 2) - hop), y - range, y + range), 0);
    army.moveX = destination.x - location.x;
    army.moveY = destination.y - location.y;
    army.action = new Contract(destination.toString(), key, 0, [army.units.size, tiles[destination.x][destination.y]]);
  }

  function gather(army) {
    payContract2(army.action)
  }

  function logic() {
    if (clickStart) {
      cursorMoved = [ cursorX - clickStart[0][0], cursorY - clickStart[0][1]]; }
    if (cursorMoved) {
      cameraX = range2(cameraX + Math.round(cursorMoved[0] / 64), 0, mapWidth - fieldX - 1);
      cameraY = range2(cameraY + Math.round(cursorMoved[1] / 64), 0, mapHeight - fieldY - 1); }

    if (nextPage) { menuPage++; nextPage = false; }
    if (keyMap[68] && inRange(cameraX + 1, 0, mapWidth - fieldX - 1)) { // d
      cameraX++; }
    if (keyMap[83] && inRange(cameraY + 1, 0, mapHeight - fieldY - 1)) { // s
      cameraY++; }
    if (keyMap[65] && inRange(cameraX - 1)) { // a
      cameraX--; }
    if (keyMap[87] && inRange(cameraY - 1)) { // w
      cameraY--; }
      
    if (keyMap[27]) { clearUI(); }
    if (keyMap[77]) { 
      if (!tileChunks) { startBuffer(); }
      showMap = !showMap;
      keyMap[77] = 0;
    }

    if (!showMissionText && checkEvent(missionProgress, missionIndex)) {
      missionProgress = nextEvent(missionProgress, missionIndex);
      showMissionText = true; }

    if (buildLand != 0)
    {
      let x = cameraX + cursorMapX;
      let y = cameraY + cursorMapY;
      if (buildLand == 1 && clickEnd != 0) {
        tiles[x][y] = 0; }
      else {
        if (clickEnd != 0 && manorBank[0] >= 250 /*&& tileOwned[x][y]*/
          && tiles[x][y] == 0) {
          tiles[x][y] = buildLand;
          if (buildLand >= 5) {
            key = padXYZ(x, y, 0);
            tileLevel[x][y] = 1;
            building = new Building(buildings.size);
            if (buildings.size == 0) { 
              regions.set(key, new Region(1));
              generateRegion(key);
              for (i = 1; i <= 4; i++) {
                units[i].home = sliceXYZ(key);
                building.units.set(i, new Contract(i, key, Date.now() + 30000)); }}
            buildings.set(key, building);
            manorBank[0] -= 250;
    }}}}
  }

  function logic1000() {
    testString = genScenario();
    //let key = padXYZ(manorX, manorY, 0);
    //let region = regions.get(key);
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++){
      let location = sliceXYZ(key[i]);
      let arm = army[i];
      let contract = army[i].action;
      if (army[i].moveX != 0 || army[i].moveY != 0
          || army[i].tileX != 0 || army[i].tileY != 0) {
        moveTowards(army[i], location); }
      else if (army[i].task == 1) {
        if (!army[i].action) {
          patrol(key[i]);
        }
        else if (army[i].action.period == 0) {
          if (!army[i].action.expiration) {
            army[i].action.expiration = Date.now() + 30000; }
          if (Date.now() - army[i].action.expiration >= 0) { army[i].action = 0; }
          else { army[i].action.period = Date.now() + 1000; }
        }
        else if (Date.now() - army[i].action.period >= 0) {
          gather(army[i]);
          army[i].action.period = 0;
        }
      }
      else if (arm.task == 2) {
        if (!contract.period) {
          if (tiles[location.x][location.y] == 4) {
            contract.payment.settlement = function() {
              if (rnd(10) == 4) { manorBank[4] += arm.units.size; }}}
          contract.period = Date.now() + 7000;
        }
        else if (Date.now() - contract.period >= 0) {
          gather(arm);
          contract.period = Date.now() + 1000;
        }
      }
    }

    key = [ ...buildings.keys() ];
    let building = [ ...buildings.values() ];

    for (let i = 0; i < building.length; i++) {
      let gps = sliceXYZ(key[i]);
      let contract = [ ...building[i].units.values() ];

      if (building[i].condition < 100 && manorBank[2] > 0) { 
        manorBank[2]--;
        building[i].condition++; } 

      if (contract.length > 0) { settleContracts(gps, building[i], contract); }

      if (tiles[gps.x][gps.y] == 5 && rnd(50) >= 5 && building[i].units.size < 4) {
        let unit = createUnit(gps, true);
        unit.events.push("I now live at " + gps + "!")
        building[i].units.set(unit.ssn, new Contract(unit.ssn, key[i], Date.now() + 30000)); }
        
      building[i].calcProduction(0); }

    /*for (y = 0; y <= mapHeight; y++) {
      for (x = 0; x <= mapWidth; x++) {
        if (tileOwned[x][y]) {
              let tile = tiles[x][y];
              if (Number.isInteger(tile) && tile == 5) {
                playerGold += tileLevel[x][y] * 10; }}
      }
    }*/
    let list = units;
    for (const unit of list) {
      let seed = rnd(100);
      if (seed == 50) {
        unit.events.push(eventIndex[rnd(10)]); }
      else if (seed >= 80) {
        let scenario = genScenario();
        let progress = 0;
        if (scenario > 9 && unit.scenarios.has(scenario)) {
          progress = unit.scenarios.get(scenario) + 1;
          array = extractText(Math.floor(scenario / 10));
          if (progress < array.length) {
            unit.events.push(scenario + progress);
            unit.scenarios.set(scenario, progress);
          }
        }
        else {
          unit.events.push(scenario + progress);
          unit.scenarios.set(scenario, progress);
        }
      }
    }
  }

  function logic5000() {
    // snd.play(); // MetaNet is great and all.. but..
    
  }

  function settleContracts(gps, property, contracts) {
    for(const contract of contracts) {
      if (contract.period < Date.now()) {
        payContract(gps, property, contract);
        contract.period = Date.now() + 30000; }
    }
  }

  function payContract(gps, property, contract) {
    let index = tiles[gps.x][gps.y];
    if (units[contract.promisee]) {
      units[contract.promisee].skills[0][0]++;
      units[contract.promisee].skills[0][0]++; }

    if (index == 5) {
      manorBank[0] += 10 + property.production; }
    else if (index == 6) {
      manorBank[1] += 1 * property.production; }
    else if (index == 7) {
      manorBank[3] += 1 * property.production; }
    else if (index == 8) {
      manorBank[2] += 1 * property.production; }
  }

  function payContract2(contract) {
    manorBank[contract.payment.resource - 1] += contract.payment.amount;
    contract.payment.settlement();
  }

/*
  function setBuffer() {
    let size = 32;
    mapBuffer[0] = [];
    mapBuffer[1] = [];
    mapBuffer[2] = [];
    // draw first layer (land/biome) //
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        land = map[x + cameraX][y + cameraY];
        key = padXYZ(x + cameraX, y + cameraY, 0);
        outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
          "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
        mapBuffer[land].push(
          [x * 32, y * 32, size, size, true, true,
            biomeDraws[land], outlineColor, "1"])
        }}
    refreshBuffer = false;
  }

  function cutBuffer() {
    for (let i = 0; i < mapBuffer.length; i++) {
      keys = mapBuffer[i].keys();
      for (let ii = 0; ii < keys.length; ii++) {
        gps = sliceXYZ(keys[ii]);
        if (!inRange(gps.x, cameraX, cameraX + fieldX)
          || !inRange(gps.y, cameraY, cameraY + fieldY)
          || i != map[x][y]) {
          mapBuffer[i].delete(keys[ii]);
        }
      }
    }
  }

  function drawBuffer() {
    for (let i = 0; i < mapBuffer.length; i++) {
      funcs = mapBuffer[i];
      for (let ii = 0; ii < funcs.length; ii++) {
        params = funcs[ii];
        drawRectangle(params[0], params[1], params[2], params[3],
          params[4], params[5], params[6], params[7], params[8]);
      }
    }
  }
*/

  function buffWorker() {
    let fieldX;
    let fieldY;
    let biomeDraws = ['#055000', 'white', "goldenrod"];
    let drawTile1;
    let canvas;
    let ctx;
    let map;

    function inRange(num, min = 0, max = 999) {
      return ((num <= max && num >= min) ? true : false ) }

    function genCanvas(x = fieldX, y = fieldY) {
      canvas = new OffscreenCanvas(x * 32, y * 32);
      ctx = canvas.getContext("2d");
      drawTile1 = [
        new OffscreenCanvas(1, 1),
        new OffscreenCanvas(1, 1),
        new OffscreenCanvas(1, 1)
      ];
      drawRectangle(0, 0, 1, 1, true, false, biomeDraws[0], "black", "1", drawTile1[0].getContext('2d'));
      drawRectangle(0, 0, 1, 1, true, false, biomeDraws[1], "black", "1", drawTile1[1].getContext('2d'));
      drawRectangle(0, 0, 1, 1, true, false, biomeDraws[2], "black", "1", drawTile1[2].getContext('2d'));
    }

    function drawRectangle(x, y, width, height, fill = true, stroke = true,
        fillColor = "black", strokeColor = "black", strokeWidth = "3", canvas = ctx) {
      canvas.beginPath();
      canvas.rect(x, y, width, height);
      if (fill) { 
        canvas.fillStyle = fillColor; 
        canvas.fill();
      if (stroke) { 
        canvas.strokeStyle = strokeColor;
        canvas.lineWidth = strokeWidth;
        canvas.stroke(); }}}

    function createChunks() {
      tileChunks = [];
      for (let x = 0; x < fieldX; x++) {
        tileChunks[x] = [];
        for (let y = 0; y < fieldY; y++) {
          tileChunks[x][y] = new OffscreenCanvas(32, 32); }}}

    function fillChunks() {
      for (let y = 0; y < fieldY; y++) {
        for (let x = 0; x < fieldX; x++) {
          for (let yy = 0; yy < 32; yy++) {
            for (let xx = 0; xx < 32; xx++) {
              tileChunks[x][y].getContext("2d").drawImage((inRange(xx + (x * 32)) && inRange(yy + (y * 32))) ? 
                drawTile1[map[xx + (x * 32)][yy + (y * 32)]] : drawTile1[0], xx, yy); }}
          canvas.getContext("2d").drawImage(tileChunks[x][y], x * 32, y * 32); }}}

    self.onmessage = function (msg) {
      fieldX = msg.data[0];
      fieldY = msg.data[1];
      map = msg.data[2];
      genCanvas();
      createChunks();
      fillChunks();
      self.postMessage([canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height)]);
    }
  }

  function createWorker(template) {
    if (typeof(Worker) !== "undefined" && !Workers.has(template)) {
      let buffer = URL.createObjectURL(new Blob(['(',
        eval('WorkerTemplates.' + template).toString(),
        ')()' ], { type: 'application/javascript' }))
      Workers.set(template, new Worker(buffer)); 
      return true; }
    else { return false; }}

  function startWorker(template = 'NetWorker') {
    if (createWorker(template)) {
      Workers.get(template).onmessage = function(msg) {
        console.log(msg);
        if (msg.data[0].hasOwnProperty('data')) {
          UserID = msg.data[0].data.attributes.id;
          UserName = msg.data[0].data.attributes.name;
          Users.set(UserID, new User(UserID, UserName, null));
          Workers.get('NetWorker').postMessage(['POST', JSON.stringify({'type': 'USER', 'id': UserID, 'name': UserName})]);
        }}
      console.log(template + " started."); }}

  function startBuffer() {
    if (createWorker('MapWorker')) {
      Workers.get('MapWorker').onmessage = function (e) {
        canvas.offscreenCanvas.getContext("2d").putImageData(e.data[0], 0, 0);
        Workers.delete('MapWorker');
        bufferCompleted = true; }
      Workers.get('MapWorker').postMessage([fieldX, fieldY, map]);
    } 
    else {
      console.log("New Worker Failed!");
      //createChunks();
      //fillChunks();
    }
  }

  function createChunks() {
    tileChunks = [];
    for (let x = 0; x < fieldX; x++) {
      tileChunks[x] = [];
      for (let y = 0; y < fieldY; y++) {
        tileChunks[x][y] = document.createElement('canvas');
        tileChunks[x][y].width = 32;
        tileChunks[x][y].height = 32; }}}

  function createBigChunks() {

  }

  function setTileChunk() {
    
  }

  function fillChunks() {
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        for (let yy = 0; yy < 32; yy++) {
          for (let xx = 0; xx < 32; xx++) {
            tileChunks[x][y].getContext("2d").drawImage((inRange(xx + (x * 32)) && inRange(yy + (y * 32))) ? 
              drawTile1[map[xx + (x * 32)][yy + (y * 32)]] : drawTile1[0], xx, yy); }}
        canvas.offscreenCanvas.getContext("2d").drawImage(tileChunks[x][y], x * 32, y * 32); }}}

  function drawBuffer() {
    ctx.drawImage(canvas.offscreenCanvas, 0, 0); }

	function drawMap() {
		let size = 32;
    let key;
    let land;
    let tile;
    let outlineColor;

    // draw first layer (land/biome) //
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        land = map[x + cameraX][y + cameraY];
        ctx.drawImage(canvasImages[0][land][(tileOwned[x + cameraX][y + cameraY]) ? 1 : 0], x * 32, y * 32);
        /*outlineColor = (tileOwned[x + cameraX][y + cameraY]) ? 
          "rgba(0,0,255,0.35)" : "rgba(0,0,0,0.05)";
        drawRectangle(x * 32, y * 32, size, size, true, true,
          biomeDraws[land], outlineColor, "1");*/ }}

    // draw selected tile || tile @ cursor position //
    let rect = (selectedTileX || selectedTileY) 
      ? [(selectedTileX - cameraX) * 32, (selectedTileY - cameraY) * 32, 32, 32] 
      : [cursorMapX * 32, cursorMapY * 32, 32, 32];
    //drawRectangle(rect[0], rect[1], rect[2], rect[3], false, true, "black", "darkgray");
    drawMenu(rect[0], rect[1], rect[2], rect[3], ()=>{}, 0, "white", "1");
    clickLock = false;

    // draw second layer (tiles)
    for (let y = 0; y < fieldY; y++) {
      for (let x = 0; x < fieldX; x++) {
        //if (tileMap.has(padXYZ(x + cameraX, y + cameraY, 0))) { // if explored
          tile = tiles[x + cameraX][y + cameraY];
          if (Number.isInteger(tile) && tile != 0) {
            if (tile >= 2 && tile < tileNames.length ) {
              xyz = padXYZ(x + cameraX, y + cameraY, 0);
              shade = (buildings.has(xyz)) ? min(buildings.get(xyz).condition / 100, 0.2) : 0;
              if (shade) { ctx.globalAlpha = shade; }
              ctx.drawImage(canvasImages[tile], x * 32, y * 32);
              if (shade) { ctx.globalAlpha = defaultAlpha }}
            else {
              drawRectangle(x * 32, y * 32, size, size, true, false, "black"); }
          }
        //}
        //else { // else fog
        //  drawRectangle(x * 32, y * 32, size, size, true, false, "rgba(0,0,0,0.7)"); }
      }
    }

    // trace the domain to show available lands for purchase //
    if (buyLand) {
      traceProperty(manorX, manorY); }

    // draw second layer index value on top of each tile //
    if (tileIndex) {
    	for (let y = 0; y < fieldY; y++) {
    		for (let x = 0; x < fieldX; x++) {
          drawText(tiles[x + cameraX][y + cameraY], 8 + x * 32, 28 + y * 32, "30px Arial"); }}}
  }

  function drawMod() {

  }

  function drawText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4, canvas = ctx) {
    canvas.font = font;
    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.strokeText(text, x, y); }
    canvas.fillStyle = color;
    canvas.fillText(text, x, y); }

  // 32px Lucida Console has width of ~19
  function drawWrappedText(text, x, y, font = "24px Arial", color = "black", 
      stroke = false, strokeColor = "black", strokeWidth = 4, canvas = ctx,
      size = Number(font.slice(0, 2)), iX = 0, iY = size) {
    x += size + Math.floor(size * 1/16);
    y += size + Math.floor(size * 7/8);
    canvas.font = font;
    for (i = 0; i < text.length; i++) {
      if (stroke) {
        canvas.strokeStyle = strokeColor;
        canvas.lineWidth = strokeWidth;
        canvas.strokeText(text[i], x + (i * iX), y + (i * iY)); }
      canvas.fillStyle = color;
      canvas.fillText(text[i], x + (i * iX), y + (i * iY)); }
  }

  function drawRectangle(x, y, width, height, fill = true, stroke = true,
      fillColor = "black", strokeColor = "black", strokeWidth = "3", canvas = ctx) {
    canvas.beginPath();
    canvas.rect(x, y, width, height);
    if (fill) { 
      canvas.fillStyle = fillColor; 
      canvas.fill();
    if (stroke) { 
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }}}

  function drawTriangle(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 2, canvas = ctx) {
    size = 0;
    /*
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    */
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 28 * scale, y + 28 * scale - size);
    canvas.lineTo(x + 4 * scale, y + 28 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill();
  }
  
  function drawTree(x, y) {
    ctx.beginPath();
    ctx.moveTo(x + 16, y + 4);
    ctx.lineTo(x + 28, y + 10);
    ctx.lineTo(x + 20, y + 10);
    ctx.lineTo(x + 28, y + 14);
    ctx.lineTo(x + 20, y + 14);
    ctx.lineTo(x + 28, y + 18);
    ctx.lineTo(x + 4, y + 18);
    ctx.lineTo(x + 12, y + 14);
    ctx.lineTo(x + 4, y + 14);
    ctx.lineTo(x + 12, y + 10);
    ctx.lineTo(x + 4, y + 10);
    ctx.lineTo(x + 16, y + 4);
    ctx.lineTo(x + 4, y + 28);
    ctx.fillStyle = "green";
    ctx.fill();
    ctx.beginPath();
    ctx.rect(x + 14, y + 18, 4, 10);
    ctx.fillStyle = "saddlebrown";
    ctx.fill();
  }

  function drawHouse(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 3, canvas = ctx) {
    let size = 0;
    /*
    if (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] > 1) {
      size = 4 * (tileLevel[Math.floor(x / 32) + cameraX][Math.floor(y / 32) + cameraY] - 1);
      // Bug if house drawn to UI on a leveled up tile
    }
    */
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 28 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 25 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 25 * scale, y + 28 * scale);
    canvas.lineTo(x + 7 * scale, y + 28 * scale);
    canvas.lineTo(x + 7 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 4 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill(); }

  function drawBuilding(x, y, scale, color, stroke = false,
      strokeColor = "black", strokeWidth = 3, canvas = ctx) {
    let size = 0;
    canvas.beginPath();
    canvas.moveTo(x + 16 * scale, y + 4 * scale - size);
    canvas.lineTo(x + 27 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 27 * scale, y + 28 * scale);
    canvas.lineTo(x + 5 * scale, y + 28 * scale);
    canvas.lineTo(x + 5 * scale, y + 16 * scale - size);
    canvas.lineTo(x + 16 * scale, y + 4 * scale - size);

    if (stroke) {
      canvas.strokeStyle = strokeColor;
      canvas.lineWidth = strokeWidth;
      canvas.stroke(); }
    canvas.fillStyle = color;
    canvas.fill(); }

  function drawArmy(x, y, scale, color, c = ctx) {
    c.beginPath();
    c.fillStyle = color;
    c.arc(x + (16 * scale), y + (10 * scale), 6 * scale, 0, Math.PI * 2, true);
    c.moveTo(x + 16 * scale, y + 16 * scale);
    c.lineTo(x + 24 * scale, y + 28 * scale);
    c.lineTo(x + 8 * scale, y + 28 * scale);
    c.fill(); }

  function drawCapitol() {
    drawRectangle((manorX - cameraX) * 32 + 4, (manorY - cameraY) * 32 + 4, 24, 24,
      true, true, "rgba(169,169,169,0.35)", "rgba(0,0,0,0.5)");
    drawRectangle((manorX - cameraX) * 32 + 10, (manorY - cameraY) * 32 + 10, 12, 12,
      true, false, "rgba(0,0,0,0.8)");
  }

  function menuSizer(length, minx = 3, maxx = 8) {
    return range2(Math.ceil(Math.sqrt(length / 2)), minx, maxx); }

  function draw2dMenu(x, y, width, height, elements = [], id = 0, c = 0, scale = 2 * tileScale,
        color = "rgba(0,0,0,0.05)", strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3") {
    let size = menuSizer(elements.length);
    width = (scale) + (2 * size * 32) + ((2 * size) * (scale / 2));
    height = (scale) + (size * 32) + (size * (scale / 2));
    let hover = (contains(x, y, width, height, cursorX, cursorY)) ? true : false;
    let hoverFunc = (unit) => {
      sketchMenu(cursorX + 32, cursorY + 32, 4 * scale, 2 * scale);
      drawText(unit.name[0] + " " + unit.name[1], cursorX + 0 + 64, cursorY + 10 + 64, "24px Arial", "lightgray", true);
      //drawText(pages[id], cursorX + 0 + 64, cursorY + 10 + 32, "24px Arial", "lightgray", true);
      drawText(unit.ssn, cursorX + 0 + 64, cursorY + 10 + 96, "24px Arial", "lightgray", true);
      drawText(unit.stats, cursorX + 0 + 64, cursorY + 10 + 128, "24px Arial", "lightgray", true);
    };
    let hoverUnit = null;
    let w = Math.floor((width - scale) / scale);
    let padx = scale / 2;
    let h = Math.floor((height - scale) / scale);
    let pady = scale / 2;
    c = pages[id] * 128;
    if (hover) { 
      strokeColor = "rgba(256,256,256,1)";
      if (clickLock == false && clickEnd != 0) {
        pages[id] = (elements.length - c < w * h) ? 0 : pages[id] + 1;
        clickLock = true; }}
    sketchMenu(x, y, width, height, color, strokeColor);
    /*drawMenu(x, y, width, height, (elements.length - c < w * h) ? ()=>{ 
      if (!clickLock) { pages[7] = 0; clickLock = true; }} : ()=>{ 
      if (!clickLock) { pages[7]++; clickLock = true; console.log("Plus Ultra!"); }});*/
    for (yy = 0; yy < h; yy++) {
      for (xx = 0; xx < w; xx++) {
          let hover2 = (contains(x + padx + xx * scale, y + pady + yy * scale, scale, scale, cursorX, cursorY)) ? true : false;
          ctx.drawImage((hover2) ? canvasObjects[0][1] : canvasObjects[0][0], x + padx + xx * scale, y + pady + yy * scale, scale, scale);
          ctx.drawImage(units[c].iCan, x + padx + xx * scale, y + pady + yy * scale, scale, scale);
          //sketchMenu(x + padx + xx * scale, y + pady + yy * scale, scale, scale,
          //    color);//, (hover2) ? "rgba(255,255,255,1)" : strokeColor, (hover2) ? "5" : strokeWidth);
          if (hover2) {
              clickLock = true;
              hoverUnit = units[c];
          }
          c++;
          if (c == elements.length) { if (hoverUnit) { hoverFunc(hoverUnit); } return; }
      }
    }
    if (hoverUnit) { hoverFunc(hoverUnit); }
  }
  /// 0: Level (LVL) = Stats
  /// 1: Health (HP) = 20 + (Level(0)/10 + Tenacity(1)) * (5 * Physique(2))
  /// 2: Attack (ATK) = (1 + Valor(5)) * (2 * Precision(4) + Physique(2))
  /// 3: Defense (DEF) = (1 + Valor(5)) * (2 * Tenacity(1) + Physique(2))
  /// 4: Speed (SPD) = 120 - Expertise(9) - (Agility(3) * Physique(2))
  /// 5: Affinity (SPD) = (3 * (Valor(5) + Expertise(9))) + (2 * (Intellect(7) + Wisdom(8))) 
  function drawStats(x, y, width, height, unit) {
    drawMenu(x, y, width, height);
    drawText("Level : " + (unit.stats.reduce((a, b) => a + b)), x + 224, y + 64, "24px Arial", "lightgray", true);
    drawText("Health : " + (20 + ((Math.ceil((unit.stats.reduce((a, b) => a + b) + 1) / 10) + unit.stats[1]) * (5 * unit.stats[2]))), x + 64, y + 128, "24px Arial", "lightgray", true);
    drawText("Attack : " + ((1 + unit.stats[5]) * (2 * unit.stats[4] + unit.stats[2])), x + 384, y + 128, "24px Arial", "lightgray", true);
    drawText("Defense : " + ((1 + unit.stats[5]) * (2 * unit.stats[1] + unit.stats[2])), x + 384, y + 224, "24px Arial", "lightgray", true);
    drawText("Speed : " + (120 - unit.stats[9] - (unit.stats[3] * unit.stats[2])), x + 64, y + 224, "24px Arial", "lightgray", true);
    drawText("Affinity : " + ((3 * (unit.stats[5] + unit.stats[9])) + (2 * (unit.stats[7] + unit.stats[8]))), x + 224, y + 512, "24px Arial", "lightgray", true);
    drawMenu(x + 32, y + 8 + 288, 256, 32, (unit = units[selectedUnit]) => { unit.stats[0]++; });
    drawText("Experience : " + unit.stats[0], x + 64, y + 320, "24px Arial", "lightgray", true);
    drawMenu(x + 32, y + 8 + 320, 256, 32, (unit = units[selectedUnit]) => { unit.stats[1]++; });
    drawText("Tenacity : " + unit.stats[1], x + 64, y + 352, "24px Arial", "lightgray", true);
    drawMenu(x + 32, y + 8 + 352, 256, 32, (unit = units[selectedUnit]) => { unit.stats[2]++; });
    drawText("Physique : " + unit.stats[2], x + 64, y + 384, "24px Arial", "lightgray", true);
    drawMenu(x + 32, y + 8 + 384, 256, 32, (unit = units[selectedUnit]) => { unit.stats[3]++; });
    drawText("Agility : " + unit.stats[3], x + 64, y + 416, "24px Arial", "lightgray", true);
    drawMenu(x + 32, y + 8 + 416, 256, 32, (unit = units[selectedUnit]) => { unit.stats[4]++; });
    drawText("Precision : " + unit.stats[4], x + 64, y + 448, "24px Arial", "lightgray", true);
    drawMenu(x + 352, y + 8 + 288, 256, 32, (unit = units[selectedUnit]) => { unit.stats[5]++; });
    drawText("Valor : " + unit.stats[5], x + 384, y + 320, "24px Arial", "lightgray", true);
    drawMenu(x + 352, y + 8 + 320, 256, 32, (unit = units[selectedUnit]) => { unit.stats[6]++; });
    drawText("Charisma : " + unit.stats[6], x + 384, y + 352, "24px Arial", "lightgray", true);
    drawMenu(x + 352, y + 8 + 352, 256, 32, (unit = units[selectedUnit]) => { unit.stats[7]++; });
    drawText("Intellect : " + unit.stats[7], x + 384, y + 384, "24px Arial", "lightgray", true);
    drawMenu(x + 352, y + 8 + 384, 256, 32, (unit = units[selectedUnit]) => { unit.stats[8]++; });
    drawText("Wisdom : " + unit.stats[8], x + 384, y + 416, "24px Arial", "lightgray", true);
    drawMenu(x + 352, y + 8 + 416, 256, 32, (unit = units[selectedUnit]) => { unit.stats[9]++; });
    drawText("Expertise : " + unit.stats[9], x + 384, y + 448, "24px Arial", "lightgray", true);
  }

  function sketchMenu(x, y, width, height, color = "rgba(0,0,0,0.05)",
        strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3", text = false) {
    drawRectangle(x, y, width, height, true, true, color, strokeColor);
  }

  function drawMenu(x, y, width, height, func = (() => {}), id = 0, 
      strokeColor = "rgba(0,0,0,0.25)", strokeWidth = "3", hoverFunc = (() => {}),
      color = "rgba(0,0,0,0.05)", items = menuLogic, texts = menuText, length = items[id].length) {
    let isML = (items == menuLogic) ? true : false;
    if (id == 7 && isML) { length = units.length; }
    else if (selectedUnit && id == 12 && isML) { length = units[selectedUnit].events.length; height += 32; }
    let overflow = (length <= 8) ? 0 : (8 * menuPage);
    length = length - overflow;
    let menuLength = (length <= 8) ? length : 9;
    if (menuLength <= 0) { menuPage = 0; }
    height += ((id == 12 && isML) ? 32 : 64) * (menuLength - 1);
    if (contains(x, y, width, height, cursorX, cursorY) && id != 7) {
      clickLock = true;
      strokeColor = "rgba(255,255,255,1)";
      strokeWidth = "5";
      { (clickEnd != 0 || selectedTile) ? func() : hoverFunc(); } // selectedTile??
    }
    if (id == 7) {
      draw2dMenu(x, y, width, height, units, 7);
    }
    else if (id == 10) { // stats menu
      drawStats(x, y, width * 2, height, units[selectedUnit]);
    }
    else { drawRectangle(x, y, width, height, true, true, color, strokeColor); }

    if (id != 0) {
      for (let i = 1 + overflow; i < menuLength + overflow; i++) {
        if (id == 7 || id == 10) { 
          //  draw2dMenu(x, y, width, height, units, 7);
          /*hoverFunc = (() => { 
            drawMenu(cursorX + 25, cursorY + 25, 320, 96);
            drawText(units[i].name, cursorX + 25 + 32, cursorY + 32 + 32, "24px Arial", "lightgray", true);
            drawText(units[i].stats, cursorX + 25 + 32, cursorY + 32 + 64, "24px Arial", "lightgray", true); });
          drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288, 32, () => { selectUnit(units[i]) }, 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
          drawText("Unit " + units[i].ssn, x + 32, y - 8 + (64 * (i - overflow)), "24px Arial", "lightgray", true);*/ }
        else if (id == 11){
          let unit = units[selectedUnit];
          drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288, 32, items[id][i], 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
          drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288 * (unit.skills[0][i] / (10 * unit.skills[i])), 32, items[id][i], 0, "rgba(55,55,55,0.25)", "3");
          drawText("" + texts[id][i] + " : " + unit.skills[i], x + 32, y - 8 + (64 * (i - overflow)), "24px Arial", "lightgray", true);
        }
        else if (selectedUnit && id == 12 && isML) { 
          let unit = units[selectedUnit];
          let event = unit.events[i - 1];
          let text = (typeof event == "number") ? extractText(event) : event;
          let hoverText = (typeof event != "number") ? event
            : ["Event ID: " + event, extractText(Math.floor(event / 10))];
          hoverFunc = (() => {
            if (Array.isArray(hoverText)) { 
              let h = 32 * hoverText[1].length;
              drawMenu(cursorX + 25, cursorY + 25, 320, 64 + h);
              drawText(hoverText[0], cursorX + 25 + 32, cursorY + 32 + 32, "24px Arial", "lightgray", true);
              for (let ii = 0; ii < hoverText[1].length; ii++) {
                if (event == Math.floor(event / 10) * 10 + ii) { drawMenu(cursorX + 25, cursorY + 72 + (32 * ii), 320, 32); }
                drawText(hoverText[1][ii], cursorX + 25 + 32, cursorY + 96 + (32 * ii), "24px Arial", "lightgray", true); }
            }
            else {
              drawMenu(cursorX + 25, cursorY + 25, 320, 64);
              drawText(hoverText, cursorX + 25 + 32, cursorY + 32 + 32, "24px Arial", "lightgray", true); }
          })
          //drawText(text, 128+16, 224 + (32 * i));
          drawMenu(x + 16, y - 32 + 32 + (32 * (i - overflow)), 288, 32, () => {}, 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
          drawText(text, x + 32, y - 8 + 32 + (32 * (i - overflow)), "24px Arial", "lightgray", true); }
        else {
          drawMenu(x + 16, y - 32 + (64 * (i - overflow)), 288, 32, items[id][i], 0, "rgba(0,0,0,0.25)", "3", hoverFunc);
          drawText(texts[id][i], x + 32, y - 8 + (64 * (i - overflow)), "24px Arial", "lightgray", true); }}}}
        // CURRENTLY CLICK TO CHANGE PAGE, NEED BUTTON FOR OVERFLOW MENUS

  function drawMenuElements() {

  }

  function getMenuElement() {

  }

  function selectUnit(unit) {
    clearUI();
    selectTile(unit.home.x, unit.home.y);
    selectedUnit = unit.ssn; }

  function drawTileUnits(tile, height, width) {
    drawMenu((fieldX - 11) * 32, 32 + height + 32, width, 192);
    drawText("Production: " + (tile.production), (fieldX - 10) * 32, height + 96, "30px Arial", "White");
    let func = (tile instanceof Army) ? () => { armies.get(selectedArmy).setTask(1); } : () => {};
    drawMenu((fieldX - 3) * 32, 32 + height + 32, 64, 64, func);
    drawArmy((fieldX - 3) * 32, 32 + height + 32, 2, "rgba(0,0,200,.5)");
	  let ssns = [ ...tile.units.keys() ];
      for (i = 0; i < ssns.length; i++) {
        drawMenu((fieldX - 11) * 32, 128 + height + (32 * (i)), width, 32,
          () => { selectedUnit = ssns[i]; });
        drawText(units[ssns[i]].name + ": " + units[ssns[i]].stats, 
          (fieldX - 11) * 32 + 24, 160 + height - 8 + (32 * (i)), "24px Arial", "lightgray", true); }}

  function drawObj() {
    drawCapitol();

    // draw all standing armies //
    let key = [ ...armies.keys() ];
    let army = [ ...armies.values() ];
    for (i = 0; i < key.length; i++) {
      let location = sliceXYZ(key[i]);
      drawArmy((location.x - cameraX) * 32 + army[i].tileX, (location.y - cameraY) * 32
        + army[i].tileY, 1, army[i].color); }}
        
  function drawUI() {
    let rect;
    let font;
    let color;
    let x;
    let y;
    let key = padXYZ(manorX, manorY, 0);

    if (buildLand != 0) {
      ctx.drawImage(canvasImages[buildLand], cursorMapX * 32, cursorMapY * 32); }

    // draw toolbar at top of screen //
    font = "30px Arial";
    drawText(cameraX, 8, 28, font);
    drawText(cameraY, 8 + 54, 28, font);
    drawText(manorBank[0] / 100, 8 + 112, 28, font, "silver");
    drawText("Food: " + manorBank[1], 8 + 112, 28 + 32, font, "red");
    drawText("Lumber: " + manorBank[2], 8 + 112 + 148, 28 + 32, font, "brown");
    drawText("Stone: " + manorBank[3], 8 + 112 + 320, 28 + 32, font, "gray");
    drawText("Ore: " + manorBank[4], 8 + 112 + 460, 28 + 32, font, "dark gray");
    drawText(fieldX, 8 + 176, 28, font);
    drawText(fieldY, 8 + 230, 28, font);
    drawText(fps, 8, 28 + 32, font);

    // info menu button
    rect = [32, 64, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[1][0]);
    ctx.font = "60px Arial";
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillText("i", 57, 118);

    // home menu button
    rect = [32, 160, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[2][0]);
    drawHouse(rect[0], rect[1], 2, "rgba(69,69,69,0.7)", true);

    // army menu button
    rect = [32, 256, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[3][0]);
    drawArmy(rect[0], rect[1], 2, "rgba(0,0,200,.5)")

    // lovely button
    rect = [32, 352, 64, 64];
    drawMenu(rect[0], rect[1], rect[2], rect[3], menuLogic[4][0]);

    if (menus[1] != 0) {
        let width = 320;
        let height = 160;
        if (selectedTileX || selectedTileY) {
        x = selectedTileX;
        y = selectedTileY;
        if (![0,1,2,3].includes(tiles[x][y])) {
            height = 384; } }
        else {
        x = cameraX + cursorMapX;
        y = cameraY + cursorMapY; }


        if (!isMobile) {
            // draw tooltip menu //
            drawMenu((fieldX - 11) * 32, 32, 320, 112);
            drawText(biomeNames[map[x][y]], (fieldX - 10) * 32, 64, font, color);
            drawText(tileNames[tiles[x][y]], (fieldX - 10) * 32, 96, font, color);
            drawText("Owned: " + tileOwned[x][y]/*((!tileMap.has(padXYZ(x, y, 0))) ? false : true)*/, (fieldX - 10) * 32, 128, font, color);
            // if tile has logic, draw expanded tooltip menu elements //
            if (![0,1].includes(tiles[x][y])) {
                //drawText("Level: " + tileLevel[x][y], (fieldX - 10) * 32, 250, font, color);
                //drawText("Condition: " + buildings.get(padXYZ(x, y, 0)).condition,
                //  (fieldX - 10) * 32, 300, font, color);
                //drawText("Pay In: ", (fieldX - 10) * 32, 350, font, color);
            }
            // draw tile action menu //
            if (menus[1] > 1) {
                drawMenu((fieldX - 11) * 32, 160, 320, 32, ()=>{}, menus[1],
                    "rgba(0,0,0,0.25)", "3", ()=>{}, "rgba(0,0,0,0.05)");
            } 
            else {
                drawMenu((fieldX - 11) * 32, 160, 320, 32, ()=>{}, tiles[x][y],
                    "rgba(0,0,0,0.25)", "3", ()=>{}, "rgba(0,0,0,0.05)", tileActionIndex.funcs, tileActionIndex.names); }
        }

        // if army is selected, draw underlying units info below tooltip menu //
        key = padXYZ(x, y, 0);
        if (armies.has(key)) {
            army = armies.get(key);
            drawTileUnits(army, height, width); }
        if (buildings.has(key)) {
            building = buildings.get(key);
            drawTileUnits(building, height, width); }
        if (selectedUnit && menus[0] == 0) {
            let unit = units[selectedUnit];
            drawText(unit.name + " " + unit.ssn, 128 + 16, 88);
            drawMenu(128, 64, 320, 32, menuLogic[9][0], 9); }}

    // if main menu is active, draw from index with embedded menuLogic[] //
    if (menus[0] != 0) {
      drawMenu(128, 64, 320, 32, menuLogic[menus[0]][0], menus[0]); }

    if (notifications.length > 0) {
      //drawFeed();
      drawTextBox(notifications[notifications.length-1].text, (fieldX - 11)*tileScale, (fieldY - 4)*tileScale, 10*tileScale, 32, 16, true);
    }
  }

  function clearUI() {
    menus[0] = 0;
    menus[1] = 1;
    menuPage = 0;
    nextPage = false;
    buildLand = 0;
    buyLand = false;
    tileIndex = false;
    selectedTileX = 0;
    selectedTileY = 0;
    selectedUnit = null;
    selectedArmy = null;
    selectedBuilding = null;
    showUI = true;
    showTech = false;
    showMissionText = false;
    showMap = false; }

  // draw technology tree //
  function drawTech() {
    if (clickLock) { clickEnd = 0; } // spend click on first pass //
    let x;
    let y;
    for (i = 0; i < 5; i++) {
      for (ii = 0; ii < techs[i].length; ii++) {
        x = 64 + (i * 192);
        y = 64 + (ii * 96);

        if (techs[i][ii].researched) {
          drawMenu(x, y, 160, 64, () => {}, 0, "rgba(255,255,255,1)"); }
        else if (techAvailable(techs[i][ii])) {
          drawMenu(x, y, 160, 64, () => { techs[i][ii].researched = true; }, 0, "rgba(0,255,0,1)"); }
        else {
          drawMenu(x, y, 160, 64); }

        drawText(techs[i][ii].name, x + 32, y - 8, "24px Arial", "lightgray", true); }}
  }

  function drawMainMenu() {
    drawRectangle(0, 0, canvas.width, canvas.height);
    let x = fieldX / 2 * 32;
    let y = fieldY / 2 * 32;
    if (map.length > 10) { 
        for (yi = 0; yi < 32; yi++) {
            for (xi = 0; xi < 68; xi++) {
                ctx.drawImage(microImages[map[cameraX + xi][cameraY + yi]],
                x - 272 + (8 * xi), y - 256 + (8 * yi));
            }
        }
    }
    drawMenu(x - 272, y - 256, 544, 256, ()=>{}, 0,
      "LightGray", "20", ()=>{}, "rgba(32,32,32,0.8)");
    drawText("BitWorld", x - 256 + 25, y - 160 + 58, "bold 96px Courier New", "Gray", true, "LightGray");
    drawMenu(x - 576 - 32, y + 32, 256, 96, () => { generateMap(); mainMenu = false; /*openFullscreen();*/ },
      0, "BlueViolet", "10", ()=>{}, "rgba(55,55,55,1)");
    drawText("RESET", x-576-32+76, y+32+58, "32px Arial", "White", true, "Indigo");
    drawMenu(x - 256 - 32, y + 32, 256, 96, () => { setMap(); mainMenu = false; /*openFullscreen();*/ },
      0, "BlueViolet", "10", ()=>{}, "rgba(55,55,55,1)");
    drawText("SINGLE", x-256-32+76, y+32+58, "32px Arial", "White", true, "Indigo");
    drawMenu(x + 32, y + 32, 256, 96, () => { (authCode) ? setMap() : getAuth(); mainMenu = false; },
      0, "BlueViolet", "10", ()=>{}, "rgba(55,55,55,1)");
    drawText("MULTI", x+32+76, y+32+58, "32px Arial", "White", true, "Indigo");
  }

  function drawError(string = "Oops") {
    animations[2].set(Date.now(), new Effect(() => { drawText(string, fieldX / 3 * tileScale, fieldY / 2 * tileScale, "48px Courier New") }, 60)); }

  function drawMissionText() {
    drawTextBox(extractText(missionProgress, missionIndex), 
      fieldX / 2 * 32 - 256, fieldY * 32 - 288, 512, 256, 32, false,
      () => { missionProgress = nextEvent(missionProgress, missionIndex); });
  }

  function drawTextBox(text, x = fieldX / 2 * 32 - 256, y = fieldY * 32 - 288, width = 512, height = 256, 
    textSize = 32, autoHeight = false, onClick = ()=>{}) {
    let wrap = wrapText(text, Math.ceil((width - (2 * textSize)) / (textSize * 19/32)));
    if (autoHeight) {
      height = height + (tileScale * Math.ceil((wrap.length * textSize) / 32));
    }
    drawMenu(x, y, width, height, onClick);
    drawWrappedText(wrap, x, y, textSize + "px Lucida Console", "White", true);
  }

  function drawFeed() {
    for (i = (notifactions.length > 8) ? notifications.length - 8 : 0; i < notifications.length; i++) {
      drawTextBox(notifications[i].text, (fieldX - 11)*tileScale, (fieldY - 4)*tileScale, 10*tileScale, 32, 16, true); }}

  function changeField(x = window.innerWidth, y = window.innerHeight) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		ctx.canvas.width = x;
		ctx.canvas.height = y;
    //ctx.canvas.offscreenCanvas.width = x;
    //ctx.canvas.offscreenCanvas.height = y;
		fieldX = Math.ceil(ctx.canvas.width / 32);
		fieldY = Math.ceil(ctx.canvas.height / 32); }

  // draw canvas elements //
	async function draw() {
    clickLock = false;
    if (!showMap) {changeField();}
		
    if (mainMenu) {
      drawMainMenu();
    }
    else if (showMap && bufferCompleted) {
      drawBuffer();
      drawText(fps, 8, 28 + 32);
    }
    else { 
      drawMap();
      drawMod();
      drawObj();
      if (showMissionText) { drawMissionText(); }
      if (showUI) { drawUI(); }
      if (showTech) { drawTech(); }
      // top layer animations, errors //
      if (animations[2].size > 0) {
        let keys = [ ...animations[2].keys()];
        for (i = 0; i < keys.length; i++) {
          let effect = animations[2].get(keys[i]);
          effect.draw();
          effect.frame--;
          if (effect.frame == 0) { animations[2].delete(keys[i]); }}
      }
    }
    
    if (selectedTile) { 
      if (!clickLock) { clickActions(); }
      else { getCursorXY(null, selectedTile[0], selectedTile[1]); 
        clickStart = 0; }
      cursorMoved = 0;
      selectedTile = 0; }
    clickEnd = 0;
  }

  function bufferDraw() {

  }

  if (isMobile) {
    let el = document.getElementsByTagName("canvas")[0];
    el.addEventListener("touchstart", touchStart);
    el.addEventListener("touchmove", touchMoved);
    el.addEventListener("touchend", touchEnd);
    //el.addEventListener("touchcancel", handleCancel);
  }
  else {
    window.onload = init;
    function init() {
      if (window.Event) {
        document.captureEvents(Event.MOUSEMOVE); }
      document.onmousemove = getCursorXY; }
    document.addEventListener("mousedown", mouseDownHandler, false);
    document.addEventListener("mouseup", mouseUpHandler, false);
  }
  
  function touchStart(e) {
    selectedTile = [cursorX, cursorY];
    getCursorXY(e, e.touches[0].clientX, e.touches[0].clientY);
    mouseDownHandler(e);
    e.preventDefault();
  }

  function touchEnd(e) {
    mouseUpHandler(e);
    e.preventDefault();
  }

  function touchMoved(e) {
    getCursorXY(e, e.touches[0].clientX, e.touches[0].clientY);
  }

  function mouseDownHandler(e) {
    clickStart = [[cursorX, cursorY], Date.now()];

    if (!clickLock && !selectedTile) { clickActions(); }

    if (buyLand) {
      let x = manorX;
      let y = manorY;
      do {
        y = y + movement[1][4];
      } while (tileOwned[x][y]);

      let xi = x;
      let yi = y;
      let direction = (tileOwned[xi + 1][yi]) ? 4 : 1;
      if (manorBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
        tileOwned[xi][yi] = true;
        manorBank[0] -= 10;
        return; }

      xi = xi + movement[0][direction];
      yi = yi + movement[1][direction];

      do {
        if (manorBank[0] >= 10 && contains((xi - cameraX) * 32, (yi - cameraY) * 32, 32, 32, cursorX, cursorY)) {
          tileOwned[xi][yi] = true;
          manorBank[0] -= 10;
          return; }

        direction = loop(direction + 1, 1, 4);
        if (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]) {
          do {
            direction = loop(direction - 1, 1, 4);
          } while (tileOwned[xi + movement[0][direction]][yi + movement[1][direction]]); }

        xi = xi + movement[0][direction];
        yi = yi + movement[1][direction];

        if (xi == x && yi == y) { return; }
      } while (true); }}

  function clickActions(e) {
    selectTile(cameraX + cursorMapX, cameraY + cursorMapY);

    if (selectedArmy) {
      let army = armies.get(selectedArmy);
      let location = sliceXYZ(selectedArmy);
      let destination = new GPS(cameraX + cursorMapX, cameraY + cursorMapY, 0);
      army.moveX = (destination.x) - location.x;
      army.moveY = (destination.y) - location.y;
      army.task = 0;
      army.action = 0;
      if (!army.task && (tiles[destination.x][destination.y] == 3
        || tiles[destination.x][destination.y] == 4)) {
          army.setTask(2, new Contract(destination.toString(), selectedArmy, 0, 
            [army.units.size, tiles[destination.x][destination.y]])); }}
  }

  function mouseUpHandler(e) {
    if (clickStart) {
      clickEnd = Date.now() - clickStart[1];
      clickStart = 0;
      cursorMoved = 0; }
    console.log(clickEnd);
  }

  function selectTile(x, y) {
    if (x == selectedTileX && y == selectedTileY) {
      selectedTileX = 0; selectedTileY = 0;
      selectedBuilding = null; selectedArmy = null; }
    else {
      selectedTileX = x;
      selectedTileY = y;
      let key = padXYZ(x, y, 0);
      if (buildings.has(key)) { selectedBuilding = key; }
      if (armies.has(key)) { selectedArmy = key; } }}

  function getCursorXY(e, x = e.clientX, y = e.clientY) {
    let rect = canvas.getBoundingClientRect();
    cursorX = (x - rect.left) / (rect.right - rect.left) * canvas.width;
    cursorY = (y - rect.top) / (rect.bottom - rect.top) * canvas.height;
    cursorMapX = Math.floor(cursorX / 32);
    cursorMapY = Math.floor(cursorY / 32); }


  function openFullscreen() {
    if (canvas.requestFullscreen) { canvas.requestFullscreen(); }
    else if (canvas.mozRequestFullScreen) { /* Firefox */
      canvas.mozRequestFullScreen(); }
    else if (canvas.webkitRequestFullscreen) { /* Chrome, Safari and Opera */
      canvas.webkitRequestFullscreen(); }
    else if (canvas.msRequestFullscreen) { /* IE/Edge */
      canvas.msRequestFullscreen(); }}

  const times = [];
  let fps;
  function refreshLoop() {
    window.requestAnimationFrame(() => {
      const now = performance.now();
      while (times.length > 0 && times[0] <= now - 1000) {
        times.shift(); }
      times.push(now);
      fps = times.length;
      refreshLoop(); }); }

  // uploadData();

  let tileDrawFuncs = [
    (x, y, color = "black", toStroke = false) => { 
      drawRectangle(x, y, 32, 32, true, toStroke, color, "rgba(0,0,0,0.05)", "1"); }, 
    (x, y) => {}, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, false, "darkblue", "black", "0", ctxImages[2]); },
    (x, y) => { 
      ctxImages[3].beginPath();
      ctxImages[3].moveTo(x + 16, y + 8);
      ctxImages[3].lineTo(x + 24, y + 24);
      ctxImages[3].lineTo(x + 8, y + 24);
      ctxImages[3].lineTo(x + 16, y + 8);
      ctxImages[3].fillStyle = "#6E2C00";
      ctxImages[3].strokeStyle = "black";
      ctxImages[3].lineWidth = "2";
      ctxImages[3].stroke();
      ctxImages[3].fill(); },
    (x, y) => { drawTriangle(x, y, 1, "rgba(150,150,150,0.7)", true, "black", "3", ctxImages[4]); },
    (x, y) => { drawHouse(x, y, 1, "rgba(69,69,69,0.7)", true, "black", "3", ctxImages[5]); },
    (x, y) => { drawBuilding(x, y, 1, "rgba(69,69,69,0.7)", true, "black", "3", ctxImages[6]); },
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[7]);
      drawText("M", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[7]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[8]);
      drawText("L", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[8]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[9]);
      drawText("C", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[9]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[10]);
      drawText("BS", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[10]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[11]);
      drawText("S", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[11]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[12]);
      drawText("$", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[12]); }, 
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[13]);
      drawText("P", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[13]); },
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[14]);
      drawText("R", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[14]); },
    (x, y) => { drawRectangle(x, y, 32, 32, true, true, "black", "black", "3", ctxImages[15]);
      drawText("I", x + 6, y + 26, "24px Arial", "White", true, "black", "1", ctxImages[15]); }]

  // Draw Images to Canvas Cache
  drawRectangle(0, 0, 64, 64, true, true, "rgba(0,0,0,0.05)", "rgba(0,0,0,0.25)", "3", ctxObjects[0][0]);
  drawRectangle(0, 0, 64, 64, true, true, "rgba(0,0,0,0.05)", "rgba(255,255,255,1)", "5", ctxObjects[0][1]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[0], "rgba(0,0,0,0.05)", "1", ctxImages[0][0][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[0], "rgba(0,0,255,0.35)", "1", ctxImages[0][0][1]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[1], "rgba(0,0,0,0.05)", "1", ctxImages[0][1][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[1], "rgba(0,0,255,0.35)", "1", ctxImages[0][1][1]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[2], "rgba(0,0,0,0.05)", "1", ctxImages[0][2][0]);
  drawRectangle(0, 0, 32, 32, true, true, biomeDraws[2], "rgba(0,0,255,0.35)", "1", ctxImages[0][2][1]);
  tileDrawFuncs[1](0, 0);
  tileDrawFuncs[2](0, 0);
  tileDrawFuncs[3](0, 0);
  tileDrawFuncs[4](0, 0);
  tileDrawFuncs[5](0, 0);
  tileDrawFuncs[6](0, 0);
  tileDrawFuncs[7](0, 0);
  tileDrawFuncs[8](0, 0);
  tileDrawFuncs[9](0, 0);
  tileDrawFuncs[10](0, 0);
  tileDrawFuncs[11](0, 0);
  tileDrawFuncs[12](0, 0);
  tileDrawFuncs[13](0, 0);
  tileDrawFuncs[14](0, 0);
  tileDrawFuncs[15](0, 0);
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[0], "black", "1", microImages[0].getContext('2d'));
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[1], "black", "1", microImages[1].getContext('2d'));
  drawRectangle(0, 0, 8, 8, true, false, biomeDraws[2], "black", "1", microImages[2].getContext('2d'));
  drawRectangle(0, 0, 1, 1, true, false, biomeDraws[0], "black", "1", drawTile1[0].getContext('2d'));
  drawRectangle(0, 0, 1, 1, true, false, biomeDraws[1], "black", "1", drawTile1[1].getContext('2d'));
  drawRectangle(0, 0, 1, 1, true, false, biomeDraws[2], "black", "1", drawTile1[2].getContext('2d'));

////////////////////////////////////////////////////////////////////////////////////////////////////////

  function main() {
    //if (refreshCanvas) { setTimeout(bufferDraw, 50); }
  }

  startWorker();
  Workers.get('NetWorker').postMessage(['GET', null]);
  if (window.location.href.indexOf("=") > -1) { checkAuth(); }
  refreshLoop();
  //setInterval(main, 20);
  setInterval(logic, 20);
  setInterval(logic1000, 1000);
  setInterval(logic5000, 5000);
  setInterval(draw, 20);
</script>

</body>
</html>
